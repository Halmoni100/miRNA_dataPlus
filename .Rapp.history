# Retrieve Data#
# raw_data retreived#
load("R_Data/saved_raw_data")#
#
#transpose data for PCA analysis#
raw_data_trans <- t(raw_data)#
dimnames(raw_data_trans) <- c(NULL, NULL)#
#
#PCA analysis#
#source:http://gastonsanchez.com/blog/how-to/2012/06/17/PCA-in-R.html#
pca1 = prcomp(raw_data_trans, scale. = TRUE)#
#
# Graph PCA#
pca_result <- pca1$x#
pca_comp_1 <- pca_result[,1]#
pca_comp_2 <- pca_result[,2]#
pca_comp_3 <- pca_result[,3]#
#
pca_comp_1_viral <- pca_comp_1[1:21]#
pca_comp_1_baseline <- pca_comp_1[22:42]#
pca_comp_1_bacteria <- pca_comp_1[43:52]#
pca_comp_2_viral <- pca_comp_2[1:21]#
pca_comp_2_baseline <- pca_comp_2[22:42]#
pca_comp_2_bacteria <- pca_comp_2[43:52]#
pca_comp_3_viral <- pca_comp_3[1:21]#
pca_comp_3_baseline <- pca_comp_3[22:42]#
pca_comp_3_bacteria <- pca_comp_3[43:52]
# Retrieve Data#
# raw_data retreived#
load("R_Data/saved_raw_data")#
#
#transpose data for PCA analysis#
raw_data_trans <- t(raw_data)#
dimnames(raw_data_trans) <- c(NULL, NULL)#
#
#PCA analysis#
#source:http://gastonsanchez.com/blog/how-to/2012/06/17/PCA-in-R.html#
pca1 = prcomp(raw_data_trans, scale. = TRUE)#
#
# Graph PCA#
pca_result <- pca1$x#
pca_comp_1 <- pca_result[,1]#
pca_comp_2 <- pca_result[,2]#
pca_comp_3 <- pca_result[,3]#
#
pca_comp_1_viral <- pca_comp_1[1:21]#
pca_comp_1_baseline <- pca_comp_1[22:42]#
pca_comp_1_bacteria <- pca_comp_1[43:52]#
pca_comp_2_viral <- pca_comp_2[1:21]#
pca_comp_2_baseline <- pca_comp_2[22:42]#
pca_comp_2_bacteria <- pca_comp_2[43:52]#
pca_comp_3_viral <- pca_comp_3[1:21]#
pca_comp_3_baseline <- pca_comp_3[22:42]#
pca_comp_3_bacteria <- pca_comp_3[43:52]#
#
# PC 1 vs PC 2#
pca_comp_3_bacteria#
plot(pca_comp_1_viral,pca_comp_2_viral,col="red",#
		xlim=c(min(pca_comp_1), max(pca_comp_1)),#
		ylim=c(min(pca_comp_2), max(pca_comp_2)))#
points(pca_comp_1_baseline,pca_comp_2_baseline,col="green")#
points(pca_comp_1_bacteria,pca_comp_2_bacteria,col="blue")#
#
# PC 1 vs PC 3#
quartz()#
plot(pca_comp_1_viral,pca_comp_3_viral,col="red",#
		xlim=c(min(pca_comp_1), max(pca_comp_1)),#
		ylim=c(min(pca_comp_3), max(pca_comp_3)))#
points(pca_comp_1_baseline,pca_comp_3_baseline,col="green")#
points(pca_comp_1_bacteria,pca_comp_3_bacteria,col="blue")#
#
# PC 2 vs PC 3#
quartz()#
plot(pca_comp_2_viral,pca_comp_3_viral,col="red",#
		xlim=c(min(pca_comp_2), max(pca_comp_2)),#
		ylim=c(min(pca_comp_3), max(pca_comp_3)))#
points(pca_comp_2_baseline,pca_comp_3_baseline,col="green")#
points(pca_comp_2_bacteria,pca_comp_3_bacteria,col="blue")#
points(pca_comp_2_bacteria,pca_comp_3_bacteria,col="blue")
str(raw_data)
# Retrieve Data#
# raw_data retreived#
load("R_Data/saved_raw_data")#
#
# function to determine if all zeros#
all_zeros <- function(v) {#
    sum <- sum(v)#
    if (sum == 0) {#
        return(TRUE)#
    }#
    return(FALSE)#
}#
# Delete data w/ no info#
# Mark and delete all miRNAs with only zeros#
only_zeros <- apply(raw_data, 1, all_zeros)#
raw_data <- raw_data[!only_zeros,]#
#
#transpose data for PCA analysis#
raw_data_trans <- t(raw_data)#
dimnames(raw_data_trans) <- c(NULL, NULL)#
#
#PCA analysis#
#source:http://gastonsanchez.com/blog/how-to/2012/06/17/PCA-in-R.html#
pca1 = prcomp(raw_data_trans, scale. = TRUE)#
#
# Graph PCA#
pca_result <- pca1$x#
pca_comp_1 <- pca_result[,1]#
pca_comp_2 <- pca_result[,2]#
pca_comp_3 <- pca_result[,3]#
#
pca_comp_1_viral <- pca_comp_1[1:21]#
pca_comp_1_baseline <- pca_comp_1[22:42]#
pca_comp_1_bacteria <- pca_comp_1[43:52]#
pca_comp_2_viral <- pca_comp_2[1:21]#
pca_comp_2_baseline <- pca_comp_2[22:42]#
pca_comp_2_bacteria <- pca_comp_2[43:52]#
pca_comp_3_viral <- pca_comp_3[1:21]#
pca_comp_3_baseline <- pca_comp_3[22:42]#
pca_comp_3_bacteria <- pca_comp_3[43:52]#
#
# PC 1 vs PC 2#
plot(pca_comp_1_viral,pca_comp_2_viral,col="red",#
		xlim=c(min(pca_comp_1), max(pca_comp_1)),#
		ylim=c(min(pca_comp_2), max(pca_comp_2)))#
points(pca_comp_1_baseline,pca_comp_2_baseline,col="green")#
points(pca_comp_1_bacteria,pca_comp_2_bacteria,col="blue")#
#
# PC 1 vs PC 3#
quartz()#
plot(pca_comp_1_viral,pca_comp_3_viral,col="red",#
		xlim=c(min(pca_comp_1), max(pca_comp_1)),#
		ylim=c(min(pca_comp_3), max(pca_comp_3)))#
points(pca_comp_1_baseline,pca_comp_3_baseline,col="green")#
points(pca_comp_1_bacteria,pca_comp_3_bacteria,col="blue")#
#
# PC 2 vs PC 3#
quartz()#
plot(pca_comp_2_viral,pca_comp_3_viral,col="red",#
		xlim=c(min(pca_comp_2), max(pca_comp_2)),#
		ylim=c(min(pca_comp_3), max(pca_comp_3)))#
points(pca_comp_2_baseline,pca_comp_3_baseline,col="green")#
points(pca_comp_2_bacteria,pca_comp_3_bacteria,col="blue")#
points(pca_comp_2_bacteria,pca_comp_3_bacteria,col="blue")
paste("1st","2nd","3rd")
paste(1,2,3)
# Retrieve Data#
# processed_data retreived#
load("R_Data/saved_processed_data")#
#
# transpose data for PCA analysis#
proc_data_trans <- t(processed_data)#
#
# PCA analysis#
pca_df = prcomp(proc_data_trans, scale. = TRUE)#
#
# Set n#
n = 6#
#
# Get first n PCs, store in lists#
pca_result <- pca_df$x#
pcs_all = vector("list", n)#
pcs_viral = vector("list", n)#
pcs_baseline = vector("list", n)#
pcs_bacteria = vector("list", n)#
for (i in 1:n) {#
	pcs_all[[i]] = pca_result[,i]#
	pcs_viral[[i]] = pca_result[1:21,i]#
	pcs_baseline[[i]] = pca_result[22:42,i]#
	pcs_bacteria[[i]] = pca_result[43:52,i]#
}#
#
# Plot all combinations of PCs, store in files#
# red=viral, green=baseline, blue=bacteria#
for (i in 1:n-1) {#
	for (j in i+1:n) {#
		plot_name <- paste(i,"vs",j)#
		dir_name <- paste("Plots/PCA/processed_data/", plot_name, collapse=NULL)#
		jpeg(dir_name)#
		plot(pcs_viral[[i]], pcs_viral[[j]], col="red",#
				xlim=c(min(pcs_all[[i]]), max(pcs_all[[i]])),#
				ylim=c(min(pcs_all[[j]]), max(pcs_all[j])))#
		points(pcs_baseline[[i]], pcs_baseline[[j]], col="green")#
		points(pcs_bacteria[[i]], pcs_bacteria[[j]], col="blue")#
		dev.off()#
	}#
}
# Retrieve Data#
# processed_data retreived#
load("R_Data/saved_processed_data")#
#
# transpose data for PCA analysis#
proc_data_trans <- t(processed_data)#
#
# PCA analysis#
pca_df = prcomp(proc_data_trans, scale. = TRUE)#
#
# Set n#
n = 6#
#
# Get first n PCs, store in lists#
pca_result <- pca_df$x#
pcs_all = vector("list", n)#
pcs_viral = vector("list", n)#
pcs_baseline = vector("list", n)#
pcs_bacteria = vector("list", n)#
for (i in 1:n) {#
	pcs_all[i] = pca_result[,i]#
	pcs_viral[i] = pca_result[1:21,i]#
	pcs_baseline[i] = pca_result[22:42,i]#
	pcs_bacteria[i] = pca_result[43:52,i]#
}#
#
# Plot all combinations of PCs, store in files#
# red=viral, green=baseline, blue=bacteria#
for (i in 1:n-1) {#
	for (j in i+1:n) {#
		plot_name <- paste(i,"vs",j)#
		dir_name <- paste("Plots/PCA/processed_data/", plot_name, collapse=NULL)#
		jpeg(dir_name)#
		plot(pcs_viral[i], pcs_viral[j], col="red",#
				xlim=c(min(pcs_all[i]), max(pcs_all[i])),#
				ylim=c(min(pcs_all[j]), max(pcs_all[j])))#
		points(pcs_baseline[i], pcs_baseline[j], col="green")#
		points(pcs_bacteria[i], pcs_bacteria[j], col="blue")#
		dev.off()#
	}#
}
warnings()
class(pcs_all)
# Retrieve Data#
# processed_data retreived#
load("R_Data/saved_processed_data")#
#
# transpose data for PCA analysis#
proc_data_trans <- t(processed_data)#
#
# PCA analysis#
pca_df = prcomp(proc_data_trans, scale. = TRUE)#
#
# Set n#
n = 6#
#
# Get first n PCs, store in lists#
pca_result <- pca_df$x#
pcs_all = vector(mode="list", length=n)#
pcs_viral = vector(mode="list", length=n)#
pcs_baseline = vector(mode="list", length=n)#
pcs_bacteria = vector(mode="list", length=n)#
for (i in 1:n) {#
	pcs_all[[i]] = pca_result[,i]#
	pcs_viral[[i]] = pca_result[1:21,i]#
	pcs_baseline[[i]] = pca_result[22:42,i]#
	pcs_bacteria[[i]] = pca_result[43:52,i]#
}#
#
# Plot all combinations of PCs, store in files#
# red=viral, green=baseline, blue=bacteria#
for (i in 1:n-1) {#
	for (j in i+1:n) {#
		plot_name <- paste(i,"vs",j)#
		dir_name <- paste("Plots/PCA/processed_data/", plot_name, collapse=NULL)#
		jpeg(dir_name)#
		plot(pcs_viral[[i]], pcs_viral[[j], col="red",#
				xlim=c(min(pcs_all[[i]]), max(pcs_all[[i]])),#
				ylim=c(min(pcs_all[[j]]), max(pcs_all[[j]])))#
		points(pcs_baseline[[i]], pcs_baseline[[j]], col="green")#
		points(pcs_bacteria[[i]], pcs_bacteria[[j]], col="blue")#
		dev.off()#
	}#
}
# Retrieve Data#
# processed_data retreived#
load("R_Data/saved_processed_data")#
#
# transpose data for PCA analysis#
proc_data_trans <- t(processed_data)#
#
# PCA analysis#
pca_df = prcomp(proc_data_trans, scale. = TRUE)#
#
# Set n#
n = 6#
#
# Get first n PCs, store in lists#
pca_result <- pca_df$x#
pcs_all = vector(mode="list", length=n)#
pcs_viral = vector(mode="list", length=n)#
pcs_baseline = vector(mode="list", length=n)#
pcs_bacteria = vector(mode="list", length=n)#
for (i in 1:n) {#
	pcs_all[[i]] = pca_result[,i]#
	pcs_viral[[i]] = pca_result[1:21,i]#
	pcs_baseline[[i]] = pca_result[22:42,i]#
	pcs_bacteria[[i]] = pca_result[43:52,i]#
}#
#
# Plot all combinations of PCs, store in files#
# red=viral, green=baseline, blue=bacteria#
for (i in 1:n-1) {#
	for (j in i+1:n) {#
		plot.new()#
		frame()#
		plot_name <- paste(i,"vs",j)#
		dir_name <- paste("Plots/PCA/processed_data/", plot_name, collapse=NULL)#
		jpeg(dir_name)#
		plot(pcs_viral[[i]], pcs_viral[[j]], col="red",#
				xlim=c(min(pcs_all[[i]]), max(pcs_all[[i]])),#
				ylim=c(min(pcs_all[[j]]), max(pcs_all[[j]])))#
		points(pcs_baseline[[i]], pcs_baseline[[j]], col="green")#
		points(pcs_bacteria[[i]], pcs_bacteria[[j]], col="blue")#
		dev.off()#
	}#
}
warnings()
# Retrieve Data#
# processed_data retreived#
load("R_Data/saved_processed_data")#
#
# transpose data for PCA analysis#
proc_data_trans <- t(processed_data)#
#
# PCA analysis#
pca_df = prcomp(proc_data_trans, scale. = TRUE)#
#
# Set n#
n = 6#
#
# Get first n PCs, store in lists#
pca_result <- pca_df$x#
pcs_all = vector(mode="list", length=n)#
pcs_viral = vector(mode="list", length=n)#
pcs_baseline = vector(mode="list", length=n)#
pcs_bacteria = vector(mode="list", length=n)#
for (i in 1:n) {#
	i#
	pcs_all[[i]] = pca_result[,i]#
	pcs_viral[[i]] = pca_result[1:21,i]#
	pcs_baseline[[i]] = pca_result[22:42,i]#
	pcs_bacteria[[i]] = pca_result[43:52,i]#
}#
#
# Plot all combinations of PCs, store in files#
# red=viral, green=baseline, blue=bacteria#
for (i in 1:n-1) {#
	for (j in i+1:n) {#
		plot.new()#
		frame()#
		plot_name <- paste(i,"vs",j)#
		dir_name <- paste("Plots/PCA/processed_data/", plot_name, collapse=NULL)#
		jpeg(dir_name)#
		plot(pcs_viral[[i]], pcs_viral[[j]], col="red",#
				xlim=c(min(pcs_all[[i]]), max(pcs_all[[i]])),#
				ylim=c(min(pcs_all[[j]]), max(pcs_all[[j]])))#
		points(pcs_baseline[[i]], pcs_baseline[[j]], col="green")#
		points(pcs_bacteria[[i]], pcs_bacteria[[j]], col="blue")#
		dev.off()#
	}#
}
pcs_viral[[1]]
# Retrieve Data#
# processed_data retreived#
load("R_Data/saved_processed_data")#
#
# transpose data for PCA analysis#
proc_data_trans <- t(processed_data)#
#
# PCA analysis#
pca_df = prcomp(proc_data_trans, scale. = TRUE)#
#
# Set n#
n = 6#
#
# Get first n PCs, store in lists#
pca_result <- pca_df$x#
pcs_all = vector(mode="list", length=n)#
pcs_viral = vector(mode="list", length=n)#
pcs_baseline = vector(mode="list", length=n)#
pcs_bacteria = vector(mode="list", length=n)#
for (i in 1:n) {#
	i#
	pcs_all[[i]] = pca_result[,i]#
	pcs_viral[[i]] = pca_result[1:21,i]#
	pcs_baseline[[i]] = pca_result[22:42,i]#
	pcs_bacteria[[i]] = pca_result[43:52,i]#
}#
#
# Plot all combinations of PCs, store in files#
# red=viral, green=baseline, blue=bacteria#
for (i in 1:n-1) {#
	for (j in i+1:n) {#
		plot.new()#
		frame()#
		plot_name <- paste(i,"vs",j)#
		dir_name <- paste("Plots/PCA/processed_data/", plot_name, collapse=NULL)#
		jpeg(dir_name)#
		plot(pcs_viral[i], pcs_viral[j], col="red",#
				xlim=c(min(pcs_all[i]), max(pcs_all[i])),#
				ylim=c(min(pcs_all[j]), max(pcs_all[j])))#
		points(pcs_baseline[i], pcs_baseline[j], col="green")#
		points(pcs_bacteria[i], pcs_bacteria[j], col="blue")#
		dev.off()#
	}#
}
warnings()
# Retrieve Data#
# processed_data retreived#
load("R_Data/saved_processed_data")#
#
# transpose data for PCA analysis#
proc_data_trans <- t(processed_data)#
#
# PCA analysis#
pca_df = prcomp(proc_data_trans, scale. = TRUE)#
#
# Set n#
n = 2#
#
# Get first n PCs, store in lists#
pca_result <- pca_df$x#
pcs_all = vector(mode="list", length=n)#
pcs_viral = vector(mode="list", length=n)#
pcs_baseline = vector(mode="list", length=n)#
pcs_bacteria = vector(mode="list", length=n)#
for (i in 1:n) {#
	i#
	pcs_all[[i]] = pca_result[,i]#
	pcs_viral[[i]] = pca_result[1:21,i]#
	pcs_baseline[[i]] = pca_result[22:42,i]#
	pcs_bacteria[[i]] = pca_result[43:52,i]#
}#
#
# Plot all combinations of PCs, store in files#
# red=viral, green=baseline, blue=bacteria#
for (i in 1:n-1) {#
	for (j in i+1:n) {#
		plot.new()#
		frame()#
		plot_name <- paste(i,"vs",j)#
		dir_name <- paste("Plots/PCA/processed_data/", plot_name, collapse=NULL)#
		jpeg(dir_name)#
		plot(pcs_viral[i], pcs_viral[j], col="red",#
				xlim=c(min(pcs_all[i]), max(pcs_all[i])),#
				ylim=c(min(pcs_all[j]), max(pcs_all[j])))#
		points(pcs_baseline[i], pcs_baseline[j], col="green")#
		points(pcs_bacteria[i], pcs_bacteria[j], col="blue")#
		dev.off()#
	}#
}
warnings()
str(pcs_viral[1])
str(pcs_viral[2])
str(pcs_baseline[1])
str(pcs_baseline[2])
str(pcs_bacteria[1])
str(pcs_bacteria[2])
# Retrieve Data#
# processed_data retreived#
load("R_Data/saved_processed_data")#
#
# transpose data for PCA analysis#
proc_data_trans <- t(processed_data)#
#
# PCA analysis#
pca_df = prcomp(proc_data_trans, scale. = TRUE)#
#
# Set n#
n = 2#
#
# Get first n PCs, store in lists#
pca_result <- pca_df$x#
pcs_all = vector(mode="list", length=n)#
pcs_viral = vector(mode="list", length=n)#
pcs_baseline = vector(mode="list", length=n)#
pcs_bacteria = vector(mode="list", length=n)#
for (i in 1:n) {#
	i#
	pcs_all[[i]] = pca_result[,i]#
	pcs_viral[[i]] = pca_result[1:21,i]#
	pcs_baseline[[i]] = pca_result[22:42,i]#
	pcs_bacteria[[i]] = pca_result[43:52,i]#
}#
#
# Plot all combinations of PCs, store in files#
# red=viral, green=baseline, blue=bacteria#
for (i in 1:n-1) {#
	for (j in i+1:n) {#
		plot.new()#
		frame()#
		plot_name <- paste(i,"vs",j)#
		dir_name <- paste("Plots/PCA/processed_data/", plot_name, collapse=NULL)#
		jpeg(dir_name)#
		plot(pcs_viral[i], pcs_viral[j], col="red",#
				xlim=c(min(pcs_all[i]), max(pcs_all[i])),#
				ylim=c(min(pcs_all[j]), max(pcs_all[j])))#
		points(pcs_baseline[i], pcs_baseline[j], col="green")#
		points(pcs_bacteria[i], pcs_bacteria[j], col="blue")#
		dev.off()#
	}#
}
# Retrieve Data#
# processed_data retreived#
load("R_Data/saved_processed_data")#
#
# transpose data for PCA analysis#
proc_data_trans <- t(processed_data)#
#
# PCA analysis#
pca_df = prcomp(proc_data_trans, scale. = TRUE)#
#
# Set n#
n = 2#
#
# Get first n PCs, store in lists#
pca_result <- pca_df$x#
pcs_all = vector(mode="list", length=n)#
pcs_viral = vector(mode="list", length=n)#
pcs_baseline = vector(mode="list", length=n)#
pcs_bacteria = vector(mode="list", length=n)#
for (i in 1:n) {#
	i#
	pcs_all[[i]] = pca_result[,i]#
	pcs_viral[[i]] = pca_result[1:21,i]#
	pcs_baseline[[i]] = pca_result[22:42,i]#
	pcs_bacteria[[i]] = pca_result[43:52,i]#
}#
#
# Plot all combinations of PCs, store in files#
# red=viral, green=baseline, blue=bacteria#
for (i in 1:n-1) {#
	for (j in i+1:n) {#
		plot.new()#
		frame()#
		plot_name <- paste(i,"vs",j)#
		dir_name <- paste("Plots/PCA/processed_data/", plot_name, collapse=NULL)#
		jpeg(dir_name)#
		length(pcs_viral[i])#
		length(pcs_viral[j])#
		length(pcs_baseline[i])#
		length(pcs_baseline[j])#
		length(pcs_bacteria[i])#
		length(pcs_bacteria[j])#
		plot(pcs_viral[i], pcs_viral[j], col="red",#
				xlim=c(min(pcs_all[i]), max(pcs_all[i])),#
				ylim=c(min(pcs_all[j]), max(pcs_all[j])))#
		points(pcs_baseline[i], pcs_baseline[j], col="green")#
		points(pcs_bacteria[i], pcs_bacteria[j], col="blue")#
		dev.off()#
	}#
}
# Retrieve Data#
# processed_data retreived#
load("R_Data/saved_processed_data")#
#
# transpose data for PCA analysis#
proc_data_trans <- t(processed_data)#
#
# PCA analysis#
pca_df = prcomp(proc_data_trans, scale. = TRUE)#
#
# Set n#
n = 2#
#
# Get first n PCs, store in lists#
pca_result <- pca_df$x#
pcs_all = vector(mode="list", length=n)#
pcs_viral = vector(mode="list", length=n)#
pcs_baseline = vector(mode="list", length=n)#
pcs_bacteria = vector(mode="list", length=n)#
for (i in 1:n) {#
	i#
	pcs_all[[i]] = pca_result[,i]#
	pcs_viral[[i]] = pca_result[1:21,i]#
	pcs_baseline[[i]] = pca_result[22:42,i]#
	pcs_bacteria[[i]] = pca_result[43:52,i]#
}#
#
		length(pcs_viral[1])#
		length(pcs_viral[2])#
		length(pcs_baseline[1])#
		length(pcs_baseline[2])#
		length(pcs_bacteria[1])#
		length(pcs_bacteria[2])#
#
# Plot all combinations of PCs, store in files#
# red=viral, green=baseline, blue=bacteria#
for (i in 1:n-1) {#
	for (j in i+1:n) {#
		plot.new()#
		frame()#
		plot_name <- paste(i,"vs",j)#
		dir_name <- paste("Plots/PCA/processed_data/", plot_name, collapse=NULL)#
		jpeg(dir_name)#
		plot(pcs_viral[i], pcs_viral[j], col="red",#
				xlim=c(min(pcs_all[i]), max(pcs_all[i])),#
				ylim=c(min(pcs_all[j]), max(pcs_all[j])))#
		points(pcs_baseline[i], pcs_baseline[j], col="green")#
		points(pcs_bacteria[i], pcs_bacteria[j], col="blue")#
		dev.off()#
	}#
}
# Retrieve Data#
# processed_data retreived#
load("R_Data/saved_processed_data")#
#
# transpose data for PCA analysis#
proc_data_trans <- t(processed_data)#
#
# PCA analysis#
pca_df = prcomp(proc_data_trans, scale. = TRUE)#
#
# Set n#
n = 2#
#
# Get first n PCs, store in lists#
pca_result <- pca_df$x#
pcs_all = vector(mode="list", length=n)#
pcs_viral = vector(mode="list", length=n)#
pcs_baseline = vector(mode="list", length=n)#
pcs_bacteria = vector(mode="list", length=n)#
for (i in 1:n) {#
	i#
	pcs_all[[i]] = pca_result[,i]#
	pcs_viral[[i]] = pca_result[1:21,i]#
	pcs_baseline[[i]] = pca_result[22:42,i]#
	pcs_bacteria[[i]] = pca_result[43:52,i]#
}#
#
		length(pcs_viral[[1]])#
		length(pcs_viral[[2]])#
		length(pcs_baseline[[1]])#
		length(pcs_baseline[[2]])#
		length(pcs_bacteria[[1]])#
		length(pcs_bacteria[[2]])#
#
# Plot all combinations of PCs, store in files#
# red=viral, green=baseline, blue=bacteria#
for (i in 1:n-1) {#
	for (j in i+1:n) {#
		plot.new()#
		frame()#
		plot_name <- paste(i,"vs",j)#
		dir_name <- paste("Plots/PCA/processed_data/", plot_name, collapse=NULL)#
		jpeg(dir_name)#
		plot(pcs_viral[i], pcs_viral[j], col="red",#
				xlim=c(min(pcs_all[i]), max(pcs_all[i])),#
				ylim=c(min(pcs_all[j]), max(pcs_all[j])))#
		points(pcs_baseline[i], pcs_baseline[j], col="green")#
		points(pcs_bacteria[i], pcs_bacteria[j], col="blue")#
		dev.off()#
	}#
}
# Retrieve Data#
# processed_data retreived#
load("R_Data/saved_processed_data")#
#
# transpose data for PCA analysis#
proc_data_trans <- t(processed_data)#
#
# PCA analysis#
pca_df = prcomp(proc_data_trans, scale. = TRUE)#
#
# Set n#
n = 2#
#
# Get first n PCs, store in lists#
pca_result <- pca_df$x#
pcs_all = vector(mode="list", length=n)#
pcs_viral = vector(mode="list", length=n)#
pcs_baseline = vector(mode="list", length=n)#
pcs_bacteria = vector(mode="list", length=n)#
for (i in 1:n) {#
	i#
	pcs_all[[i]] = pca_result[,i]#
	pcs_viral[[i]] = pca_result[1:21,i]#
	pcs_baseline[[i]] = pca_result[22:42,i]#
	pcs_bacteria[[i]] = pca_result[43:52,i]#
}#
#
# Plot all combinations of PCs, store in files#
# red=viral, green=baseline, blue=bacteria#
for (i in 1:n-1) {#
	for (j in i+1:n) {#
		plot.new()#
		frame()#
		plot_name <- paste(i,"vs",j)#
		dir_name <- paste("Plots/PCA/processed_data/", plot_name, collapse=NULL)#
		jpeg(dir_name)#
		plot(pcs_viral[[i]], pcs_viral[[j]], col="red",#
				xlim=c(min(pcs_all[[i]]), max(pcs_all[[i]])),#
				ylim=c(min(pcs_all[[j]]), max(pcs_all[[j]])))#
		points(pcs_baseline[[i]], pcs_baseline[[j]], col="green")#
		points(pcs_bacteria[[i]], pcs_bacteria[[j]], col="blue")#
		dev.off()#
	}#
}
for (i in 1:3) {i}
or (i in 1:3) {print(i)}
for (i in 1:3) {print(i)}
warnings()
# Retrieve Data#
# processed_data retreived#
load("R_Data/saved_processed_data")#
#
# transpose data for PCA analysis#
proc_data_trans <- t(processed_data)#
#
# PCA analysis#
pca_df = prcomp(proc_data_trans, scale. = TRUE)#
#
# Set n#
n = 2#
#
# Get first n PCs, store in lists#
pca_result <- pca_df$x#
pcs_all = vector(mode="list", length=n)#
pcs_viral = vector(mode="list", length=n)#
pcs_baseline = vector(mode="list", length=n)#
pcs_bacteria = vector(mode="list", length=n)#
for (i in 1:n) {#
	pcs_all[[i]] = pca_result[,i]#
	pcs_viral[[i]] = pca_result[1:21,i]#
	pcs_baseline[[i]] = pca_result[22:42,i]#
	pcs_bacteria[[i]] = pca_result[43:52,i]#
}#
#
# Plot all combinations of PCs, store in files#
# red=viral, green=baseline, blue=bacteria#
for (i in 1:n-1) {#
	for (j in i+1:n) {#
		plot.new()#
		frame()#
		plot_name <- paste(i,"vs",j)#
		dir_name <- paste("Plots/PCA/processed_data/", plot_name, collapse=NULL)#
		jpeg(dir_name)#
		print(length(pcs_viral[[i]]))#
		print(length(pcs_viral[[j]]))#
		plot(pcs_viral[[i]], pcs_viral[[j]], col="red",#
				xlim=c(min(pcs_all[[i]]), max(pcs_all[[i]])),#
				ylim=c(min(pcs_all[[j]]), max(pcs_all[[j]])))#
		points(pcs_baseline[[i]], pcs_baseline[[j]], col="green")#
		points(pcs_bacteria[[i]], pcs_bacteria[[j]], col="blue")#
		dev.off()#
	}#
}
for (i in 1:n-1) {#
	print(pcs_viral[[i]])#
	for (j in i+1:n) {#
		plot.new()#
		frame()#
		plot_name <- paste(i,"vs",j)#
		dir_name <- paste("Plots/PCA/processed_data/", plot_name, collapse=NULL)#
		jpeg(dir_name)#
		plot(pcs_viral[[i]], pcs_viral[[j]], col="red",#
				xlim=c(min(pcs_all[[i]]), max(pcs_all[[i]])),#
				ylim=c(min(pcs_all[[j]]), max(pcs_all[[j]])))#
		points(pcs_baseline[[i]], pcs_baseline[[j]], col="green")#
		points(pcs_bacteria[[i]], pcs_bacteria[[j]], col="blue")#
		dev.off()#
	}#
}
for (i in 1:n-1) {#
	print(pcs_viral[[j]])#
	for (j in i+1:n) {#
		plot.new()#
		frame()#
		plot_name <- paste(i,"vs",j)#
		dir_name <- paste("Plots/PCA/processed_data/", plot_name, collapse=NULL)#
		jpeg(dir_name)#
		plot(pcs_viral[[i]], pcs_viral[[j]], col="red",#
				xlim=c(min(pcs_all[[i]]), max(pcs_all[[i]])),#
				ylim=c(min(pcs_all[[j]]), max(pcs_all[[j]])))#
		points(pcs_baseline[[i]], pcs_baseline[[j]], col="green")#
		points(pcs_bacteria[[i]], pcs_bacteria[[j]], col="blue")#
		dev.off()#
	}#
}
for (i in 1:n-1) {#
	print(i)#
	for (j in i+1:n) {#
		plot.new()#
		frame()#
		plot_name <- paste(i,"vs",j)#
		dir_name <- paste("Plots/PCA/processed_data/", plot_name, collapse=NULL)#
		jpeg(dir_name)#
		plot(pcs_viral[[i]], pcs_viral[[j]], col="red",#
				xlim=c(min(pcs_all[[i]]), max(pcs_all[[i]])),#
				ylim=c(min(pcs_all[[j]]), max(pcs_all[[j]])))#
		points(pcs_baseline[[i]], pcs_baseline[[j]], col="green")#
		points(pcs_bacteria[[i]], pcs_bacteria[[j]], col="blue")#
		dev.off()#
	}#
}
# Retrieve Data#
# processed_data retreived#
load("R_Data/saved_processed_data")#
#
# transpose data for PCA analysis#
proc_data_trans <- t(processed_data)#
#
# PCA analysis#
pca_df = prcomp(proc_data_trans, scale. = TRUE)#
#
# Set n#
n = 2#
#
# Get first n PCs, store in lists#
pca_result <- pca_df$x#
pcs_all = vector(mode="list", length=n)#
pcs_viral = vector(mode="list", length=n)#
pcs_baseline = vector(mode="list", length=n)#
pcs_bacteria = vector(mode="list", length=n)#
for (i in 1:n) {#
	pcs_all[[i]] = pca_result[,i]#
	pcs_viral[[i]] = pca_result[1:21,i]#
	pcs_baseline[[i]] = pca_result[22:42,i]#
	pcs_bacteria[[i]] = pca_result[43:52,i]#
}#
#
# Plot all combinations of PCs, store in files#
# red=viral, green=baseline, blue=bacteria#
from_i <- 1#
to_i <- n - 1#
to_j <- n#
for (i in from_i:to_i) {#
	from_j <- i + 1#
	for (j in from_j:to_j) {#
		plot.new()#
		frame()#
		plot_name <- paste(i,"vs",j)#
		dir_name <- paste("Plots/PCA/processed_data/", plot_name, collapse=NULL)#
		jpeg(dir_name)#
		plot(pcs_viral[[i]], pcs_viral[[j]], col="red",#
				xlim=c(min(pcs_all[[i]]), max(pcs_all[[i]])),#
				ylim=c(min(pcs_all[[j]]), max(pcs_all[[j]])))#
		points(pcs_baseline[[i]], pcs_baseline[[j]], col="green")#
		points(pcs_bacteria[[i]], pcs_bacteria[[j]], col="blue")#
		dev.off()#
	}#
}
# Retrieve Data#
# processed_data retreived#
load("R_Data/saved_processed_data")#
#
# transpose data for PCA analysis#
proc_data_trans <- t(processed_data)#
#
# PCA analysis#
pca_df = prcomp(proc_data_trans, scale. = TRUE)#
#
# Set n#
n = 2#
#
# Get first n PCs, store in lists#
pca_result <- pca_df$x#
pcs_all = vector(mode="list", length=n)#
pcs_viral = vector(mode="list", length=n)#
pcs_baseline = vector(mode="list", length=n)#
pcs_bacteria = vector(mode="list", length=n)#
for (i in 1:n) {#
	pcs_all[[i]] = pca_result[,i]#
	pcs_viral[[i]] = pca_result[1:21,i]#
	pcs_baseline[[i]] = pca_result[22:42,i]#
	pcs_bacteria[[i]] = pca_result[43:52,i]#
}#
#
# Plot all combinations of PCs, store in files#
# red=viral, green=baseline, blue=bacteria#
from_i <- 1#
to_i <- n - 1#
to_j <- n#
for (i in from_i:to_i) {#
	from_j <- i + 1#
	for (j in from_j:to_j) {#
		#plot.new()#
		#frame()#
		#plot_name <- paste(i,"vs",j)#
		#dir_name <- paste("Plots/PCA/processed_data/", plot_name, collapse=NULL)#
		#jpeg(dir_name)#
		plot(pcs_viral[[i]], pcs_viral[[j]], col="red",#
				xlim=c(min(pcs_all[[i]]), max(pcs_all[[i]])),#
				ylim=c(min(pcs_all[[j]]), max(pcs_all[[j]])))#
		points(pcs_baseline[[i]], pcs_baseline[[j]], col="green")#
		points(pcs_bacteria[[i]], pcs_bacteria[[j]], col="blue")#
		#dev.off()#
	}#
}
quartz()
# Retrieve Data#
# processed_data retreived#
load("R_Data/saved_processed_data")#
#
# transpose data for PCA analysis#
proc_data_trans <- t(processed_data)#
#
# PCA analysis#
pca_df = prcomp(proc_data_trans, scale. = TRUE)#
#
# Set n#
n = 2#
#
# Get first n PCs, store in lists#
pca_result <- pca_df$x#
pcs_all = vector(mode="list", length=n)#
pcs_viral = vector(mode="list", length=n)#
pcs_baseline = vector(mode="list", length=n)#
pcs_bacteria = vector(mode="list", length=n)#
for (i in 1:n) {#
	pcs_all[[i]] = pca_result[,i]#
	pcs_viral[[i]] = pca_result[1:21,i]#
	pcs_baseline[[i]] = pca_result[22:42,i]#
	pcs_bacteria[[i]] = pca_result[43:52,i]#
}#
#
# Plot all combinations of PCs, store in files#
# red=viral, green=baseline, blue=bacteria#
from_i <- 1#
to_i <- n - 1#
to_j <- n#
for (i in from_i:to_i) {#
	from_j <- i + 1#
	for (j in from_j:to_j) {#
		plot.new()#
		frame()#
		plot_name <- paste(i,"vs",j)#
		dir_name <- paste("Plots/PCA/processed_data/", plot_name, ".jpeg", collapse=NULL)#
		jpeg(dir_name)#
		plot(pcs_viral[[i]], pcs_viral[[j]], col="red",#
				xlim=c(min(pcs_all[[i]]), max(pcs_all[[i]])),#
				ylim=c(min(pcs_all[[j]]), max(pcs_all[[j]])))#
		points(pcs_baseline[[i]], pcs_baseline[[j]], col="green")#
		points(pcs_bacteria[[i]], pcs_bacteria[[j]], col="blue")#
		dev.off()#
	}#
}
# Retrieve Data#
# processed_data retreived#
load("R_Data/saved_processed_data")#
#
# transpose data for PCA analysis#
proc_data_trans <- t(processed_data)#
#
# PCA analysis#
pca_df = prcomp(proc_data_trans, scale. = TRUE)#
#
# Set n#
n = 2#
#
# Get first n PCs, store in lists#
pca_result <- pca_df$x#
pcs_all = vector(mode="list", length=n)#
pcs_viral = vector(mode="list", length=n)#
pcs_baseline = vector(mode="list", length=n)#
pcs_bacteria = vector(mode="list", length=n)#
for (i in 1:n) {#
	pcs_all[[i]] = pca_result[,i]#
	pcs_viral[[i]] = pca_result[1:21,i]#
	pcs_baseline[[i]] = pca_result[22:42,i]#
	pcs_bacteria[[i]] = pca_result[43:52,i]#
}#
#
# Plot all combinations of PCs, store in files#
# red=viral, green=baseline, blue=bacteria#
from_i <- 1#
to_i <- n - 1#
to_j <- n#
for (i in from_i:to_i) {#
	from_j <- i + 1#
	for (j in from_j:to_j) {#
		plot.new()#
		frame()#
		plot_name <- paste(i,"vs",j)#
		dir_name <- paste("Plots/PCA/processed_data/", plot_name, ".jpeg", collapse="")#
		jpeg(dir_name)#
		plot(pcs_viral[[i]], pcs_viral[[j]], col="red",#
				xlim=c(min(pcs_all[[i]]), max(pcs_all[[i]])),#
				ylim=c(min(pcs_all[[j]]), max(pcs_all[[j]])))#
		points(pcs_baseline[[i]], pcs_baseline[[j]], col="green")#
		points(pcs_bacteria[[i]], pcs_bacteria[[j]], col="blue")#
		dev.off()#
	}#
}
# Retrieve Data#
# processed_data retreived#
load("R_Data/saved_processed_data")#
#
# transpose data for PCA analysis#
proc_data_trans <- t(processed_data)#
#
# PCA analysis#
pca_df = prcomp(proc_data_trans, scale. = TRUE)#
#
# Set n#
n = 6#
#
# Get first n PCs, store in lists#
pca_result <- pca_df$x#
pcs_all = vector(mode="list", length=n)#
pcs_viral = vector(mode="list", length=n)#
pcs_baseline = vector(mode="list", length=n)#
pcs_bacteria = vector(mode="list", length=n)#
for (i in 1:n) {#
	pcs_all[[i]] = pca_result[,i]#
	pcs_viral[[i]] = pca_result[1:21,i]#
	pcs_baseline[[i]] = pca_result[22:42,i]#
	pcs_bacteria[[i]] = pca_result[43:52,i]#
}#
#
# Plot all combinations of PCs, store in files#
# red=viral, green=baseline, blue=bacteria#
from_i <- 1#
to_i <- n - 1#
to_j <- n#
for (i in from_i:to_i) {#
	from_j <- i + 1#
	for (j in from_j:to_j) {#
		plot.new()#
		frame()#
		plot_name <- paste(i,"vs",j)#
		dir_name <- paste("Plots/PCA/processed_data/", plot_name, ".jpeg", collapse="", res=500)#
		jpeg(dir_name)#
		plot(pcs_viral[[i]], pcs_viral[[j]], col="red",#
				xlim=c(min(pcs_all[[i]]), max(pcs_all[[i]])),#
				ylim=c(min(pcs_all[[j]]), max(pcs_all[[j]])))#
		points(pcs_baseline[[i]], pcs_baseline[[j]], col="green")#
		points(pcs_bacteria[[i]], pcs_bacteria[[j]], col="blue")#
		dev.off()#
	}#
}
# Retrieve Data#
# processed_data retreived#
load("R_Data/saved_processed_data")#
#
# transpose data for PCA analysis#
proc_data_trans <- t(processed_data)#
#
# PCA analysis#
pca_df = prcomp(proc_data_trans, scale. = TRUE)#
#
# Set n#
n = 6#
#
# Get first n PCs, store in lists#
pca_result <- pca_df$x#
pcs_all = vector(mode="list", length=n)#
pcs_viral = vector(mode="list", length=n)#
pcs_baseline = vector(mode="list", length=n)#
pcs_bacteria = vector(mode="list", length=n)#
for (i in 1:n) {#
	pcs_all[[i]] = pca_result[,i]#
	pcs_viral[[i]] = pca_result[1:21,i]#
	pcs_baseline[[i]] = pca_result[22:42,i]#
	pcs_bacteria[[i]] = pca_result[43:52,i]#
}#
#
# Plot all combinations of PCs, store in files#
# red=viral, green=baseline, blue=bacteria#
from_i <- 1#
to_i <- n - 1#
to_j <- n#
for (i in from_i:to_i) {#
	from_j <- i + 1#
	for (j in from_j:to_j) {#
		plot.new()#
		frame()#
		plot_name <- paste(i,"vs",j)#
		dir_name <- paste("Plots/PCA/processed_data/", plot_name, ".jpeg", collapse="")#
		jpeg(dir_name, res=500)#
		plot(pcs_viral[[i]], pcs_viral[[j]], col="red",#
				xlim=c(min(pcs_all[[i]]), max(pcs_all[[i]])),#
				ylim=c(min(pcs_all[[j]]), max(pcs_all[[j]])))#
		points(pcs_baseline[[i]], pcs_baseline[[j]], col="green")#
		points(pcs_bacteria[[i]], pcs_bacteria[[j]], col="blue")#
		dev.off()#
	}#
}
# Retrieve Data#
# processed_data retreived#
load("R_Data/saved_processed_data")#
#
# transpose data for PCA analysis#
proc_data_trans <- t(processed_data)#
#
# PCA analysis#
pca_df = prcomp(proc_data_trans, scale. = TRUE)#
#
# Set n#
n = 6#
#
# Get first n PCs, store in lists#
pca_result <- pca_df$x#
pcs_all = vector(mode="list", length=n)#
pcs_viral = vector(mode="list", length=n)#
pcs_baseline = vector(mode="list", length=n)#
pcs_bacteria = vector(mode="list", length=n)#
for (i in 1:n) {#
	pcs_all[[i]] = pca_result[,i]#
	pcs_viral[[i]] = pca_result[1:21,i]#
	pcs_baseline[[i]] = pca_result[22:42,i]#
	pcs_bacteria[[i]] = pca_result[43:52,i]#
}#
#
# Plot all combinations of PCs, store in files#
# red=viral, green=baseline, blue=bacteria#
from_i <- 1#
to_i <- n - 1#
to_j <- n#
for (i in from_i:to_i) {#
	from_j <- i + 1#
	for (j in from_j:to_j) {#
		plot.new()#
		frame()#
		plot_name <- paste(i,"vs",j)#
		dir_name <- paste("Plots/PCA/processed_data/", plot_name, ".jpeg", collapse="")#
		jpeg(dir_name)#
		plot(pcs_viral[[i]], pcs_viral[[j]], col="red",#
				xlim=c(min(pcs_all[[i]]), max(pcs_all[[i]])),#
				ylim=c(min(pcs_all[[j]]), max(pcs_all[[j]])))#
		points(pcs_baseline[[i]], pcs_baseline[[j]], col="green")#
		points(pcs_bacteria[[i]], pcs_bacteria[[j]], col="blue")#
		dev.off()#
	}#
}
# Retrieve Data#
# processed_data retreived#
load("R_Data/saved_processed_data")#
#
# transpose data for PCA analysis#
proc_data_trans <- t(processed_data)#
#
# PCA analysis#
pca_df = prcomp(proc_data_trans, scale. = TRUE)#
#
# Set n#
n = 6#
#
# Get first n PCs, store in lists#
pca_result <- pca_df$x#
pcs_all = vector(mode="list", length=n)#
pcs_viral = vector(mode="list", length=n)#
pcs_baseline = vector(mode="list", length=n)#
pcs_bacteria = vector(mode="list", length=n)#
for (i in 1:n) {#
	pcs_all[[i]] = pca_result[,i]#
	pcs_viral[[i]] = pca_result[1:21,i]#
	pcs_baseline[[i]] = pca_result[22:42,i]#
	pcs_bacteria[[i]] = pca_result[43:52,i]#
}#
#
# Plot all combinations of PCs, store in files#
# red=viral, green=baseline, blue=bacteria#
from_i <- 1#
to_i <- n - 1#
to_j <- n#
for (i in from_i:to_i) {#
	from_j <- i + 1#
	for (j in from_j:to_j) {#
		plot.new()#
		frame()#
		plot_name <- paste(i,"vs",j)#
		dir_name <- paste("Plots/PCA/processed_data/", plot_name, ".jpeg", collapse="")#
		jpng(dir_name, 500, 500)#
		plot(pcs_viral[[i]], pcs_viral[[j]], col="red",#
				xlim=c(min(pcs_all[[i]]), max(pcs_all[[i]])),#
				ylim=c(min(pcs_all[[j]]), max(pcs_all[[j]])))#
		points(pcs_baseline[[i]], pcs_baseline[[j]], col="green")#
		points(pcs_bacteria[[i]], pcs_bacteria[[j]], col="blue")#
		dev.off()#
	}#
}
# Retrieve Data#
# processed_data retreived#
load("R_Data/saved_processed_data")#
#
# transpose data for PCA analysis#
proc_data_trans <- t(processed_data)#
#
# PCA analysis#
pca_df = prcomp(proc_data_trans, scale. = TRUE)#
#
# Set n#
n = 6#
#
# Get first n PCs, store in lists#
pca_result <- pca_df$x#
pcs_all = vector(mode="list", length=n)#
pcs_viral = vector(mode="list", length=n)#
pcs_baseline = vector(mode="list", length=n)#
pcs_bacteria = vector(mode="list", length=n)#
for (i in 1:n) {#
	pcs_all[[i]] = pca_result[,i]#
	pcs_viral[[i]] = pca_result[1:21,i]#
	pcs_baseline[[i]] = pca_result[22:42,i]#
	pcs_bacteria[[i]] = pca_result[43:52,i]#
}#
#
# Plot all combinations of PCs, store in files#
# red=viral, green=baseline, blue=bacteria#
from_i <- 1#
to_i <- n - 1#
to_j <- n#
for (i in from_i:to_i) {#
	from_j <- i + 1#
	for (j in from_j:to_j) {#
		plot_name <- paste(i,"vs",j)#
		dir_name <- paste("Plots/PCA/processed_data/", plot_name, ".jpeg", collapse="")#
		jpeg(dir_name)#
		plot(pcs_viral[[i]], pcs_viral[[j]], col="red",#
				xlim=c(min(pcs_all[[i]]), max(pcs_all[[i]])),#
				ylim=c(min(pcs_all[[j]]), max(pcs_all[[j]])))#
		points(pcs_baseline[[i]], pcs_baseline[[j]], col="green")#
		points(pcs_bacteria[[i]], pcs_bacteria[[j]], col="blue")#
		dev.off()#
	}#
}
# Retrieve Data#
# processed_data retreived#
load("R_Data/saved_raw_data")#
# get rid of all non-zero counts to create a vector#
nonzero_data <- subset(v, v > 0)#
# UQ normalization function#
UQNorm <- function(v) {#
    nonzero_data <- subset(v, v > 0)#
    quartiles <- quantile(nonzero_data)#
    uq <- quartiles[4]#
    return(uq)#
} #
# vector of Us needed to normalize data#
Us <- apply(raw_data, 2, UQNorm)#
# finding mean of the of the uq samples#
U <- mean(Us)#
# load processed data#
load("R_Data/saved_processed_data")#
#
uqnorm <- matrix(, nrow=nrow(processed_data), ncol=ncol(processed_data))#
#
# doing a for loop to normalize on each sample#
for (i in 1:ncol(processed_data)) {#
	colneeded <- processed_data[,i]#
	uqnorm[,i] <- colneeded/Us[i]*U#
}#
# all code below here is adapted from http://davetang.org/muse/2014/07/07/quantile-normalisation-in-r/#
# create quantile normalization function#
quantile_normalization <- function(uqnorm) {#
	uqnorm_rank <- apply(uqnorm, 2, rank, ties.method="min")#
	uqnorm_sorted <- data.frame(apply(uqnorm, 2, sort))#
	uqnorm_mean <- apply(uqnorm_sorted, 1, mean)#
	index_to_mean <- function (my_index, my_mean) {#
		return (my_mean[my_index])#
	}#
	uqnorm_final <- apply(uqnorm_rank, 2, index_to_mean, my_mean = uqnorm_mean)#
	return(uqnorm_final)#
}#
#
# test the function#
quantile_norm_data <- quantile_normalization(uqnorm)#
#
# graph the normalized data on a histogram#
hist(quantile_norm_data)
# Retrieve Data#
# processed_data retreived#
load("R_Data/saved_raw_data")#
# get rid of all non-zero counts to create a vector#
nonzero_data <- subset(v, v > 0)#
# UQ normalization function#
UQNorm <- function(v) {#
    nonzero_data <- subset(v, v > 0)#
    quartiles <- quantile(nonzero_data)#
    uq <- quartiles[4]#
    return(uq)#
} #
# vector of Us needed to normalize data#
Us <- apply(raw_data, 2, UQNorm)#
# finding mean of the of the uq samples#
U <- mean(Us)#
# load processed data#
load("R_Data/saved_processed_data")#
#
uqnorm <- matrix(, nrow=nrow(processed_data), ncol=ncol(processed_data))#
#
# doing a for loop to normalize on each sample#
for (i in 1:ncol(processed_data)) {#
	colneeded <- processed_data[,i]#
	uqnorm[,i] <- colneeded/Us[i]*U#
}#
#
PCA(uqnorm, 4)
# Retrieve Data#
# processed_data retreived#
load("R_Data/saved_raw_data")#
# get rid of all non-zero counts to create a vector#
nonzero_data <- subset(v, v > 0)#
# UQ normalization function#
UQNorm <- function(v) {#
    nonzero_data <- subset(v, v > 0)#
    quartiles <- quantile(nonzero_data)#
    uq <- quartiles[4]#
    return(uq)#
} #
# vector of Us needed to normalize data#
Us <- apply(raw_data, 2, UQNorm)#
# finding mean of the of the uq samples#
U <- mean(Us)#
# load processed data#
load("R_Data/saved_processed_data")#
#
uqnorm <- matrix(, nrow=nrow(processed_data), ncol=ncol(processed_data))#
#
# doing a for loop to normalize on each sample#
for (i in 1:ncol(processed_data)) {#
	colneeded <- processed_data[,i]#
	uqnorm[,i] <- colneeded/Us[i]*U#
}#
#
PCA <- dget("PCA.R")#
PCA(uqnorm, 4)
# Retrieve Data#
# processed_data retreived#
load("R_Data/saved_raw_data")#
# get rid of all non-zero counts to create a vector#
nonzero_data <- subset(v, v > 0)#
# UQ normalization function#
UQNorm <- function(v) {#
    nonzero_data <- subset(v, v > 0)#
    quartiles <- quantile(nonzero_data)#
    uq <- quartiles[4]#
    return(uq)#
} #
# vector of Us needed to normalize data#
Us <- apply(raw_data, 2, UQNorm)#
# finding mean of the of the uq samples#
U <- mean(Us)#
# load processed data#
load("R_Data/saved_processed_data")#
#
uqnorm <- matrix(, nrow=nrow(processed_data), ncol=ncol(processed_data))#
#
# doing a for loop to normalize on each sample#
for (i in 1:ncol(processed_data)) {#
	colneeded <- processed_data[,i]#
	uqnorm[,i] <- colneeded/Us[i]*U#
}#
#
PCA <- dget("PCA")#
PCA(uqnorm, 4)
# Retrieve Data#
# processed_data retreived#
load("R_Data/saved_raw_data")#
# get rid of all non-zero counts to create a vector#
nonzero_data <- subset(v, v > 0)#
# UQ normalization function#
UQNorm <- function(v) {#
    nonzero_data <- subset(v, v > 0)#
    quartiles <- quantile(nonzero_data)#
    uq <- quartiles[4]#
    return(uq)#
} #
# vector of Us needed to normalize data#
Us <- apply(raw_data, 2, UQNorm)#
# finding mean of the of the uq samples#
U <- mean(Us)#
# load processed data#
load("R_Data/saved_processed_data")#
#
uqnorm <- matrix(, nrow=nrow(processed_data), ncol=ncol(processed_data))#
#
# doing a for loop to normalize on each sample#
for (i in 1:ncol(processed_data)) {#
	colneeded <- processed_data[,i]#
	uqnorm[,i] <- colneeded/Us[i]*U#
}#
#
PCA <- dget("PCA.r")#
PCA(uqnorm, 4)
# Retrieve Data#
# processed_data retreived#
load("R_Data/saved_raw_data")#
# get rid of all non-zero counts to create a vector#
nonzero_data <- subset(v, v > 0)#
# UQ normalization function#
UQNorm <- function(v) {#
    nonzero_data <- subset(v, v > 0)#
    quartiles <- quantile(nonzero_data)#
    uq <- quartiles[4]#
    return(uq)#
} #
# vector of Us needed to normalize data#
Us <- apply(raw_data, 2, UQNorm)#
# finding mean of the of the uq samples#
U <- mean(Us)#
# load processed data#
load("R_Data/saved_processed_data")#
#
uqnorm <- matrix(, nrow=nrow(processed_data), ncol=ncol(processed_data))#
#
# doing a for loop to normalize on each sample#
for (i in 1:ncol(processed_data)) {#
	colneeded <- processed_data[,i]#
	uqnorm[,i] <- colneeded/Us[i]*U#
}#
#
PCA <- dget("Preliminary_Steps/PCA.r")#
PCA(uqnorm, 4)
# Retrieve Data#
# processed_data retreived#
load("R_Data/saved_raw_data")#
# get rid of all non-zero counts to create a vector#
nonzero_data <- subset(v, v > 0)#
# UQ normalization function#
UQNorm <- function(v) {#
    nonzero_data <- subset(v, v > 0)#
    quartiles <- quantile(nonzero_data)#
    uq <- quartiles[4]#
    return(uq)#
} #
# vector of Us needed to normalize data#
Us <- apply(raw_data, 2, UQNorm)#
# finding mean of the of the uq samples#
U <- mean(Us)#
# load processed data#
load("R_Data/saved_processed_data")#
#
uqnorm <- matrix(, nrow=nrow(processed_data), ncol=ncol(processed_data))#
#
# doing a for loop to normalize on each sample#
for (i in 1:ncol(processed_data)) {#
	colneeded <- processed_data[,i]#
	uqnorm[,i] <- colneeded/Us[i]*U#
}#
#
logged <- log2(uqnorm + 1)#
PCA <- dget("Preliminary_Steps/PCA.r")#
PCA(logged, 4)
# Retrieve Data#
# processed_data retreived#
load("R_Data/saved_raw_data")#
# get rid of all non-zero counts to create a vector#
nonzero_data <- subset(v, v > 0)#
# UQ normalization function#
UQNorm <- function(v) {#
    nonzero_data <- subset(v, v > 0)#
    quartiles <- quantile(nonzero_data)#
    uq <- quartiles[4]#
    return(uq)#
} #
# vector of Us needed to normalize data#
Us <- apply(raw_data, 2, UQNorm)#
# finding mean of the of the uq samples#
U <- mean(Us)#
# load processed data#
load("R_Data/saved_processed_data")#
#
uqnorm <- matrix(, nrow=nrow(processed_data), ncol=ncol(processed_data))#
#
# doing a for loop to normalize on each sample#
for (i in 1:ncol(processed_data)) {#
	colneeded <- processed_data[,i]#
	uqnorm[,i] <- colneeded/Us[i]*U#
}#
#
logged <- log2(uqnorm + 1)#
PCA <- dget("Preliminary_Steps/PCA.r")#
PCA(logged, 6)
install.packages("FactoMineR")
# Retrieve Data#
# processed_data retreived#
load("R_Data/saved_raw_data")#
# get rid of all non-zero counts to create a vector#
nonzero_data <- subset(v, v > 0)#
# UQ normalization function#
UQNorm <- function(v) {#
    nonzero_data <- subset(v, v > 0)#
    quartiles <- quantile(nonzero_data)#
    uq <- quartiles[4]#
    return(uq)#
} #
# vector of Us needed to normalize data#
Us <- apply(raw_data, 2, UQNorm)#
# finding mean of the of the uq samples#
U <- mean(Us)#
# load processed data#
load("R_Data/saved_processed_data")#
#
uqnorm <- matrix(, nrow=nrow(processed_data), ncol=ncol(processed_data))#
#
# doing a for loop to normalize on each sample#
for (i in 1:ncol(processed_data)) {#
	colneeded <- processed_data[,i]#
	uqnorm[,i] <- colneeded/Us[i]*U#
}#
#
logged <- log2(uqnorm + 1)#
pca_analysis <- dget("Preliminary_Steps/PCA.r")#
pca_analysis(logged, 6)
class(pca_analysis)
pca_analysis <- dget("Preliminary_Steps/PCA.r")#
pca_analysis(logged, 6)
n
pca_analysis <- dget("Preliminary_Steps/PCA.r")#
pca_analysis(logged, 6)
print(n)
pca_analysis(logged,5)
pca_analysis <- dget("Preliminary_Steps/PCA.r")
pca_analysis(logged,5)
pca_analysis <- dget("Preliminary_Steps/PCA.r")
pca_analysis(logged,5)
pca_analysis <- dget("Preliminary_Steps/PCA.r")#
> pca_analysis(logged,5)
pca_analysis <- dget("Preliminary_Steps/PCA.r")#
pca_analysis(logged, 6)
pca_analysis
pca_analysis <- dget("Preliminary_Steps/PCA.r")
pca_analysis
pca_analysis(logged, 6)
pca_analysis
head(logged)
pca_df = PCA(logged)
pca_df = PCA(t(logged))
pca_analysis <- dget("Preliminary_Steps/PCA.r")#
pca_analysis(logged, 6)
class(PCA)
PCA
rm(PCA)
pca_analysis <- dget("Preliminary_Steps/PCA.r")#
pca_analysis(logged, 6)
function(data, num) {#
# Load package#
library(FactoMineR)#
#
# PCA analysis#
pca_df = PCA(t(data))#
#
# Get first n PCs, store in lists#
pca_result <- pca_df$ind$coord#
#
pcs_all = vector(mode="list", length=num)#
pcs_viral = vector(mode="list", length=num)#
pcs_baseline = vector(mode="list", length=num)#
pcs_bacteria = vector(mode="list", length=num)#
for (i in 1:num) {#
	pcs_all[[i]] = pca_result[,i]#
	pcs_viral[[i]] = pca_result[1:21,i]#
	pcs_baseline[[i]] = pca_result[22:42,i]#
	pcs_bacteria[[i]] = pca_result[43:52,i]#
}#
#
# Plot all combinations of PCs, store in files#
# red=viral, green=baseline, blue=bacteria#
from_i <- 1#
to_i <- num - 1#
to_j <- num#
for (i in from_i:to_i) {#
	from_j <- i + 1#
	for (j in from_j:to_j) {#
		plot_name <- paste(i,"vs",j)#
		dir_name <- paste("Plots/PCA", plot_name, ".jpeg", collapse="")#
		jpeg(dir_name)#
		plot(pcs_viral[[i]], pcs_viral[[j]], col="red",#
				xlim=c(min(pcs_all[[i]]), max(pcs_all[[i]])),#
				ylim=c(min(pcs_all[[j]]), max(pcs_all[[j]])))#
		points(pcs_baseline[[i]], pcs_baseline[[j]], col="green")#
		points(pcs_bacteria[[i]], pcs_bacteria[[j]], col="blue")#
		dev.off()#
	}#
}#
#
}
pca_analysis <- dget("Preliminary_Steps/PCA.r")#
pca_analysis(logged, 6)
pca_analysis <- dget("Preliminary_Steps/analyze_PCs.r")#
pca_analysis(logged, 6)
pca_analysis <- dget("Preliminary_Steps/analyze_PCs.r")#
pca_analysis(logged, 10)
pca_analysis <- dget("Preliminary_Steps/analyze_PCs.r")#
pca_analysis(uqnorm, 10)
# Retrieve Data#
# processed_data retreived#
load("R_Data/saved_raw_data")#
# get rid of all non-zero counts to create a vector#
nonzero_data <- subset(v, v > 0)#
# UQ normalization function#
UQNorm <- function(v) {#
    nonzero_data <- subset(v, v > 0)#
    quartiles <- quantile(nonzero_data)#
    uq <- quartiles[4]#
    return(uq)#
} #
# vector of Us needed to normalize data#
Us <- apply(raw_data, 2, UQNorm)#
# finding mean of the of the uq samples#
U <- mean(Us)#
# load processed data#
load("R_Data/saved_processed_data")#
#
uqnorm <- matrix(, nrow=nrow(processed_data), ncol=ncol(processed_data))#
#
# doing a for loop to normalize on each sample#
for (i in 1:ncol(processed_data)) {#
	colneeded <- processed_data[,i]#
	uqnorm[,i] <- colneeded/Us[i]*U#
}#
#
logged <- log2(uqnorm + 1)#
pca_analysis <- dget("Preliminary_Steps/analyze_PCs.r")#
pca_analysis(logged, 25)
# Retrieve Data#
# logged_data retrieved#
load("R_data/saved_logged_data")#
#
# Read content table w/ sequence data#
seq_df <- read.delim("Preliminary_Steps/sequence_content/content_table.txt")#
head(seq_df)#
#
# Create list for gc proportion#
gc_prop_list <- split(seq_df$miRNA, seq_df$gc_prop)#
head(gc_prop_list)
gc_prop_list <- seq_df$gc_prop#
names(gc_prop_list) <- seq_df$miRNA#
head(gc_prop_list)
# Retrieve Data#
# processed_data retreived#
load("R_Data/saved_raw_data")#
#
# UQ normalization function#
UQNorm <- function(v) {#
    nonzero_data <- subset(v, v > 0)#
    quartiles <- quantile(nonzero_data)#
    uq <- quartiles[4]#
    return(uq)#
} #
#
# vector of Us needed to normalize data#
Us <- apply(raw_data, 2, UQNorm)#
#
# finding mean of the of the uq samples#
U <- mean(Us)#
#
# load processed data#
load("R_Data/saved_processed_data")#
#
uqnorm <- matrix(, nrow=nrow(processed_data), ncol=ncol(processed_data))#
#
# doing a for loop to normalize on each sample#
for (i in 1:ncol(processed_data)) {#
	colneeded <- processed_data[,i]#
	uqnorm[,i] <- colneeded/Us[i]*U#
}#
#
# log norm data, save it#
logged_data <- log2(uqnorm + 1)#
save(logged_data, file="R_data/saved_logged_data")#
# create quantile normalization function#
quantile_normalization <- function(uqnorm) {#
	uqnorm_rank <- apply(uqnorm, 2, rank, ties.method="min")#
	uqnorm_sorted <- apply(uqnorm_rank, 2, sort)#
	#create the sampling vector to add into the quantiles function#
	sampling_vector <- 1:52#
	makingquantiles <- sampling_vector / 53#
	# setting quantiles argument#
	quantiles <- qnorm(makingquantiles)#
#
	return(quantiles[uqnorm_rank])#
}#
# test the function#
quantile_norm_data <- quantile_normalization(uqnorm)#
head(quantile_norm_data)
# test the function#
quantile_norm_data <- quantile_normalization(uqnorm)#
head(quantile_norm_data)
# create quantile normalization function#
quantile_normalization <- function(uqnorm) {#
	uqnorm_rank <- apply(uqnorm, 2, rank, ties.method="min")#
	uqnorm_sorted <- apply(uqnorm_rank, 2, sort)#
	#create the sampling vector to add into the quantiles function#
	sampling_vector <- 1:52#
	makingquantiles <- sampling_vector / 53#
	# setting quantiles argument#
	quantiles <- qnorm(makingquantiles, mean=0, sd=1)#
	print(quantiles)#
	return(quantiles[uqnorm_rank])#
}#
# test the function#
quantile_norm_data <- quantile_normalization(uqnorm)#
head(quantile_norm_data)
# create quantile normalization function#
quantile_normalization <- function(uqnorm) {#
	uqnorm_rank <- apply(uqnorm, 2, rank, ties.method="min")#
	uqnorm_sorted <- apply(uqnorm_rank, 2, sort)#
	#create the sampling vector to add into the quantiles function#
	sampling_vector <- 1:52#
	makingquantiles <- sampling_vector / 53#
	# setting quantiles argument#
	quantiles <- qnorm(makingquantiles, mean=0, sd=1)#
	print(head(quantiles[uqnorm_rank])#
	return(quantiles[uqnorm_rank])#
}#
# test the function#
quantile_norm_data <- quantile_normalization(uqnorm)#
head(quantile_norm_data)
# create quantile normalization function#
quantile_normalization <- function(uqnorm) {#
	uqnorm_rank <- apply(uqnorm, 2, rank, ties.method="min")#
	uqnorm_sorted <- apply(uqnorm_rank, 2, sort)#
	#create the sampling vector to add into the quantiles function#
	sampling_vector <- 1:52#
	makingquantiles <- sampling_vector / 53#
	# setting quantiles argument#
	quantiles <- qnorm(makingquantiles, mean=0, sd=1)#
	ordered_quantiles <- quantiles[uqnorm_rank]#
	return(ordered_quantiles)#
}#
# test the function#
quantile_norm_data <- quantile_normalization(uqnorm)#
head(quantile_norm_data)
# test the function#
quantile_norm_data <- quantile_normalization(uqnorm)#
head(quantile_norm_data)
# test the function#
quantile_norm_data <- quantile_normalization(uqnorm)#
str(quantile_norm_data)
# test the function#
quantile_norm_data <- quantile_normalization(uqnorm)#
class(quantile_norm_data)
rm(quantile_norm_data)
# test the function#
quantile_norm_data <- quantile_normalization(uqnorm)#
class(quantile_norm_data)
head(quantile_norm_data)
str(quantile_norm_data)
# create quantile normalization function#
quantile_normalization <- function(uqnorm) {#
	uqnorm_rank <- apply(uqnorm, 2, rank, ties.method="min")#
	uqnorm_sorted <- apply(uqnorm_rank, 2, sort)#
	#create the sampling vector to add into the quantiles function#
	sampling_vector <- 1:52#
	makingquantiles <- sampling_vector / 53#
	# setting quantiles argument#
	quantiles <- qnorm(makingquantiles, mean=0, sd=1)#
	out <- quantiles[uqnorm_rank]#
	str(out)#
	return(out)#
}#
# test the function#
quantile_norm_data <- quantile_normalization(uqnorm)#
str(quantile_norm_data)
# create quantile normalization function#
quantile_normalization <- function(uqnorm) {#
	uqnorm_rank <- apply(uqnorm, 2, rank, ties.method="min")#
	uqnorm_sorted <- apply(uqnorm_rank, 2, sort)#
	#create the sampling vector to add into the quantiles function#
	sampling_vector <- 1:52#
	makingquantiles <- sampling_vector / 53#
	# setting quantiles argument#
	quantiles <- qnorm(makingquantiles, mean=0, sd=1)#
	out <- quantiles[uqnorm_rank]#
	head(out)#
	return(out)#
}#
# test the function#
quantile_norm_data <- quantile_normalization(uqnorm)#
str(quantile_norm_data)
# create quantile normalization function#
quantile_normalization <- function(uqnorm) {#
	uqnorm_rank <- apply(uqnorm, 2, rank, ties.method="min")#
	uqnorm_sorted <- apply(uqnorm_rank, 2, sort)#
	#create the sampling vector to add into the quantiles function#
	sampling_vector <- 1:52#
	makingquantiles <- sampling_vector / 53#
	# setting quantiles argument#
	quantiles <- qnorm(makingquantiles, mean=0, sd=1)#
	out <- quantiles[uqnorm_rank]#
	print(str(out))#
	return(out)#
}#
# test the function#
quantile_norm_data <- quantile_normalization(uqnorm)#
str(quantile_norm_data)
x <- c(1,2,3,4)
x <- c(2,4,6,8)
y <- x[3,2,1,4]
y <- x[c(3,2,1,4)]
y
# create quantile normalization function#
quantile_normalization <- function(uqnorm) {#
	uqnorm_rank <- apply(uqnorm, 2, rank, ties.method="min")#
	uqnorm_sorted <- apply(uqnorm_rank, 2, sort)#
	#create the sampling vector to add into the quantiles function#
	sampling_vector <- 1:52#
	makingquantiles <- sampling_vector / 53#
	# setting quantiles argument#
	quantiles <- qnorm(makingquantiles, mean=0, sd=1)#
	out <- quantiles[uqnorm_rank]#
	print(length(quantiles))#
	print(length(uqnorm_rank))#
	return(out)#
}#
# test the function#
quantile_norm_data <- quantile_normalization(uqnorm)#
str(quantile_norm_data)
# create quantile normalization function#
quantile_normalization <- function(uqnorm) {#
	uqnorm_rank <- apply(uqnorm, 2, rank, ties.method="min")#
	head(uqnorm_rank)#
	uqnorm_sorted <- apply(uqnorm_rank, 2, sort)#
	#create the sampling vector to add into the quantiles function#
	sampling_vector <- 1:52#
	makingquantiles <- sampling_vector / 53#
	# setting quantiles argument#
	quantiles <- qnorm(makingquantiles, mean=0, sd=1)#
	out <- quantiles[uqnorm_rank]#
	print(length(quantiles))#
	print(length(uqnorm_rank))#
	return(out)#
}#
# test the function#
quantile_norm_data <- quantile_normalization(uqnorm)#
str(quantile_norm_data)
# create quantile normalization function#
quantile_normalization <- function(uqnorm) {#
	uqnorm_rank <- apply(uqnorm, 2, rank, ties.method="min")#
	print(head(uqnorm_rank))#
	uqnorm_sorted <- apply(uqnorm_rank, 2, sort)#
	#create the sampling vector to add into the quantiles function#
	sampling_vector <- 1:52#
	makingquantiles <- sampling_vector / 53#
	# setting quantiles argument#
	quantiles <- qnorm(makingquantiles, mean=0, sd=1)#
	out <- quantiles[uqnorm_rank]#
	print(length(quantiles))#
	print(length(uqnorm_rank))#
	return(out)#
}#
# test the function#
quantile_norm_data <- quantile_normalization(uqnorm)#
str(quantile_norm_data)
# create quantile normalization function#
quantile_normalization <- function(uqnorm) {#
	uqnorm_rank <- apply(uqnorm, 2, rank, ties.method="min")#
	print(str(uqnorm_rank))#
	uqnorm_sorted <- apply(uqnorm_rank, 2, sort)#
	#create the sampling vector to add into the quantiles function#
	sampling_vector <- 1:52#
	makingquantiles <- sampling_vector / 53#
	# setting quantiles argument#
	quantiles <- qnorm(makingquantiles, mean=0, sd=1)#
	out <- quantiles[uqnorm_rank]#
	print(length(quantiles))#
	print(length(uqnorm_rank))#
	return(out)#
}#
# test the function#
quantile_norm_data <- quantile_normalization(uqnorm)#
str(quantile_norm_data)
# create quantile normalization function#
quantile_normalization <- function(uqnorm) {#
	uqnorm_rank <- apply(uqnorm, 2, rank, ties.method="min")#
	print(str(uqnorm_rank))#
	uqnorm_sorted <- apply(uqnorm_rank, 2, sort)#
	#create the sampling vector to add into the quantiles function#
	sampling_vector <- 1:52#
	makingquantiles <- sampling_vector / 53#
	# setting quantiles argument#
	quantiles <- qnorm(makingquantiles, mean=0, sd=1)#
	out <- quantiles[uqnorm_rank]#
	print(str(quantiles))#
	print(str(uqnorm_rank))#
	return(out)#
}#
# test the function#
quantile_norm_data <- quantile_normalization(uqnorm)#
str(quantile_norm_data)
# create quantile normalization function#
quantile_normalization <- function(uqnorm) {#
	uqnorm_rank <- apply(uqnorm, 2, rank, ties.method="min")#
	uqnorm_sorted <- apply(uqnorm_rank, 2, sort)#
	print(uqnorm_sorted)#
	#create the sampling vector to add into the quantiles function#
	sampling_vector <- 1:52#
	makingquantiles <- sampling_vector / 53#
	# setting quantiles argument#
	quantiles <- qnorm(makingquantiles, mean=0, sd=1)#
	out <- quantiles[uqnorm_rank]#
	print(str(quantiles))#
	print(str(uqnorm_rank))#
	return(out)#
}#
# test the function#
quantile_norm_data <- quantile_normalization(uqnorm)#
str(quantile_norm_data)
# Retrieve Data#
# processed_data retreived#
load("R_Data/saved_raw_data")#
#
# UQ normalization function#
UQNorm <- function(v) {#
    nonzero_data <- subset(v, v > 0)#
    quartiles <- quantile(nonzero_data)#
    uq <- quartiles[4]#
    return(uq)#
} #
#
# vector of Us needed to normalize data#
Us <- apply(raw_data, 2, UQNorm)#
#
# finding mean of the of the uq samples#
U <- mean(Us)#
#
# load processed data#
load("R_Data/saved_processed_data")#
#
uqnorm <- matrix(, nrow=nrow(processed_data), ncol=ncol(processed_data))#
#
# doing a for loop to normalize on each sample#
for (i in 1:ncol(processed_data)) {#
	colneeded <- processed_data[,i]#
	uqnorm[,i] <- colneeded/Us[i]*U#
}#
#
# log norm data, save it#
logged_data <- log2(uqnorm + 1)#
save(logged_data, file="R_data/saved_logged_data")#
# create quantile normalization function#
quantile_normalization <- function(uqnorm) {#
	### I think we should be sorting by sample#
	uqnorm_rank <- apply(uqnorm, 2, rank, ties.method="min")#
#
	#create the sampling vector to add into the quantiles function#
	sampling_vector <- 1:52#
	### Not sure about the divide by number, ask Ashlee to clarify#
	makingquantiles <- sampling_vector / 51#
	# setting quantiles argument#
	quantiles <- qnorm(makingquantiles, mean=0, sd=1)#
	### Initialize quant_norm matrix#
	quant_norm <- matrix(, nrow(uqnorm), ncol(uqnorm))#
	# create for loop to sort every quantile based on rank#
	### So the for loop should go through each sample (column)#
	### Return sorted quantiles vector for each loop based on rank vectors in uqnorm_rank#
	for (i in ncol(uqnorm)) {#
		quant_norm[,i] <- quantiles[uqnorm_rank[,i]]#
	}#
	### return quantile normalized matrix#
	return(quant_norm)#
}#
# test the function#
quantile_norm_data <- quantile_normalization(uqnorm)#
str(quantile_norm_data)
# insert data set#
known_data <-read.delim("miRDeep2_Data/known_miRNAs_expressed_all_samples.txt", header=TRUE)#
#
# extract raw data into matrix (just #s), exclude "norm" data#
raw_data <- known_data[,5:56]#
raw_data <- data.matrix(raw_data)#
#
# save row names into matrix#
miRNA_names <- known_data[,1]#
rownames(raw_data) <- miRNA_names#
#
# save raw data#
save(raw_data, file="R_Data/saved_raw_data")#
#
# function to count zeros, return proportions#
count_zeros <- function(v) {#
	len <- length(v)#
	zero_bool <- v==0#
	zero_count <- length(which(zero_bool == "TRUE"))#
	nonzero_count <- len - zero_count#
	props <- c(0, 0)#
	props[1] <- zero_count / len#
	props[2] <- nonzero_count / len#
	return(props)#
}#
#
# find zero proportions for each sample#
zero_counts_sample <- apply(raw_data, 2, count_zeros)#
#
# find zero proportions for each miRNA#
zero_counts_miRNA <- apply(raw_data, 1, count_zeros)#
#
# save zero proportions (zero_count / len)#
zero_props_miRNA <- zero_counts_miRNA[1,]#
save(zero_props_miRNA, file="R_Data/saved_zero_props_miRNA")#
#
# delete miRNAs that have >50% zeros#
over_50 <- zero_props_miRNA > 0.5#
processed_data <- raw_data[!over_50,]#
#
# save processed data#
# save as R file#
save(processed_data, file="R_Data/saved_processed_data")#
# save as txt file#
write.table(processed_data, "misc_data/saved_processed_data_text.txt", sep="\t",#
		quote=FALSE)
x <- c(1,1,2,4)
y <- rank(x)
y
# insert data set#
known_data <-read.delim("miRDeep2_Data/known_miRNAs_expressed_all_samples.txt", header=TRUE)
str(known_data)
# insert data set#
known_data <-read.delim("miRDeep2_Data/known_miRNAs_expressed_all_samples.txt", header=TRUE)#
#
# extract raw data into matrix (just #s), exclude "norm" data#
raw_data <- known_data[,5:56]#
raw_data <- data.matrix(raw_data)#
#
# save row names into matrix#
miRNA_names <- known_data[,1]#
rownames(raw_data) <- miRNA_names#
#
# save raw data#
save(raw_data, file="R_Data/saved_raw_data")#
#
# function to count zeros, return proportions#
count_zeros <- function(v) {#
	len <- length(v)#
	zero_bool <- v==0#
	zero_count <- length(which(zero_bool == "TRUE"))#
	nonzero_count <- len - zero_count#
	props <- c(0, 0)#
	props[1] <- zero_count / len#
	props[2] <- nonzero_count / len#
	return(props)#
}#
#
# find zero proportions for each sample#
zero_counts_sample <- apply(raw_data, 2, count_zeros)#
#
# find zero proportions for each miRNA#
zero_counts_miRNA <- apply(raw_data, 1, count_zeros)#
#
# save zero proportions (zero_count / len)#
zero_props_miRNA <- zero_counts_miRNA[1,]#
save(zero_props_miRNA, file="R_Data/saved_zero_props_miRNA")#
#
# delete miRNAs that have >50% zeros#
over_50 <- zero_props_miRNA > 0.5#
processed_data <- raw_data[!over_50,]#
#
# save processed data#
# save as R file#
save(processed_data, file="R_Data/saved_processed_data")#
# save as txt file#
write.table(processed_data, "misc_data/saved_processed_data_text.txt", sep="\t",#
		quote=FALSE)#
#
# get precursor names#
precursor_names <- known_data$precursor#
# get corresponding precursor names for processed_data#
prec_names_proc <- precursor_names[!over_50]#
# save precursor names for processed_data#
save(prec_names_proc, file="R_Data/saved_prec_names_proc")
# Retrieve Data#
# processed_data retreived#
load("R_Data/saved_processed_data")#
#
# get miRNA names in order#
miRNA_names <- rownames(processed_data)#
#
# save miRNA names to .txt file#
write.table(miRNA_names, "misc_data/saved_miRNA_names.txt", sep="\t",#
		quote=FALSE, row.names=FALSE, col.names=FALSE)#
# get precursor names in processed data#
load("R_data/saved_prec_names_proc")#
#
# save precursor names in processed data in .txt file#
write.table(miRNA_names, "misc_data/saved_precursor_names.txt", sep="\t",#
		quote=FALSE, row.names=FALSE, col.names=FALSE)
# Retrieve Data#
# processed_data retreived#
load("R_Data/saved_processed_data")#
#
# get miRNA names in order#
miRNA_names <- rownames(processed_data)#
#
# save miRNA names to .txt file#
write.table(miRNA_names, "misc_data/saved_miRNA_names.txt", sep="\t",#
		quote=FALSE, row.names=FALSE, col.names=FALSE)#
# get precursor names in processed data#
# prec_names_proc retrieved#
load("R_data/saved_prec_names_proc")#
#
# save precursor names in processed data in .txt file#
write.table(prec_names_proc, "misc_data/saved_precursor_names.txt", sep="\t",#
		quote=FALSE, row.names=FALSE, col.names=FALSE)
known_data$precursor
# Retrieve Data#
# processed_data retreived#
load("R_Data/saved_raw_data")#
#
# UQ normalization function#
UQNorm <- function(v) {#
    nonzero_data <- subset(v, v > 0)#
    quartiles <- quantile(nonzero_data)#
    uq <- quartiles[4]#
    return(uq)#
} #
#
# vector of Us needed to normalize data#
Us <- apply(raw_data, 2, UQNorm)#
#
# finding mean of the of the uq samples#
U <- mean(Us)#
#
# load processed data#
load("R_Data/saved_processed_data")#
#
uqnorm <- matrix(, nrow=nrow(processed_data), ncol=ncol(processed_data))#
#
# doing a for loop to normalize on each sample#
for (i in 1:ncol(processed_data)) {#
	colneeded <- processed_data[,i]#
	uqnorm[,i] <- colneeded/Us[i]*U#
}#
#
#create a function to normalize data#
#order the data set according to rank#
quantile_normalize <- function(v) {#
	v_order <- rank(v,ties.method="average")#
	#set the quantiles based on the order#
	quantiles <- v_order/53#
	quantile_norm_vec <- qnorm(quantiles,mean=0,sd=1)#
	return(quantile_norm_vec)	#
}#
#
output_matrix <- matrix(, nrow=m, ncol=n)#
# create quantile normalization function for each miRNA#
quantile_norm_data <- apply(uqnorm, 1, quantile_normalize)#
head(quantile_norm_data)#
#
# save final normalized data#
save(quantile_norm_data, file="R_Data/saved_quantile_norm_data")
# Retrieve Data#
# processed_data retreived#
load("R_Data/saved_raw_data")#
#
# UQ normalization function#
UQNorm <- function(v) {#
    nonzero_data <- subset(v, v > 0)#
    quartiles <- quantile(nonzero_data)#
    uq <- quartiles[4]#
    return(uq)#
} #
#
# vector of Us needed to normalize data#
Us <- apply(raw_data, 2, UQNorm)#
#
# finding mean of the of the uq samples#
U <- mean(Us)#
#
# load processed data#
load("R_Data/saved_processed_data")#
#
uqnorm <- matrix(, nrow=nrow(processed_data), ncol=ncol(processed_data))#
#
# doing a for loop to normalize on each sample#
for (i in 1:ncol(processed_data)) {#
	colneeded <- processed_data[,i]#
	uqnorm[,i] <- colneeded/Us[i]*U#
}#
#
#create a function to normalize data#
#order the data set according to rank#
quantile_normalize <- function(v) {#
	v_order <- rank(v,ties.method="average")#
	#set the quantiles based on the order#
	quantiles <- v_order/53#
	quantile_norm_vec <- qnorm(quantiles,mean=0,sd=1)#
	return(quantile_norm_vec)	#
}#
#
output_matrix <- matrix(, nrow=m, ncol=n)#
# create quantile normalization function for each miRNA#
quantile_norm_data <- apply(uqnorm, 1, quantile_normalize)#
quantile_norm_data <- t(quantile_norm_data)#
str(quantile_norm_data)#
#
# save final normalized data#
save(quantile_norm_data, file="R_Data/saved_quantile_norm_data")
# Retrieve Data#
# quantile_norm_data retrieved#
load("R_data/saved_quantile_norm_data")#
#
# Do PCA Analysis#
pca_analysis <- dget("Preliminary_Steps/PCA/analyze_PCs_miRNA.r")#
pca_analysis(quantile_norm_data, 10)
# Retrieve Data#
# quantile_norm_data retrieved#
load("R_data/saved_quantile_norm_data")#
#
# Do PCA Analysis#
pca_analysis <- dget("Preliminary_Steps/PCA/analyze_PCs_samples.r")#
pca_analysis(quantile_norm_data, 10)
ggplot2
ggplot
library(ggplot1)
library(ggplot2)
x <- -4
abs(x)
x <- c(1,2,3,4)
y <- c(4,2,2,1)
ggplot(data.frame(xval=x,yval=y), aes(x='1',y='2'))
ggplot(data.frame(xval=x,yval=y), aes(x='1',y='2')) + geom_point()
ggplot(data.frame(xval=x,yval=y)) + geom_point(aes(x='1',y='2'))
# Generate some data#
set.seed(133)#
df <- data.frame(xval=rnorm(50), yval=rnorm(50))#
#
# Make color depend on yval#
ggplot(df, aes(x=xval, y=yval, colour=yval)) + geom_point()
# Generate some data#
set.seed(133)#
df <- data.frame(xval=rnorm(50), yval=rnorm(50))#
#
# Make color depend on yval#
ggplot(df, aes(x='1', y='2', colour=yval)) + geom_point()
# Generate some data#
set.seed(133)#
df <- data.frame(xval=rnorm(50), yval=rnorm(50))#
#
# Make color depend on yval#
ggplot(df, aes(x=xal, y=yl, colour=yval)) + geom_point()
# Read quantile normalized data#
# quantile_norm_data retrieved#
load("R_data/saved_quantile_norm_data")#
#
# Read content table w/ sequence data for miRNA & precursor#
miRNA_seq_df <- read.delim("Preliminary_Steps/sequence_content/content_table_miRNA.txt")#
prec_seq_df <- read.delim("Preliminary_Steps/sequence_content/content_table_precursor.txt")#
#
# Create lists for gc proportion and lengths for miRNA & precursor#
miRNA_gc_prop <- miRNA_seq_df$gc_prop#
prec_gc_prop <- prec_seq_df$gc_prop#
miRNA_length <- miRNA_seq_df$length#
prec_length <- prec_seq_df$length#
#
# Do PCA Analysis for all variables#
pca_analysis <- dget("Preliminary_Steps/PCA/analyze_PCs_miRNA_precursor.r")#
pca_analysis(quantile_norm_data, miRNA_length, miRNa_gc_prop,#
		prec_length, prec_gc_prop, 10)
# Read quantile normalized data#
# quantile_norm_data retrieved#
load("R_data/saved_quantile_norm_data")#
#
# Read content table w/ sequence data for miRNA & precursor#
miRNA_seq_df <- read.delim("Preliminary_Steps/sequence_content/content_table_miRNA.txt")#
prec_seq_df <- read.delim("Preliminary_Steps/sequence_content/content_table_precursor.txt")#
#
# Create lists for gc proportion and lengths for miRNA & precursor#
miRNA_gc_prop <- miRNA_seq_df$gc_prop#
prec_gc_prop <- prec_seq_df$gc_prop#
miRNA_length <- miRNA_seq_df$length#
prec_length <- prec_seq_df$length#
#
# Do PCA Analysis for all variables#
pca_analysis <- dget("Preliminary_Steps/PCA/analyze_PCs_miRNA_precursor.r")#
pca_analysis(quantile_norm_data, miRNA_length, miRNA_gc_prop,#
		prec_length, prec_gc_prop, 10)
# Read quantile normalized data#
# quantile_norm_data retrieved#
load("R_data/saved_quantile_norm_data")#
#
# Read content table w/ sequence data for miRNA & precursor#
miRNA_seq_df <- read.delim("Preliminary_Steps/sequence_content/content_table_miRNA.txt")#
prec_seq_df <- read.delim("Preliminary_Steps/sequence_content/content_table_precursor.txt")#
#
# Create lists for gc proportion and lengths for miRNA & precursor#
miRNA_gc_prop <- miRNA_seq_df$gc_prop#
prec_gc_prop <- prec_seq_df$gc_prop#
miRNA_length <- miRNA_seq_df$length#
prec_length <- prec_seq_df$length#
#
# Do PCA Analysis for all variables#
pca_analysis <- dget("Preliminary_Steps/PCA/analyze_PCs_miRNA_precursor.r")#
pca_analysis(quantile_norm_data, miRNA_length, miRNA_gc_prop,#
		prec_length, prec_gc_prop, 2)
# Read quantile normalized data#
# quantile_norm_data retrieved#
load("R_data/saved_quantile_norm_data")#
#
# Read content table w/ sequence data for miRNA & precursor#
miRNA_seq_df <- read.delim("Preliminary_Steps/sequence_content/content_table_miRNA.txt")#
prec_seq_df <- read.delim("Preliminary_Steps/sequence_content/content_table_precursor.txt")#
#
# Create lists for gc proportion and lengths for miRNA & precursor#
miRNA_gc_prop <- miRNA_seq_df$gc_prop#
prec_gc_prop <- prec_seq_df$gc_prop#
miRNA_length <- miRNA_seq_df$length#
prec_length <- prec_seq_df$length#
#
# Do PCA Analysis for all variables#
pca_analysis <- dget("Preliminary_Steps/PCA/analyze_PCs_miRNA_precursor.r")#
pca_analysis(quantile_norm_data, miRNA_length, miRNA_gc_prop,#
		prec_length, prec_gc_prop, 3)
plot_df <- data.frame(xval=pcs_all[[1]], yval=pcs_all[[2]])#
	ggplot(plot_df, aes(x=pcs_all[[1]],y=pcs_all[[2]], colour=z_data)) +#
				geom_point() +#
				scale_colour_gradientn(colours=rainbow(max(abs(z_data))))
# Load package#
	library(FactoMineR)#
	# PCA analysis, miRNAs are data points, samples are features#
	pca_df = PCA(data, ncp=num, graph=FALSE)#
	# Find proportion of variance, etc.#
	prop_of_var <- pca_df$eig[1:num,]#
	write.table(prop_of_var, "Preliminary_Steps/PCA/analysis/prop_of_vars_miRNA.txt", sep="\t", quote=FALSE)#
	# Get first n PCs, store in lists#
	pca_result <- pca_df$ind$coord#
	pcs_all = vector(mode="list", length=num)#
	for(i in 1:num) {#
		pcs_all[[i]] = pca_result[,i]#
	}#
	plot_df <- data.frame(xval=pcs_all[[1]], yval=pcs_all[[2]])#
	ggplot(plot_df, aes(x=pcs_all[[1]],y=pcs_all[[2]], colour=z_data)) +#
				geom_point() +#
				scale_colour_gradientn(colours=rainbow(max(abs(z_data))))
# Load package#
	library(FactoMineR)#
	# PCA analysis, miRNAs are data points, samples are features#
	pca_df = PCA(data, ncp=3, graph=FALSE)#
	# Find proportion of variance, etc.#
	prop_of_var <- pca_df$eig[1:num,]#
	write.table(prop_of_var, "Preliminary_Steps/PCA/analysis/prop_of_vars_miRNA.txt", sep="\t", quote=FALSE)#
	# Get first n PCs, store in lists#
	pca_result <- pca_df$ind$coord#
	pcs_all = vector(mode="list", length=num)#
	for(i in 1:3) {#
		pcs_all[[i]] = pca_result[,i]#
	}#
	plot_df <- data.frame(xval=pcs_all[[1]], yval=pcs_all[[2]])#
	ggplot(plot_df, aes(x=pcs_all[[1]],y=pcs_all[[2]], colour=z_data)) +#
				geom_point() +#
				scale_colour_gradientn(colours=rainbow(max(abs(z_data))))
# Read quantile normalized data#
# quantile_norm_data retrieved#
load("R_data/saved_quantile_norm_data")#
#
# Read content table w/ sequence data for miRNA & precursor#
miRNA_seq_df <- read.delim("Preliminary_Steps/sequence_content/content_table_miRNA.txt")#
prec_seq_df <- read.delim("Preliminary_Steps/sequence_content/content_table_precursor.txt")#
#
# Create lists for gc proportion and lengths for miRNA & precursor#
miRNA_gc_prop <- miRNA_seq_df$gc_prop#
prec_gc_prop <- prec_seq_df$gc_prop#
miRNA_length <- miRNA_seq_df$length#
prec_length <- prec_seq_df$length#
#
# Do PCA Analysis for all variables#
pca_analysis <- dget("Preliminary_Steps/PCA/analyze_PCs_miRNA_precursor.r")#
pca_analysis(quantile_norm_data, miRNA_length, miRNA_gc_prop,#
		prec_length, prec_gc_prop, 3)
warnings()
# Read quantile normalized data#
# quantile_norm_data retrieved#
load("R_data/saved_quantile_norm_data")#
#
# Read content table w/ sequence data for miRNA & precursor#
miRNA_seq_df <- read.delim("Preliminary_Steps/sequence_content/content_table_miRNA.txt")#
prec_seq_df <- read.delim("Preliminary_Steps/sequence_content/content_table_precursor.txt")#
#
# Create lists for gc proportion and lengths for miRNA & precursor#
miRNA_gc_prop <- miRNA_seq_df$gc_prop#
prec_gc_prop <- prec_seq_df$gc_prop#
miRNA_length <- miRNA_seq_df$length#
prec_length <- prec_seq_df$length#
#
# Do PCA Analysis for all variables#
pca_analysis <- dget("Preliminary_Steps/PCA/analyze_PCs_miRNA_precursor.r")#
pca_analysis(quantile_norm_data, miRNA_length, miRNA_gc_prop,#
		prec_length, prec_gc_prop, 3)
warnings
warnings()
error()
errorS()
errors()
traceback()
# Read quantile normalized data#
# quantile_norm_data retrieved#
load("R_data/saved_quantile_norm_data")#
#
# Read content table w/ sequence data for miRNA & precursor#
miRNA_seq_df <- read.delim("Preliminary_Steps/sequence_content/content_table_miRNA.txt")#
prec_seq_df <- read.delim("Preliminary_Steps/sequence_content/content_table_precursor.txt")#
#
# Create lists for gc proportion and lengths for miRNA & precursor#
miRNA_gc_prop <- miRNA_seq_df$gc_prop#
prec_gc_prop <- prec_seq_df$gc_prop#
miRNA_length <- miRNA_seq_df$length#
prec_length <- prec_seq_df$length#
#
# Do PCA Analysis for all variables#
pca_analysis <- dget("Preliminary_Steps/PCA/analyze_PCs_miRNA_precursor.r")#
pca_analysis(quantile_norm_data, miRNA_length, miRNA_gc_prop,#
		prec_length, prec_gc_prop, 3)
# Read quantile normalized data#
# quantile_norm_data retrieved#
load("R_data/saved_quantile_norm_data")#
#
# Read content table w/ sequence data for miRNA & precursor#
miRNA_seq_df <- read.delim("Preliminary_Steps/sequence_content/content_table_miRNA.txt")#
prec_seq_df <- read.delim("Preliminary_Steps/sequence_content/content_table_precursor.txt")#
#
# Create lists for gc proportion and lengths for miRNA & precursor#
miRNA_gc_prop <- miRNA_seq_df$gc_prop#
prec_gc_prop <- prec_seq_df$gc_prop#
miRNA_length <- miRNA_seq_df$length#
prec_length <- prec_seq_df$length#
#
len(prec_seq_df$gc_prop)#
# Do PCA Analysis for all variables#
pca_analysis <- dget("Preliminary_Steps/PCA/analyze_PCs_miRNA_precursor.r")#
pca_analysis(quantile_norm_data, miRNA_length, miRNA_gc_prop,#
		prec_length, prec_gc_prop, 3)
# Read quantile normalized data#
# quantile_norm_data retrieved#
load("R_data/saved_quantile_norm_data")#
#
# Read content table w/ sequence data for miRNA & precursor#
miRNA_seq_df <- read.delim("Preliminary_Steps/sequence_content/content_table_miRNA.txt")#
prec_seq_df <- read.delim("Preliminary_Steps/sequence_content/content_table_precursor.txt")#
#
# Create lists for gc proportion and lengths for miRNA & precursor#
miRNA_gc_prop <- miRNA_seq_df$gc_prop#
prec_gc_prop <- prec_seq_df$gc_prop#
miRNA_length <- miRNA_seq_df$length#
prec_length <- prec_seq_df$length#
#
length(prec_seq_df$gc_prop)#
# Do PCA Analysis for all variables#
pca_analysis <- dget("Preliminary_Steps/PCA/analyze_PCs_miRNA_precursor.r")#
pca_analysis(quantile_norm_data, miRNA_length, miRNA_gc_prop,#
		prec_length, prec_gc_prop, 3)
head(prec_seq_df$gc_prop)
head(miRNA_gc_prop)
length(miRNA_gc_prop)
# Read quantile normalized data#
# quantile_norm_data retrieved#
load("R_data/saved_quantile_norm_data")#
#
# Read content table w/ sequence data for miRNA & precursor#
miRNA_seq_df <- read.delim("Preliminary_Steps/sequence_content/content_table_miRNA.txt")#
prec_seq_df <- read.delim("Preliminary_Steps/sequence_content/content_table_precursor.txt")#
#
# Create lists for gc proportion and lengths for miRNA & precursor#
miRNA_gc_prop <- miRNA_seq_df$gc_prop#
prec_gc_prop <- prec_seq_df$gc_prop#
miRNA_length <- miRNA_seq_df$length#
prec_length <- prec_seq_df$length#
#
# Do PCA Analysis for all variables#
pca_analysis <- dget("Preliminary_Steps/PCA/analyze_PCs_miRNA_precursor.r")#
pca_analysis(quantile_norm_data, miRNA_length, miRNA_gc_prop,#
		prec_length, prec_gc_prop, 3)
x <- c(1,2,3,4)
y <- c(4,3,9,4)
ggplot(data.frame(xval=x,yval=y), aes(x=xval,y=yval)) + geom_point()
install.packages("ggplot2")
# Read quantile normalized data#
# quantile_norm_data retrieved#
load("R_data/saved_quantile_norm_data")#
#
# Read content table w/ sequence data for miRNA & precursor#
miRNA_seq_df <- read.delim("Preliminary_Steps/sequence_content/content_table_miRNA.txt")#
prec_seq_df <- read.delim("Preliminary_Steps/sequence_content/content_table_precursor.txt")#
#
# Create lists for gc proportion and lengths for miRNA & precursor#
miRNA_gc_prop <- miRNA_seq_df$gc_prop#
prec_gc_prop <- prec_seq_df$gc_prop#
miRNA_length <- miRNA_seq_df$length#
prec_length <- prec_seq_df$length#
#
# Do PCA Analysis for all variables#
pca_analysis <- dget("Preliminary_Steps/PCA/analyze_PCs_miRNA_precursor.r")#
pca_analysis(quantile_norm_data, miRNA_length, miRNA_gc_prop,#
		prec_length, prec_gc_prop, 3)
x
y
df <- data.frame(xval=x,yval=y)
ggplot(df, aes(x=xval,y=yval)) + geom_point(size=1)
print(ggplot(df, aes(x=xval,y=yval)) + geom_point(size=1))
print(ggplot(df, ase(x=xval,y=yval)) + geom_point())
print(ggplot(df, aes(x=xval,y=yval)) + geom_point())
p <- ggplot(df, ase(x=xval,y=yval)) + geom_point()
p <- ggplot(df, aes(x=xval,y=yval)) + geom_point()
print(p)
ggsave("sample.gg",p)
ggsave("sample",p)
ggsave("sample.jpeg",p)
# Read quantile normalized data#
# quantile_norm_data retrieved#
load("R_data/saved_quantile_norm_data")#
#
# Read content table w/ sequence data for miRNA & precursor#
miRNA_seq_df <- read.delim("Preliminary_Steps/sequence_content/content_table_miRNA.txt")#
prec_seq_df <- read.delim("Preliminary_Steps/sequence_content/content_table_precursor.txt")#
#
# Create lists for gc proportion and lengths for miRNA & precursor#
miRNA_gc_prop <- miRNA_seq_df$gc_prop#
prec_gc_prop <- prec_seq_df$gc_prop#
miRNA_length <- miRNA_seq_df$length#
prec_length <- prec_seq_df$length#
#
# Do PCA Analysis for all variables#
pca_analysis <- dget("Preliminary_Steps/PCA/analyze_PCs_miRNA_precursor.r")#
pca_analysis(quantile_norm_data, miRNA_length, miRNA_gc_prop,#
		prec_length, prec_gc_prop, 3)
x <- 1:100
x <- x / 100
x <- 1:100
x <- (x - 1) / 100
pbinom(q, 100, 1/6)
pbinom(x, 100, 1/6)
x <- 1:100
pbinom(x,100,1/6)
prob_dist <- pbinom(x,100,1/6)
expected <- 12/38 * 100
(expected - x) ^2
y <- (expected - x) ^2
prob_dist * y
var <- prob_dist[1:38] * y[1:38]
var <- sum(var)
se <- var ^ (1/2)
se
x <- c(1:10,20:22)
x
# load normalized data#
# loading quantile_norm_data#
load("R_Data/saved_quantile_norm_data")#
#
# subset viral, bacterial, baseline, asymptomatic/symptomatic miRNA expression#
allviral <- quantile_norm_data[,1:21]#
baseline <- quantile_norm_data[,22:42]#
bacterial <- quantile_norm_data[,43:52]#
viral_symptomatic <- quantile_norm_data[,c(1,2,5,9,11,13,15,16,17,18,19,20,21)]#
viral_asymptomatic <- quantile_norm_data[,c(3,4,6,7,8,10,12,14)]#
combined_bacterial_baseline <- quantile_norm_data[,22:52]#
combined_bacterial_allviral <- quantile_norm_data[,c(1:21,43:52)]#
combined_baseline_allviral <- quantile_norm_data[,1:42]#
#
# I didn't make it clear that the matrix should be initialized outside the for loop, or else the for loop will create a new matrix every iteration.  I'll call it P for simplicity#
# make an output matrix for the pvalues of all the tests#
P <- matrix(, ncol=11, nrow=k)#
# conducting a Welch Two Sample t-test on every variable (not assuming equal standard deviation) using a for loop#
for (k in 1:nrow(quantile_norm_data)) {#
	output_vector <- vector()#
	output_vector[1] <- t.test(allviral[,k], bacterial[,k], alternative="two.sided")#
	output_vector[2] <- t.test(allviral[,k], baseline[,k], alternative="two.sided", paired=TRUE)#
	# test2 is a paired t-test #
	output_vector[3] <- t.test(viral_symptomatic[,k], viral_asymptomatic[,k],alternative="two.sided")#
	output_vector[4] <- t.test(bacterial[,k], baseline[,k], alternative="two.sided")#
	output_vector[5] <- t.test(bacterial[,k], viral_symptomatic[,k], alternative="two.sided")#
	output_vector[6] <- t.test(bacterial[,k], viral_asymptomatic[,k], alternative="two.sided")#
	output_vector[7] <- t.test(baseline[,k], viral_symptomatic[,k], alternative="two.sided")#
	output_vector[8] <- t.test(baseline[,k], viral_asymptomatic[,k], alternative="two.sided")#
	output_vector[9] <- t.test(combined_bacterial_baseline[,k], allviral[,k], alternative="two.sided")#
	output_vector[10] <- t.test(combined_bacterial_allviral[,k], baseline[,k], alternative="two.sided")#
	output_vector[11] <- t.test(combined_baseline_allviral[,k], bacterial[,k], alternative="two.sided")#
#
	P[k,] <- output_vector#
}#
#
head(P)
# load normalized data#
# loading quantile_norm_data#
load("R_Data/saved_quantile_norm_data")#
#
# subset viral, bacterial, baseline, asymptomatic/symptomatic miRNA expression#
allviral <- quantile_norm_data[,1:21]#
baseline <- quantile_norm_data[,22:42]#
bacterial <- quantile_norm_data[,43:52]#
viral_symptomatic <- quantile_norm_data[,c(1,2,5,9,11,13,15,16,17,18,19,20,21)]#
viral_asymptomatic <- quantile_norm_data[,c(3,4,6,7,8,10,12,14)]#
combined_bacterial_baseline <- quantile_norm_data[,22:52]#
combined_bacterial_allviral <- quantile_norm_data[,c(1:21,43:52)]#
combined_baseline_allviral <- quantile_norm_data[,1:42]#
#
# I didn't make it clear that the matrix should be initialized outside the for loop, or else the for loop will create a new matrix every iteration.  I'll call it P for simplicity#
# make an output matrix for the pvalues of all the tests#
P <- matrix(, ncol=11, nrow=nrow(quantile_norm_data))#
# conducting a Welch Two Sample t-test on every variable (not assuming equal standard deviation) using a for loop#
for (k in 1:nrow(quantile_norm_data)) {#
	output_vector <- vector()#
	output_vector[1] <- t.test(allviral[,k], bacterial[,k], alternative="two.sided")#
	output_vector[2] <- t.test(allviral[,k], baseline[,k], alternative="two.sided", paired=TRUE)#
	# test2 is a paired t-test #
	output_vector[3] <- t.test(viral_symptomatic[,k], viral_asymptomatic[,k],alternative="two.sided")#
	output_vector[4] <- t.test(bacterial[,k], baseline[,k], alternative="two.sided")#
	output_vector[5] <- t.test(bacterial[,k], viral_symptomatic[,k], alternative="two.sided")#
	output_vector[6] <- t.test(bacterial[,k], viral_asymptomatic[,k], alternative="two.sided")#
	output_vector[7] <- t.test(baseline[,k], viral_symptomatic[,k], alternative="two.sided")#
	output_vector[8] <- t.test(baseline[,k], viral_asymptomatic[,k], alternative="two.sided")#
	output_vector[9] <- t.test(combined_bacterial_baseline[,k], allviral[,k], alternative="two.sided")#
	output_vector[10] <- t.test(combined_bacterial_allviral[,k], baseline[,k], alternative="two.sided")#
	output_vector[11] <- t.test(combined_baseline_allviral[,k], bacterial[,k], alternative="two.sided")#
#
	P[k,] <- output_vector#
}#
#
head(P)
# load normalized data#
# loading quantile_norm_data#
load("R_Data/saved_quantile_norm_data")#
#
# subset viral, bacterial, baseline, asymptomatic/symptomatic miRNA expression#
allviral <- quantile_norm_data[,1:21]#
baseline <- quantile_norm_data[,22:42]#
bacterial <- quantile_norm_data[,43:52]#
viral_symptomatic <- quantile_norm_data[,c(1,2,5,9,11,13,15,16,17,18,19,20,21)]#
viral_asymptomatic <- quantile_norm_data[,c(3,4,6,7,8,10,12,14)]#
combined_bacterial_baseline <- quantile_norm_data[,22:52]#
combined_bacterial_allviral <- quantile_norm_data[,c(1:21,43:52)]#
combined_baseline_allviral <- quantile_norm_data[,1:42]#
#
# I didn't make it clear that the matrix should be initialized outside the for loop, or else the for loop will create a new matrix every iteration.  I'll call it P for simplicity#
# make an output matrix for the pvalues of all the tests#
P <- matrix(, ncol=11, nrow=nrow(quantile_norm_data))#
# conducting a Welch Two Sample t-test on every variable (not assuming equal standard deviation) using a for loop#
for (k in 1:nrow(quantile_norm_data)) {#
	output_vector <- vector()#
	output_vector[1] <- t.test(allviral[,k], bacterial[,k], alternative="two.sided")#
	output_vector[2] <- t.test(allviral[,k], baseline[,k], alternative="two.sided", paired=TRUE)#
	# test2 is a paired t-test #
	output_vector[3] <- t.test(viral_symptomatic[,k], viral_asymptomatic[,k],alternative="two.sided")#
	output_vector[4] <- t.test(bacterial[,k], baseline[,k], alternative="two.sided")#
	output_vector[5] <- t.test(bacterial[,k], viral_symptomatic[,k], alternative="two.sided")#
	output_vector[6] <- t.test(bacterial[,k], viral_asymptomatic[,k], alternative="two.sided")#
	output_vector[7] <- t.test(baseline[,k], viral_symptomatic[,k], alternative="two.sided")#
	output_vector[8] <- t.test(baseline[,k], viral_asymptomatic[,k], alternative="two.sided")#
	output_vector[9] <- t.test(combined_bacterial_baseline[,k], allviral[,k], alternative="two.sided")#
	output_vector[10] <- t.test(combined_bacterial_allviral[,k], baseline[,k], alternative="two.sided")#
	output_vector[11] <- t.test(combined_baseline_allviral[,k], bacterial[,k], alternative="two.sided")#
	length(output_vector)#
	P[k,] <- output_vector#
}#
#
head(P)
# load normalized data#
# loading quantile_norm_data#
load("R_Data/saved_quantile_norm_data")#
#
# subset viral, bacterial, baseline, asymptomatic/symptomatic miRNA expression#
allviral <- quantile_norm_data[,1:21]#
baseline <- quantile_norm_data[,22:42]#
bacterial <- quantile_norm_data[,43:52]#
viral_symptomatic <- quantile_norm_data[,c(1,2,5,9,11,13,15,16,17,18,19,20,21)]#
viral_asymptomatic <- quantile_norm_data[,c(3,4,6,7,8,10,12,14)]#
combined_bacterial_baseline <- quantile_norm_data[,22:52]#
combined_bacterial_allviral <- quantile_norm_data[,c(1:21,43:52)]#
combined_baseline_allviral <- quantile_norm_data[,1:42]#
#
# I didn't make it clear that the matrix should be initialized outside the for loop, or else the for loop will create a new matrix every iteration.  I'll call it P for simplicity#
# make an output matrix for the pvalues of all the tests#
P <- matrix(, ncol=11, nrow=nrow(quantile_norm_data))#
# conducting a Welch Two Sample t-test on every variable (not assuming equal standard deviation) using a for loop#
for (k in 1:nrow(quantile_norm_data)) {#
	output_vector <- vector()#
	output_vector[1] <- t.test(allviral[,k], bacterial[,k], alternative="two.sided")#
	output_vector[2] <- t.test(allviral[,k], baseline[,k], alternative="two.sided", paired=TRUE)#
	# test2 is a paired t-test #
	output_vector[3] <- t.test(viral_symptomatic[,k], viral_asymptomatic[,k],alternative="two.sided")#
	output_vector[4] <- t.test(bacterial[,k], baseline[,k], alternative="two.sided")#
	output_vector[5] <- t.test(bacterial[,k], viral_symptomatic[,k], alternative="two.sided")#
	output_vector[6] <- t.test(bacterial[,k], viral_asymptomatic[,k], alternative="two.sided")#
	output_vector[7] <- t.test(baseline[,k], viral_symptomatic[,k], alternative="two.sided")#
	output_vector[8] <- t.test(baseline[,k], viral_asymptomatic[,k], alternative="two.sided")#
	output_vector[9] <- t.test(combined_bacterial_baseline[,k], allviral[,k], alternative="two.sided")#
	output_vector[10] <- t.test(combined_bacterial_allviral[,k], baseline[,k], alternative="two.sided")#
	output_vector[11] <- t.test(combined_baseline_allviral[,k], bacterial[,k], alternative="two.sided")#
	print(length(output_vector))#
	P[k,] <- output_vector#
}#
#
head(P)
warnings()
# load normalized data#
# loading quantile_norm_data#
load("R_Data/saved_quantile_norm_data")#
#
# subset viral, bacterial, baseline, asymptomatic/symptomatic miRNA expression#
allviral <- quantile_norm_data[,1:21]#
baseline <- quantile_norm_data[,22:42]#
bacterial <- quantile_norm_data[,43:52]#
viral_symptomatic <- quantile_norm_data[,c(1,2,5,9,11,13,15,16,17,18,19,20,21)]#
viral_asymptomatic <- quantile_norm_data[,c(3,4,6,7,8,10,12,14)]#
combined_bacterial_baseline <- quantile_norm_data[,22:52]#
combined_bacterial_allviral <- quantile_norm_data[,c(1:21,43:52)]#
combined_baseline_allviral <- quantile_norm_data[,1:42]#
#
# I didn't make it clear that the matrix should be initialized outside the for loop, or else the for loop will create a new matrix every iteration.  I'll call it P for simplicity#
# make an output matrix for the pvalues of all the tests#
P <- matrix(, nrow=nrow(quantile_norm_data), ncol=11)#
# conducting a Welch Two Sample t-test on every variable (not assuming equal standard deviation) using a for loop#
for (k in 1:nrow(quantile_norm_data)) {#
	output_vector <- []#
	output_vector[1] <- t.test(allviral[,k], bacterial[,k], alternative="two.sided")#
	output_vector[2] <- t.test(allviral[,k], baseline[,k], alternative="two.sided", paired=TRUE)#
	# test2 is a paired t-test #
	output_vector[3] <- t.test(viral_symptomatic[,k], viral_asymptomatic[,k],alternative="two.sided")#
	output_vector[4] <- t.test(bacterial[,k], baseline[,k], alternative="two.sided")#
	output_vector[5] <- t.test(bacterial[,k], viral_symptomatic[,k], alternative="two.sided")#
	output_vector[6] <- t.test(bacterial[,k], viral_asymptomatic[,k], alternative="two.sided")#
	output_vector[7] <- t.test(baseline[,k], viral_symptomatic[,k], alternative="two.sided")#
	output_vector[8] <- t.test(baseline[,k], viral_asymptomatic[,k], alternative="two.sided")#
	output_vector[9] <- t.test(combined_bacterial_baseline[,k], allviral[,k], alternative="two.sided")#
	output_vector[10] <- t.test(combined_bacterial_allviral[,k], baseline[,k], alternative="two.sided")#
	output_vector[11] <- t.test(combined_baseline_allviral[,k], bacterial[,k], alternative="two.sided")#
	print(length(output_vector))#
	P[k,] <- output_vector#
}#
#
head(P)
# load normalized data#
# loading quantile_norm_data#
load("R_Data/saved_quantile_norm_data")#
#
# subset viral, bacterial, baseline, asymptomatic/symptomatic miRNA expression#
allviral <- quantile_norm_data[,1:21]#
baseline <- quantile_norm_data[,22:42]#
bacterial <- quantile_norm_data[,43:52]#
viral_symptomatic <- quantile_norm_data[,c(1,2,5,9,11,13,15,16,17,18,19,20,21)]#
viral_asymptomatic <- quantile_norm_data[,c(3,4,6,7,8,10,12,14)]#
combined_bacterial_baseline <- quantile_norm_data[,22:52]#
combined_bacterial_allviral <- quantile_norm_data[,c(1:21,43:52)]#
combined_baseline_allviral <- quantile_norm_data[,1:42]#
#
# I didn't make it clear that the matrix should be initialized outside the for loop, or else the for loop will create a new matrix every iteration.  I'll call it P for simplicity#
# make an output matrix for the pvalues of all the tests#
P <- matrix(, nrow=nrow(quantile_norm_data), ncol=11)#
# conducting a Welch Two Sample t-test on every variable (not assuming equal standard deviation) using a for loop#
for (k in 1:nrow(quantile_norm_data)) {#
	output_vector <- vector(11)#
	output_vector[1] <- t.test(allviral[,k], bacterial[,k], alternative="two.sided")#
	output_vector[2] <- t.test(allviral[,k], baseline[,k], alternative="two.sided", paired=TRUE)#
	# test2 is a paired t-test #
	output_vector[3] <- t.test(viral_symptomatic[,k], viral_asymptomatic[,k],alternative="two.sided")#
	output_vector[4] <- t.test(bacterial[,k], baseline[,k], alternative="two.sided")#
	output_vector[5] <- t.test(bacterial[,k], viral_symptomatic[,k], alternative="two.sided")#
	output_vector[6] <- t.test(bacterial[,k], viral_asymptomatic[,k], alternative="two.sided")#
	output_vector[7] <- t.test(baseline[,k], viral_symptomatic[,k], alternative="two.sided")#
	output_vector[8] <- t.test(baseline[,k], viral_asymptomatic[,k], alternative="two.sided")#
	output_vector[9] <- t.test(combined_bacterial_baseline[,k], allviral[,k], alternative="two.sided")#
	output_vector[10] <- t.test(combined_bacterial_allviral[,k], baseline[,k], alternative="two.sided")#
	output_vector[11] <- t.test(combined_baseline_allviral[,k], bacterial[,k], alternative="two.sided")#
	print(length(output_vector))#
	P[k,] <- output_vector#
}#
#
head(P)
# load normalized data#
# loading quantile_norm_data#
load("R_Data/saved_quantile_norm_data")#
#
# subset viral, bacterial, baseline, asymptomatic/symptomatic miRNA expression#
allviral <- quantile_norm_data[,1:21]#
baseline <- quantile_norm_data[,22:42]#
bacterial <- quantile_norm_data[,43:52]#
viral_symptomatic <- quantile_norm_data[,c(1,2,5,9,11,13,15,16,17,18,19,20,21)]#
viral_asymptomatic <- quantile_norm_data[,c(3,4,6,7,8,10,12,14)]#
combined_bacterial_baseline <- quantile_norm_data[,22:52]#
combined_bacterial_allviral <- quantile_norm_data[,c(1:21,43:52)]#
combined_baseline_allviral <- quantile_norm_data[,1:42]#
#
# I didn't make it clear that the matrix should be initialized outside the for loop, or else the for loop will create a new matrix every iteration.  I'll call it P for simplicity#
# make an output matrix for the pvalues of all the tests#
P <- matrix(, nrow=nrow(quantile_norm_data), ncol=11)#
# conducting a Welch Two Sample t-test on every variable (not assuming equal standard deviation) using a for loop#
for (k in 1:nrow(quantile_norm_data)) {#
	output_vector <- vector(length=11)#
	output_vector[1] <- t.test(allviral[,k], bacterial[,k], alternative="two.sided")#
	output_vector[2] <- t.test(allviral[,k], baseline[,k], alternative="two.sided", paired=TRUE)#
	# test2 is a paired t-test #
	output_vector[3] <- t.test(viral_symptomatic[,k], viral_asymptomatic[,k],alternative="two.sided")#
	output_vector[4] <- t.test(bacterial[,k], baseline[,k], alternative="two.sided")#
	output_vector[5] <- t.test(bacterial[,k], viral_symptomatic[,k], alternative="two.sided")#
	output_vector[6] <- t.test(bacterial[,k], viral_asymptomatic[,k], alternative="two.sided")#
	output_vector[7] <- t.test(baseline[,k], viral_symptomatic[,k], alternative="two.sided")#
	output_vector[8] <- t.test(baseline[,k], viral_asymptomatic[,k], alternative="two.sided")#
	output_vector[9] <- t.test(combined_bacterial_baseline[,k], allviral[,k], alternative="two.sided")#
	output_vector[10] <- t.test(combined_bacterial_allviral[,k], baseline[,k], alternative="two.sided")#
	output_vector[11] <- t.test(combined_baseline_allviral[,k], bacterial[,k], alternative="two.sided")#
	print(length(output_vector))#
	P[k,] <- output_vector#
}#
#
head(P)
# load normalized data#
# loading quantile_norm_data#
load("R_Data/saved_quantile_norm_data")#
#
# subset viral, bacterial, baseline, asymptomatic/symptomatic miRNA expression#
allviral <- quantile_norm_data[,1:21]#
baseline <- quantile_norm_data[,22:42]#
bacterial <- quantile_norm_data[,43:52]#
viral_symptomatic <- quantile_norm_data[,c(1,2,5,9,11,13,15,16,17,18,19,20,21)]#
viral_asymptomatic <- quantile_norm_data[,c(3,4,6,7,8,10,12,14)]#
combined_bacterial_baseline <- quantile_norm_data[,22:52]#
combined_bacterial_allviral <- quantile_norm_data[,c(1:21,43:52)]#
combined_baseline_allviral <- quantile_norm_data[,1:42]#
#
# I didn't make it clear that the matrix should be initialized outside the for loop, or else the for loop will create a new matrix every iteration.  I'll call it P for simplicity#
# make an output matrix for the pvalues of all the tests#
P <- matrix(, nrow=nrow(quantile_norm_data), ncol=11)#
# conducting a Welch Two Sample t-test on every variable (not assuming equal standard deviation) using a for loop#
for (k in 1:nrow(quantile_norm_data)) {#
	output_vector <- vector(length=11)#
	output_vector[1] <- t.test(allviral[,k], bacterial[,k], alternative="two.sided")#
	output_vector[2] <- t.test(allviral[,k], baseline[,k], alternative="two.sided", paired=TRUE)#
	# test2 is a paired t-test #
	output_vector[3] <- t.test(viral_symptomatic[,k], viral_asymptomatic[,k],alternative="two.sided")#
	output_vector[4] <- t.test(bacterial[,k], baseline[,k], alternative="two.sided")#
	output_vector[5] <- t.test(bacterial[,k], viral_symptomatic[,k], alternative="two.sided")#
	output_vector[6] <- t.test(bacterial[,k], viral_asymptomatic[,k], alternative="two.sided")#
	output_vector[7] <- t.test(baseline[,k], viral_symptomatic[,k], alternative="two.sided")#
	output_vector[8] <- t.test(baseline[,k], viral_asymptomatic[,k], alternative="two.sided")#
	output_vector[9] <- t.test(combined_bacterial_baseline[,k], allviral[,k], alternative="two.sided")#
	output_vector[10] <- t.test(combined_bacterial_allviral[,k], baseline[,k], alternative="two.sided")#
	output_vector[11] <- t.test(combined_baseline_allviral[,k], bacterial[,k], alternative="two.sided")#
	print(output_vector)#
	P[k,] <- output_vector#
}#
#
head(P)
# load normalized data#
# loading quantile_norm_data#
load("R_Data/saved_quantile_norm_data")#
#
# subset viral, bacterial, baseline, asymptomatic/symptomatic miRNA expression#
allviral <- quantile_norm_data[,1:21]#
baseline <- quantile_norm_data[,22:42]#
bacterial <- quantile_norm_data[,43:52]#
viral_symptomatic <- quantile_norm_data[,c(1,2,5,9,11,13,15,16,17,18,19,20,21)]#
viral_asymptomatic <- quantile_norm_data[,c(3,4,6,7,8,10,12,14)]#
combined_bacterial_baseline <- quantile_norm_data[,22:52]#
combined_bacterial_allviral <- quantile_norm_data[,c(1:21,43:52)]#
combined_baseline_allviral <- quantile_norm_data[,1:42]#
#
# I didn't make it clear that the matrix should be initialized outside the for loop, or else the for loop will create a new matrix every iteration.  I'll call it P for simplicity#
# make an output matrix for the pvalues of all the tests#
P <- matrix(, nrow=nrow(quantile_norm_data), ncol=11)#
# conducting a Welch Two Sample t-test on every variable (not assuming equal standard deviation) using a for loop#
for (k in 1:nrow(quantile_norm_data)) {#
	output_vector <- vector(length=11)#
	output_vector[1] <- t.test(allviral[,k], bacterial[,k], alternative="two.sided")#
	print(t.test(allviral[,k], bacterial[,k], alternative="two.sided"))#
	output_vector[2] <- t.test(allviral[,k], baseline[,k], alternative="two.sided", paired=TRUE)#
	# test2 is a paired t-test #
	output_vector[3] <- t.test(viral_symptomatic[,k], viral_asymptomatic[,k],alternative="two.sided")#
	output_vector[4] <- t.test(bacterial[,k], baseline[,k], alternative="two.sided")#
	output_vector[5] <- t.test(bacterial[,k], viral_symptomatic[,k], alternative="two.sided")#
	output_vector[6] <- t.test(bacterial[,k], viral_asymptomatic[,k], alternative="two.sided")#
	output_vector[7] <- t.test(baseline[,k], viral_symptomatic[,k], alternative="two.sided")#
	output_vector[8] <- t.test(baseline[,k], viral_asymptomatic[,k], alternative="two.sided")#
	output_vector[9] <- t.test(combined_bacterial_baseline[,k], allviral[,k], alternative="two.sided")#
	output_vector[10] <- t.test(combined_bacterial_allviral[,k], baseline[,k], alternative="two.sided")#
	output_vector[11] <- t.test(combined_baseline_allviral[,k], bacterial[,k], alternative="two.sided")#
	P[k,] <- output_vector#
}#
#
head(P)
# load normalized data#
# loading quantile_norm_data#
load("R_Data/saved_quantile_norm_data")#
#
# subset viral, bacterial, baseline, asymptomatic/symptomatic miRNA expression#
allviral <- quantile_norm_data[,1:21]#
baseline <- quantile_norm_data[,22:42]#
bacterial <- quantile_norm_data[,43:52]#
viral_symptomatic <- quantile_norm_data[,c(1,2,5,9,11,13,15,16,17,18,19,20,21)]#
viral_asymptomatic <- quantile_norm_data[,c(3,4,6,7,8,10,12,14)]#
combined_bacterial_baseline <- quantile_norm_data[,22:52]#
combined_bacterial_allviral <- quantile_norm_data[,c(1:21,43:52)]#
combined_baseline_allviral <- quantile_norm_data[,1:42]#
#
do_t_test <- function(s1, s2, is_paired) {#
	result <- t.test(s1, s2, alternative="two.sided", paired=is_paired)#
	return(result[p.value])#
}#
#
# I didn't make it clear that the matrix should be initialized outside the for loop, or else the for loop will create a new matrix every iteration.  I'll call it P for simplicity#
# make an output matrix for the pvalues of all the tests#
P <- matrix(, nrow=nrow(quantile_norm_data), ncol=11)#
# conducting a Welch Two Sample t-test on every variable (not assuming equal standard deviation) using a for loop#
for (k in 1:nrow(quantile_norm_data)) {#
	output_vector <- vector(length=11)#
	output_vector[1] <- do_t_test(allviral[,k], bacterial[,k], FALSE)#
	output_vector[2] <- do_t_test(allviral[,k], baseline[,k], TRUE)#
	output_vector[3] <- do_t_test(viral_symptomatic[,k], viral_asymptomatic[,k], FALSE)#
	output_vector[4] <- do_t_test(bacterial[,k], baseline[,k], FALSE)#
	output_vector[5] <- do_t_test(bacterial[,k], viral_symptomatic[,k], FALSE)#
	output_vector[6] <- do_t_test(bacterial[,k], viral_asymptomatic[,k], FALSE)#
	output_vector[7] <- do_t_test(baseline[,k], viral_symptomatic[,k], FALSE)#
	output_vector[8] <- do_t_test(baseline[,k], viral_asymptomatic[,k], FALSE)#
	output_vector[9] <- do_t_test(combined_bacterial_baseline[,k], allviral[,k], FALSE)#
	output_vector[10] <- do_t_test(combined_bacterial_allviral[,k], baseline[,k], FALSE)#
	output_vector[11] <- do_t_test(combined_baseline_allviral[,k], bacterial[,k], FALSE)#
	P[k,] <- output_vector#
}#
#
head(P)
# load normalized data#
# loading quantile_norm_data#
load("R_Data/saved_quantile_norm_data")#
#
# subset viral, bacterial, baseline, asymptomatic/symptomatic miRNA expression#
allviral <- quantile_norm_data[,1:21]#
baseline <- quantile_norm_data[,22:42]#
bacterial <- quantile_norm_data[,43:52]#
viral_symptomatic <- quantile_norm_data[,c(1,2,5,9,11,13,15,16,17,18,19,20,21)]#
viral_asymptomatic <- quantile_norm_data[,c(3,4,6,7,8,10,12,14)]#
combined_bacterial_baseline <- quantile_norm_data[,22:52]#
combined_bacterial_allviral <- quantile_norm_data[,c(1:21,43:52)]#
combined_baseline_allviral <- quantile_norm_data[,1:42]#
#
do_t_test <- function(s1, s2, is_paired) {#
	result <- t.test(s1, s2, alternative="two.sided", paired=is_paired)#
	print(class(result))#
	return(result[p.value])#
}#
#
# I didn't make it clear that the matrix should be initialized outside the for loop, or else the for loop will create a new matrix every iteration.  I'll call it P for simplicity#
# make an output matrix for the pvalues of all the tests#
P <- matrix(, nrow=nrow(quantile_norm_data), ncol=11)#
# conducting a Welch Two Sample t-test on every variable (not assuming equal standard deviation) using a for loop#
for (k in 1:nrow(quantile_norm_data)) {#
	output_vector <- vector(length=11)#
	output_vector[1] <- do_t_test(allviral[,k], bacterial[,k], FALSE)#
	output_vector[2] <- do_t_test(allviral[,k], baseline[,k], TRUE)#
	output_vector[3] <- do_t_test(viral_symptomatic[,k], viral_asymptomatic[,k], FALSE)#
	output_vector[4] <- do_t_test(bacterial[,k], baseline[,k], FALSE)#
	output_vector[5] <- do_t_test(bacterial[,k], viral_symptomatic[,k], FALSE)#
	output_vector[6] <- do_t_test(bacterial[,k], viral_asymptomatic[,k], FALSE)#
	output_vector[7] <- do_t_test(baseline[,k], viral_symptomatic[,k], FALSE)#
	output_vector[8] <- do_t_test(baseline[,k], viral_asymptomatic[,k], FALSE)#
	output_vector[9] <- do_t_test(combined_bacterial_baseline[,k], allviral[,k], FALSE)#
	output_vector[10] <- do_t_test(combined_bacterial_allviral[,k], baseline[,k], FALSE)#
	output_vector[11] <- do_t_test(combined_baseline_allviral[,k], bacterial[,k], FALSE)#
	P[k,] <- output_vector#
}
# make an output matrix for the pvalues of all the tests#
P <- matrix(, nrow=nrow(quantile_norm_data), ncol=11)#
# conducting a Welch Two Sample t-test on every variable (not assuming equal standard deviation) using a for loop#
for (k in 1:nrow(quantile_norm_data)) {#
	output_vector <- vector(length=11)#
	output_vector[1] <- do_t_test(allviral[,k], bacterial[,k], FALSE)#
	output_vector[2] <- do_t_test(allviral[,k], baseline[,k], TRUE)#
	output_vector[3] <- do_t_test(viral_symptomatic[,k], viral_asymptomatic[,k], FALSE)#
	output_vector[4] <- do_t_test(bacterial[,k], baseline[,k], FALSE)#
	output_vector[5] <- do_t_test(bacterial[,k], viral_symptomatic[,k], FALSE)#
	output_vector[6] <- do_t_test(bacterial[,k], viral_asymptomatic[,k], FALSE)#
	output_vector[7] <- do_t_test(baseline[,k], viral_symptomatic[,k], FALSE)#
	output_vector[8] <- do_t_test(baseline[,k], viral_asymptomatic[,k], FALSE)#
	output_vector[9] <- do_t_test(combined_bacterial_baseline[,k], allviral[,k], FALSE)#
	output_vector[10] <- do_t_test(combined_bacterial_allviral[,k], baseline[,k], FALSE)#
	output_vector[11] <- do_t_test(combined_baseline_allviral[,k], bacterial[,k], FALSE)#
	P[k,] <- output_vector#
}
# load normalized data#
# loading quantile_norm_data#
load("R_Data/saved_quantile_norm_data")#
#
# subset viral, bacterial, baseline, asymptomatic/symptomatic miRNA expression#
allviral <- quantile_norm_data[,1:21]#
baseline <- quantile_norm_data[,22:42]#
bacterial <- quantile_norm_data[,43:52]#
viral_symptomatic <- quantile_norm_data[,c(1,2,5,9,11,13,15,16,17,18,19,20,21)]#
viral_asymptomatic <- quantile_norm_data[,c(3,4,6,7,8,10,12,14)]#
combined_bacterial_baseline <- quantile_norm_data[,22:52]#
combined_bacterial_allviral <- quantile_norm_data[,c(1:21,43:52)]#
combined_baseline_allviral <- quantile_norm_data[,1:42]#
#
do_t_test <- function(s1, s2, is_paired) {#
	result <- t.test(s1, s2, alternative="two.sided", paired=is_paired)#
	return(result[[p.value]])#
}#
#
# I didn't make it clear that the matrix should be initialized outside the for loop, or else the for loop will create a new matrix every iteration.  I'll call it P for simplicity#
# make an output matrix for the pvalues of all the tests#
P <- matrix(, nrow=nrow(quantile_norm_data), ncol=11)#
# conducting a Welch Two Sample t-test on every variable (not assuming equal standard deviation) using a for loop#
for (k in 1:nrow(quantile_norm_data)) {#
	output_vector <- vector(length=11)#
	output_vector[1] <- do_t_test(allviral[,k], bacterial[,k], FALSE)#
	output_vector[2] <- do_t_test(allviral[,k], baseline[,k], TRUE)#
	output_vector[3] <- do_t_test(viral_symptomatic[,k], viral_asymptomatic[,k], FALSE)#
	output_vector[4] <- do_t_test(bacterial[,k], baseline[,k], FALSE)#
	output_vector[5] <- do_t_test(bacterial[,k], viral_symptomatic[,k], FALSE)#
	output_vector[6] <- do_t_test(bacterial[,k], viral_asymptomatic[,k], FALSE)#
	output_vector[7] <- do_t_test(baseline[,k], viral_symptomatic[,k], FALSE)#
	output_vector[8] <- do_t_test(baseline[,k], viral_asymptomatic[,k], FALSE)#
	output_vector[9] <- do_t_test(combined_bacterial_baseline[,k], allviral[,k], FALSE)#
	output_vector[10] <- do_t_test(combined_bacterial_allviral[,k], baseline[,k], FALSE)#
	output_vector[11] <- do_t_test(combined_baseline_allviral[,k], bacterial[,k], FALSE)#
	P[k,] <- output_vector#
}#
#
head(P)
# load normalized data#
# loading quantile_norm_data#
load("R_Data/saved_quantile_norm_data")#
#
# subset viral, bacterial, baseline, asymptomatic/symptomatic miRNA expression#
allviral <- quantile_norm_data[,1:21]#
baseline <- quantile_norm_data[,22:42]#
bacterial <- quantile_norm_data[,43:52]#
viral_symptomatic <- quantile_norm_data[,c(1,2,5,9,11,13,15,16,17,18,19,20,21)]#
viral_asymptomatic <- quantile_norm_data[,c(3,4,6,7,8,10,12,14)]#
combined_bacterial_baseline <- quantile_norm_data[,22:52]#
combined_bacterial_allviral <- quantile_norm_data[,c(1:21,43:52)]#
combined_baseline_allviral <- quantile_norm_data[,1:42]#
#
do_t_test <- function(s1, s2, is_paired) {#
	result <- t.test(s1, s2, alternative="two.sided", paired=is_paired)#
	return(result$p.value)#
}#
#
# I didn't make it clear that the matrix should be initialized outside the for loop, or else the for loop will create a new matrix every iteration.  I'll call it P for simplicity#
# make an output matrix for the pvalues of all the tests#
P <- matrix(, nrow=nrow(quantile_norm_data), ncol=11)#
# conducting a Welch Two Sample t-test on every variable (not assuming equal standard deviation) using a for loop#
for (k in 1:nrow(quantile_norm_data)) {#
	output_vector <- vector(length=11)#
	output_vector[1] <- do_t_test(allviral[,k], bacterial[,k], FALSE)#
	output_vector[2] <- do_t_test(allviral[,k], baseline[,k], TRUE)#
	output_vector[3] <- do_t_test(viral_symptomatic[,k], viral_asymptomatic[,k], FALSE)#
	output_vector[4] <- do_t_test(bacterial[,k], baseline[,k], FALSE)#
	output_vector[5] <- do_t_test(bacterial[,k], viral_symptomatic[,k], FALSE)#
	output_vector[6] <- do_t_test(bacterial[,k], viral_asymptomatic[,k], FALSE)#
	output_vector[7] <- do_t_test(baseline[,k], viral_symptomatic[,k], FALSE)#
	output_vector[8] <- do_t_test(baseline[,k], viral_asymptomatic[,k], FALSE)#
	output_vector[9] <- do_t_test(combined_bacterial_baseline[,k], allviral[,k], FALSE)#
	output_vector[10] <- do_t_test(combined_bacterial_allviral[,k], baseline[,k], FALSE)#
	output_vector[11] <- do_t_test(combined_baseline_allviral[,k], bacterial[,k], FALSE)#
	P[k,] <- output_vector#
}#
#
head(P)
known_data <-read.delim("miRDeep2_Data/known_miRNAs_expressed_all_samples.txt", header=TRUE)
known_data
head(known_data)
known_data[nrow(known_data),]
# Retrieve Data#
# quantile_norm_data retrieved#
load("R_data/saved_quantile_norm_data")#
#
# Do PCA Analysis#
pca_analysis <- dget("Preliminary_Steps/PCA/analyze_PCs_samples.r")#
pca_analysis(quantile_norm_data, 10)
# load normalized data#
# loading quantile_norm_data#
load("R_Data/saved_quantile_norm_data")#
#
# subset viral, bacterial, baseline, asymptomatic/symptomatic miRNA expression#
allviral <- quantile_norm_data[,1:21]#
baseline <- quantile_norm_data[,22:42]#
bacterial <- quantile_norm_data[,43:52]#
viral_symptomatic <- quantile_norm_data[,c(1,2,5,9,11,13,15,16,17,18,19,20,21)]#
viral_asymptomatic <- quantile_norm_data[,c(3,4,6,7,8,10,12,14)]#
combined_bacterial_baseline <- quantile_norm_data[,22:52]#
combined_bacterial_allviral <- quantile_norm_data[,c(1:21,43:52)]#
combined_baseline_allviral <- quantile_norm_data[,1:42]#
#
# Make sure you compartmentalize repeated code in a function.  Helps to make code more concise, easier to read, and debug#
do_t_test <- function(s1, s2, is_paired) {#
	result <- t.test(s1, s2, alternative="two.sided", paired=is_paired)#
	return(result$p.value)#
}#
#
# I didn't make it clear that the matrix should be initialized outside the for loop, or else the for loop will create a new matrix every iteration.  I'll call it P for simplicity#
# make an output matrix for the pvalues of all the tests#
P <- matrix(, nrow=nrow(quantile_norm_data), ncol=11)#
# conducting a Welch Two Sample t-test on every variable (not assuming equal standard deviation) using a for loop#
for (k in 1:nrow(quantile_norm_data)) {#
	output_vector <- vector(length=11)#
	output_vector[1] <- do_t_test(allviral[,k], bacterial[,k], FALSE)#
	output_vector[2] <- do_t_test(allviral[,k], baseline[,k], TRUE)#
	output_vector[3] <- do_t_test(viral_symptomatic[,k], viral_asymptomatic[,k], FALSE)#
	output_vector[4] <- do_t_test(bacterial[,k], baseline[,k], FALSE)#
	output_vector[5] <- do_t_test(bacterial[,k], viral_symptomatic[,k], FALSE)#
	output_vector[6] <- do_t_test(bacterial[,k], viral_asymptomatic[,k], FALSE)#
	output_vector[7] <- do_t_test(baseline[,k], viral_symptomatic[,k], FALSE)#
	output_vector[8] <- do_t_test(baseline[,k], viral_asymptomatic[,k], FALSE)#
	output_vector[9] <- do_t_test(combined_bacterial_baseline[,k], allviral[,k], FALSE)#
	output_vector[10] <- do_t_test(combined_bacterial_allviral[,k], baseline[,k], FALSE)#
	output_vector[11] <- do_t_test(combined_baseline_allviral[,k], bacterial[,k], FALSE)#
	P[k,] <- output_vector#
}#
#
P[1:20,]
errors()
warnings()
quantile_norm_data[1:20,]
# load normalized data#
# loading quantile_norm_data#
load("R_Data/saved_quantile_norm_data")#
#
# subset viral, bacterial, baseline, asymptomatic/symptomatic miRNA expression#
allviral <- quantile_norm_data[,1:21]#
baseline <- quantile_norm_data[,22:42]#
bacterial <- quantile_norm_data[,43:52]#
viral_symptomatic <- quantile_norm_data[,c(1,2,5,9,11,13,15,16,17,18,19,20,21)]#
viral_asymptomatic <- quantile_norm_data[,c(3,4,6,7,8,10,12,14)]#
combined_bacterial_baseline <- quantile_norm_data[,22:52]#
combined_bacterial_allviral <- quantile_norm_data[,c(1:21,43:52)]#
combined_baseline_allviral <- quantile_norm_data[,1:42]#
#
# t-test function#
do_t_test <- function(s1, s2, is_paired) {#
	result <- t.test(s1, s2, alternative="two.sided", paired=is_paired)#
	return(result$p.value)#
}#
#
# make an output matrix for the pvalues of all the tests#
P <- matrix(, nrow=nrow(quantile_norm_data), ncol=11)#
#
# conducting a Welch Two Sample t-test on every variable (not assuming equal standard deviation) using a for loop#
for (k in 1:nrow(quantile_norm_data)) {#
	output_vector <- vector(length=11)#
	output_vector[1] <- do_t_test(allviral[,k], bacterial[,k], FALSE)#
	output_vector[2] <- do_t_test(allviral[,k], baseline[,k], TRUE)#
	output_vector[3] <- do_t_test(viral_symptomatic[,k], viral_asymptomatic[,k], FALSE)#
	output_vector[4] <- do_t_test(bacterial[,k], baseline[,k], FALSE)#
	output_vector[5] <- do_t_test(bacterial[,k], viral_symptomatic[,k], FALSE)#
	output_vector[6] <- do_t_test(bacterial[,k], viral_asymptomatic[,k], FALSE)#
	output_vector[7] <- do_t_test(baseline[,k], viral_symptomatic[,k], FALSE)#
	output_vector[8] <- do_t_test(baseline[,k], viral_asymptomatic[,k], FALSE)#
	output_vector[9] <- do_t_test(combined_bacterial_baseline[,k], allviral[,k], FALSE)#
	output_vector[10] <- do_t_test(combined_bacterial_allviral[,k], baseline[,k], FALSE)#
	output_vector[11] <- do_t_test(combined_baseline_allviral[,k], bacterial[,k], FALSE)#
	if (k <= 20) {print(output_vector)}#
	P[k,] <- output_vector#
}#
#
quantile_norm_data[1:20,]#
P[1:20,]
# load normalized data#
# loading quantile_norm_data#
load("R_Data/saved_quantile_norm_data")#
#
# subset viral, bacterial, baseline, asymptomatic/symptomatic miRNA expression#
allviral <- quantile_norm_data[,1:21]#
baseline <- quantile_norm_data[,22:42]#
bacterial <- quantile_norm_data[,43:52]#
viral_symptomatic <- quantile_norm_data[,c(1,2,5,9,11,13,15,16,17,18,19,20,21)]#
viral_asymptomatic <- quantile_norm_data[,c(3,4,6,7,8,10,12,14)]#
combined_bacterial_baseline <- quantile_norm_data[,22:52]#
combined_bacterial_allviral <- quantile_norm_data[,c(1:21,43:52)]#
combined_baseline_allviral <- quantile_norm_data[,1:42]#
#
# t-test function#
do_t_test <- function(s1, s2, is_paired) {#
	result <- t.test(s1, s2, alternative="two.sided", paired=is_paired)#
	return(result$p.value)#
}#
#
# make an output matrix for the pvalues of all the tests#
P <- matrix(, nrow=nrow(quantile_norm_data), ncol=11)#
#
# conducting a Welch Two Sample t-test on every variable (not assuming equal standard deviation) using a for loop#
for (k in 1:nrow(quantile_norm_data)) {#
	output_vector <- vector(length=11)#
	output_vector[1] <- do_t_test(allviral[k,], bacterial[k,], FALSE)#
	output_vector[2] <- do_t_test(allviral[k,], baseline[k,], TRUE)#
	output_vector[3] <- do_t_test(viral_symptomatic[k,], viral_asymptomatic[k,], FALSE)#
	output_vector[4] <- do_t_test(bacterial[k,], baseline[k,], FALSE)#
	output_vector[5] <- do_t_test(bacterial[k,], viral_symptomatic[k,], FALSE)#
	output_vector[6] <- do_t_test(bacterial[k,], viral_asymptomatic[k,], FALSE)#
	output_vector[7] <- do_t_test(baseline[k,], viral_symptomatic[k,], FALSE)#
	output_vector[8] <- do_t_test(baseline[k,], viral_asymptomatic[k,], FALSE)#
	output_vector[9] <- do_t_test(combined_bacterial_baseline[k,], allviral[k,], FALSE)#
	output_vector[10] <- do_t_test(combined_bacterial_allviral[k,], baseline[k,], FALSE)#
	output_vector[11] <- do_t_test(combined_baseline_allviral[k,], bacterial[k,], FALSE)#
	if (k <= 20) {print(output_vector)}#
	P[k,] <- output_vector#
}#
#
quantile_norm_data[1:20,]#
P[1:20,]
# load normalized data#
# loading quantile_norm_data#
load("R_Data/saved_quantile_norm_data")#
#
# subset viral, bacterial, baseline, asymptomatic/symptomatic miRNA expression#
allviral <- quantile_norm_data[,1:21]#
baseline <- quantile_norm_data[,22:42]#
bacterial <- quantile_norm_data[,43:52]#
viral_symptomatic <- quantile_norm_data[,c(1,2,5,9,11,13,15,16,17,18,19,20,21)]#
viral_asymptomatic <- quantile_norm_data[,c(3,4,6,7,8,10,12,14)]#
combined_bacterial_baseline <- quantile_norm_data[,22:52]#
combined_bacterial_allviral <- quantile_norm_data[,c(1:21,43:52)]#
combined_baseline_allviral <- quantile_norm_data[,1:42]#
#
# t-test function#
do_t_test <- function(s1, s2, is_paired) {#
	result <- t.test(s1, s2, alternative="two.sided", paired=is_paired)#
	return(result$p.value)#
}#
#
# make an output matrix for the pvalues of all the tests#
p_vals <- matrix(, nrow=nrow(quantile_norm_data), ncol=11)#
#
# conducting a Welch Two Sample t-test on every variable (not assuming equal standard deviation) using a for loop#
for (k in 1:nrow(quantile_norm_data)) {#
	output_vector <- vector(length=11)#
	output_vector[1] <- do_t_test(allviral[k,], bacterial[k,], FALSE)#
	output_vector[2] <- do_t_test(allviral[k,], baseline[k,], TRUE)#
	output_vector[3] <- do_t_test(viral_symptomatic[k,], viral_asymptomatic[k,], FALSE)#
	output_vector[4] <- do_t_test(bacterial[k,], baseline[k,], FALSE)#
	output_vector[5] <- do_t_test(bacterial[k,], viral_symptomatic[k,], FALSE)#
	output_vector[6] <- do_t_test(bacterial[k,], viral_asymptomatic[k,], FALSE)#
	output_vector[7] <- do_t_test(baseline[k,], viral_symptomatic[k,], FALSE)#
	output_vector[8] <- do_t_test(baseline[k,], viral_asymptomatic[k,], FALSE)#
	output_vector[9] <- do_t_test(combined_bacterial_baseline[k,], allviral[k,], FALSE)#
	output_vector[10] <- do_t_test(combined_bacterial_allviral[k,], baseline[k,], FALSE)#
	output_vector[11] <- do_t_test(combined_baseline_allviral[k,], bacterial[k,], FALSE)#
	p_vals[k,] <- output_vector#
}#
#
# save p_vals matrix#
save(p_vals, file="R_Data/saved_p_vals")
load("/Users/mrincredible/Box Sync/Home Folder csh36/Sharing/Data_Plus/R_Data/saved_raw_data.r")
load("/Users/mrincredible/Box Sync/Home Folder csh36/Sharing/Data_Plus/R_Data/saved_processed_data.r")
x <- rep.int(1,3)
x
x <- rep_len("Marty",3)
x
# Factors are:#
# Viral Symptomatic - v_s#
# Viral Asymptomatic - v_as#
# Baseline - bl#
# Bacteria - bc#
#
# Write factors for viral symptomatic & asymptomatic#
viral_symp_indices <- c(1,2,5,9,11,13,15,16,17,18,19,20,21)#
viral_asymp_indices <- c(3,4,6,7,8,10,12,14)#
viral <- vector(length=21)#
for (i in viral_symp_indices) {#
	viral[i] <- "v_s"#
}#
for (i in viral_asymp_indices) {#
	viral[i] <- "v_as"#
}#
#
# Write factors for baseline#
baseline <- rep_len("bl", 21)#
#
# Write factors for bacteria#
bacteria <- rep_len("bc", 10)#
#
# Get one big factor vector#
category_vector <- c(viral, baseline, bacteria)#
sample_factors <- factor(category_vector)#
sample_factors#
#
# Save factor vector#
save(sample_factors, "R_Data_temp/saved_sample_factors.r")
getwd()
# Factors are:#
# Viral Symptomatic - v_s#
# Viral Asymptomatic - v_as#
# Baseline - bl#
# Bacteria - bc#
#
# Write factors for viral symptomatic & asymptomatic#
viral_symp_indices <- c(1,2,5,9,11,13,15,16,17,18,19,20,21)#
viral_asymp_indices <- c(3,4,6,7,8,10,12,14)#
viral <- vector(length=21)#
for (i in viral_symp_indices) {#
	viral[i] <- "v_s"#
}#
for (i in viral_asymp_indices) {#
	viral[i] <- "v_as"#
}#
#
# Write factors for baseline#
baseline <- rep_len("bl", 21)#
#
# Write factors for bacteria#
bacteria <- rep_len("bc", 10)#
#
# Get one big factor vector#
category_vector <- c(viral, baseline, bacteria)#
sample_factors <- factor(category_vector)#
sample_factors#
#
# Save factor vector#
save(sample_factors, file="R_Data_temp/saved_sample_factors.r")
length(sample_factors)
choose <- c(FALSE, TRUE, FALSE)
el <- c(1,2,3,4,5,6,7,8,9)
X <- matrix(el, nrow=3, ncol=3)
X
X_sub <- X[choose,]
X_sub
