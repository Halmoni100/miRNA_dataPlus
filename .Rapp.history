k
for (k in 1:333){#
	colneeded <- quantile_norm_data[,k]#
	allviral[,k] <- quantile_norm_data[1:21]#
baseline[,k] <- quantile_norm_data[22:42]#
bacterial[,k] <- quantile_norm_data[43:52]#
viral_symptomatic_vector <- c(1,2,5,9,11,13,15,16,17,18,19,20,21)#
viral_asymptomatic_vector <- c(3,4,6,7,8,10,12,14)#
viral_symptomatic[k,] <- quantile_norm_data[viral_symptomatic_vector]#
viral_asymptomatic[k,] <- quantile_norm_data[viral_asymptomatic_vector]#
combined_bacterial_baseline[k,] <- quantile_norm_data[22:52]#
combined_bacterial_allviral_vector <- c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,43,44,45,46,47,48,49,50,51,52)#
combined_bacterial_allviral[k,] <- quantile_norm_data[combined_bacterial_allviral_vector]#
combined_baseline_allviral[k,] <- quantile_norm_data[1:42]#
}
for (k in 1:333){#
	colneeded <- quantile_norm_data[,k]#
	allviral <- colneeded[1:21]#
baseline <- quantile_norm_data[22:42]#
bacterial <- quantile_norm_data[43:52]#
viral_symptomatic_vector <- c(1,2,5,9,11,13,15,16,17,18,19,20,21)#
viral_asymptomatic_vector <- c(3,4,6,7,8,10,12,14)#
viral_symptomatic <- quantile_norm_data[viral_symptomatic_vector]#
viral_asymptomatic <- quantile_norm_data[viral_asymptomatic_vector]#
combined_bacterial_baseline <- quantile_norm_data[22:52]#
combined_bacterial_allviral_vector <- c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,43,44,45,46,47,48,49,50,51,52)#
combined_bacterial_allviral <- quantile_norm_data[combined_bacterial_allviral_vector]#
combined_baseline_allviral <- quantile_norm_data[1:42]#
}
for (k in 1:333){#
	colneeded <- quantile_norm_data[k]#
	allviral <- colneeded[1:21]#
baseline <- quantile_norm_data[22:42]#
bacterial <- quantile_norm_data[43:52]#
viral_symptomatic_vector <- c(1,2,5,9,11,13,15,16,17,18,19,20,21)#
viral_asymptomatic_vector <- c(3,4,6,7,8,10,12,14)#
viral_symptomatic <- quantile_norm_data[viral_symptomatic_vector]#
viral_asymptomatic <- quantile_norm_data[viral_asymptomatic_vector]#
combined_bacterial_baseline <- quantile_norm_data[22:52]#
combined_bacterial_allviral_vector <- c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,43,44,45,46,47,48,49,50,51,52)#
combined_bacterial_allviral <- quantile_norm_data[combined_bacterial_allviral_vector]#
combined_baseline_allviral <- quantile_norm_data[1:42]#
}
k
allviral
baseline
allviral <- quantile_norm_data[k,1:21]
allviral
allviral <- quantile_norm_data[1:21,k]
# load normalized data set#
# doing a for loop to go throuhg each row (miRNA) and subset viral, bacterial, baseline, asymptomatic/symptomatic miRNA expression#
allviral <- quantile_norm_data[k,1:21]#
baseline <- quantile_norm_data[k,22:42]#
bacterial <- quantile_norm_data[k,43:52]#
viral_symptomatic_vector <- c(1,2,5,9,11,13,15,16,17,18,19,20,21)#
viral_asymptomatic_vector <- c(3,4,6,7,8,10,12,14)#
viral_symptomatic <- quantile_norm_data[viral_symptomatic_vector]#
viral_asymptomatic <- quantile_norm_data[viral_asymptomatic_vector]#
combined_bacterial_baseline <- quantile_norm_data[k,22:52]#
combined_bacterial_allviral_vector <- c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,43,44,45,46,47,48,49,50,51,52)#
combined_bacterial_allviral <- quantile_norm_data[combined_bacterial_allviral_vector]#
combined_baseline_allviral <- quantile_norm_data[k,1:42]#
}
allviral <- quantile_norm_data[k,1:21]#
baseline <- quantile_norm_data[k,22:42]#
bacterial <- quantile_norm_data[k,43:52]#
viral_symptomatic_vector <- c(1,2,5,9,11,13,15,16,17,18,19,20,21)#
viral_asymptomatic_vector <- c(3,4,6,7,8,10,12,14)#
viral_symptomatic <- quantile_norm_data[viral_symptomatic_vector]#
viral_asymptomatic <- quantile_norm_data[viral_asymptomatic_vector]#
combined_bacterial_baseline <- quantile_norm_data[k,22:52]#
combined_bacterial_allviral_vector <- c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,43,44,45,46,47,48,49,50,51,52)#
combined_bacterial_allviral <- quantile_norm_data[combined_bacterial_allviral_vector]#
combined_baseline_allviral <- quantile_norm_data[k,1:42]
bacterial
for k in 1:nrow(quantile_norm_data) {#
allviral <- quantile_norm_data[k,1:21]#
baseline <- quantile_norm_data[k,22:42]#
bacterial <- quantile_norm_data[k,43:52]#
viral_symptomatic_vector <- c(1,2,5,9,11,13,15,16,17,18,19,20,21)#
viral_asymptomatic_vector <- c(3,4,6,7,8,10,12,14)#
viral_symptomatic <- quantile_norm_data[viral_symptomatic_vector]#
viral_asymptomatic <- quantile_norm_data[viral_asymptomatic_vector]#
combined_bacterial_baseline <- quantile_norm_data[k,22:52]#
combined_bacterial_allviral_vector <- c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,43,44,45,46,47,48,49,50,51,52)#
combined_bacterial_allviral <- quantile_norm_data[combined_bacterial_allviral_vector]#
combined_baseline_allviral <- quantile_norm_data[k,1:42]#
}
for (k in 1:nrow(quantile_norm_data)) {#
allviral <- quantile_norm_data[k,1:21]#
baseline <- quantile_norm_data[k,22:42]#
bacterial <- quantile_norm_data[k,43:52]#
viral_symptomatic_vector <- c(1,2,5,9,11,13,15,16,17,18,19,20,21)#
viral_asymptomatic_vector <- c(3,4,6,7,8,10,12,14)#
viral_symptomatic <- quantile_norm_data[viral_symptomatic_vector]#
viral_asymptomatic <- quantile_norm_data[viral_asymptomatic_vector]#
combined_bacterial_baseline <- quantile_norm_data[k,22:52]#
combined_bacterial_allviral_vector <- c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,43,44,45,46,47,48,49,50,51,52)#
combined_bacterial_allviral <- quantile_norm_data[combined_bacterial_allviral_vector]#
combined_baseline_allviral <- quantile_norm_data[k,1:42]#
}
for (k in 1:nrow(quantile_norm_data)) {#
print(k)#
allviral <- quantile_norm_data[k,1:21]#
baseline <- quantile_norm_data[k,22:42]#
bacterial <- quantile_norm_data[k,43:52]#
viral_symptomatic_vector <- c(1,2,5,9,11,13,15,16,17,18,19,20,21)#
viral_asymptomatic_vector <- c(3,4,6,7,8,10,12,14)#
viral_symptomatic <- quantile_norm_data[viral_symptomatic_vector]#
viral_asymptomatic <- quantile_norm_data[viral_asymptomatic_vector]#
combined_bacterial_baseline <- quantile_norm_data[k,22:52]#
combined_bacterial_allviral_vector <- c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,43,44,45,46,47,48,49,50,51,52)#
combined_bacterial_allviral <- quantile_norm_data[combined_bacterial_allviral_vector]#
combined_baseline_allviral <- quantile_norm_data[k,1:42]#
}
all viral
allviral
# load normalized data set using "Normalization" R script#
# subset viral, bacterial, baseline, asymptomatic/symptomatic miRNA expression#
allviral <- quantile_norm_data[,1:21]#
baseline <- quantile_norm_data[,22:42]#
bacterial <- quantile_norm_data[,43:52]#
viral_symptomatic_vector <- c(1,2,5,9,11,13,15,16,17,18,19,20,21)#
viral_asymptomatic_vector <- c(3,4,6,7,8,10,12,14)#
viral_symptomatic <- quantile_norm_data[viral_symptomatic_vector]#
viral_asymptomatic <- quantile_norm_data[viral_asymptomatic_vector]#
combined_bacterial_baseline <- quantile_norm_data[,22:52]#
combined_bacterial_allviral_vector <- c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,43,44,45,46,47,48,49,50,51,52)#
combined_bacterial_allviral <- quantile_norm_data[combined_bacterial_allviral_vector]#
combined_baseline_allviral <- quantile_norm_data[,1:42]#
#
# make an output matrix for the pvalues of all the tests#
ttestmatrix <- matrix(, ncol=11, nrow=333)#
# conducting a Welch Two Sample t-test on every variable (not assuming equal standard deviation) using a for loop#
for (k in 1:nrow(quantile_norm_data)) {#
test1 <- t.test(allviral[k,],bacterial[k,],alternative="two.sided")#
test2 <- t.test(allviral[k,],baseline[k,],alternative="two.sided", paired=TRUE)#
# test2 is a paired t-test #
test3 <- t.test(viral_symptomatic[k,], viral_asymptomatic[k,],alternative="two.sided")#
test4 <- t.test(bacterial[k,],baseline[k,],alternative="two.sided")#
test5 <- t.test(bacterial[k,],viral_symptomatic[k,],alternative="two.sided")#
test6 <- t.test(bacterial[k,],viral_asymptomatic[k,],alternative="two.sided")#
test7 <- t.test(baseline[k,], viral_symptomatic[k,], alternative="two.sided")#
test8 <- t.test(baseline[k,], viral_asymptomatic[k,], alternative="two.sided")#
test9 <- t.test(combined_bacterial_baseline[k,],allviral[k,],alternative="two.sided")#
test10 <- t.test(combined_bacterial_allviral[k,],baseline[k,],alternative="two.sided")#
test11 <- t.test(combined_baseline_allviral[k,],bacterial[k,],alternative="two.sided")#
ttestmatrix[k,]#
print(ttestmatrix)#
}
# make an output matrix for the pvalues of all the tests#
ttestmatrix <- matrix(, ncol=11, nrow=333)#
#make an output vector for pvalues of all tests#
output_vector <- vector()#
#assign a test vector#
test_vector <- c(test1, test2, test3, test4, test5, test6, test7, test8, test9, test10, test11)#
# conducting a Welch Two Sample t-test on every variable (not assuming equal standard deviation) using a for loop#
for (k in 1:nrow(quantile_norm_data)) {#
test1 <- t.test(allviral[k,],bacterial[k,],alternative="two.sided")#
test2 <- t.test(allviral[k,],baseline[k,],alternative="two.sided", paired=TRUE)#
# test2 is a paired t-test #
test3 <- t.test(viral_symptomatic, viral_asymptomatic,alternative="two.sided")#
test4 <- t.test(bacterial[k,],baseline[k,],alternative="two.sided")#
test5 <- t.test(bacterial[k,],viral_symptomatic[k,],alternative="two.sided")#
test6 <- t.test(bacterial[k,],viral_asymptomatic[k,],alternative="two.sided")#
test7 <- t.test(baseline[k,], viral_symptomatic[k,], alternative="two.sided")#
test8 <- t.test(baseline[k,], viral_asymptomatic[k,], alternative="two.sided")#
test9 <- t.test(combined_bacterial_baseline[k,],allviral[k,],alternative="two.sided")#
test10 <- t.test(combined_bacterial_allviral[k,],baseline[k,],alternative="two.sided")#
test11 <- t.test(combined_baseline_allviral[k,],bacterial[k,],alternative="two.sided")#
#
output_vector[k] <- (test_vector)#
print(ttestmatrix[output_vector])#
}
# subset viral, bacterial, baseline, asymptomatic/symptomatic miRNA expression#
allviral <- quantile_norm_data[,1:21]#
baseline <- quantile_norm_data[,22:42]#
bacterial <- quantile_norm_data[,43:52]#
viral_symptomatic <- quantile_norm_data[,c(1,2,5,9,11,13,15,16,17,18,19,20,21)]#
viral_asymptomatic <- quantile_norm_data[,c(3,4,6,7,8,10,12,14)]#
combined_bacterial_baseline <- quantile_norm_data[,22:52]#
combined_bacterial_allviral <- quantile_norm_data[,c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,43,44,45,46,47,48,49,50,51,52)]#
combined_baseline_allviral <- quantile_norm_data[,1:42]
# subset viral, bacterial, baseline, asymptomatic/symptomatic miRNA expression#
allviral <- quantile_norm_data[,1:21]#
baseline <- quantile_norm_data[,22:42]#
bacterial <- quantile_norm_data[,43:52]#
viral_symptomatic <- quantile_norm_data[,c(1,2,5,9,11,13,15,16,17,18,19,20,21)]#
viral_asymptomatic <- quantile_norm_data[,c(3,4,6,7,8,10,12,14)]#
combined_bacterial_baseline <- quantile_norm_data[,22:52]#
combined_bacterial_allviral <- quantile_norm_data[,c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,43,44,45,46,47,48,49,50,51,52)]#
combined_baseline_allviral <- quantile_norm_data[,1:42]#
#
# make an output matrix for the pvalues of all the tests#
ttestmatrix <- matrix(, ncol=11, nrow=333)#
#make an output vector for pvalues of all tests#
output_vector <- vector()#
#assign a test vector#
test_vector <- c(test1, test2, test3, test4, test5, test6, test7, test8, test9, test10, test11)#
# conducting a Welch Two Sample t-test on every variable (not assuming equal standard deviation) using a for loop#
for (k in 1:nrow(quantile_norm_data)) {#
test1 <- t.test(allviral[k,],bacterial[k,],alternative="two.sided")#
test2 <- t.test(allviral[k,],baseline[k,],alternative="two.sided", paired=TRUE)#
# test2 is a paired t-test #
test3 <- t.test(viral_symptomatic, viral_asymptomatic,alternative="two.sided")#
test4 <- t.test(bacterial[k,],baseline[k,],alternative="two.sided")#
test5 <- t.test(bacterial[k,],viral_symptomatic[k,],alternative="two.sided")#
test6 <- t.test(bacterial[k,],viral_asymptomatic[k,],alternative="two.sided")#
test7 <- t.test(baseline[k,], viral_symptomatic[k,], alternative="two.sided")#
test8 <- t.test(baseline[k,], viral_asymptomatic[k,], alternative="two.sided")#
test9 <- t.test(combined_bacterial_baseline[k,],allviral[k,],alternative="two.sided")#
test10 <- t.test(combined_bacterial_allviral[k,],baseline[k,],alternative="two.sided")#
test11 <- t.test(combined_baseline_allviral[k,],bacterial[k,],alternative="two.sided")#
#
output_vector[k] <- (test_vector)#
print(ttestmatrix[output_vector])#
}
# conducting a Welch Two Sample t-test on every variable (not assuming equal standard deviation) using a for loop#
for (k in 1:nrow(quantile_norm_data)) {#
test1 <- t.test(allviral[k,],bacterial[k,],alternative="two.sided")#
test2 <- t.test(allviral[k,],baseline[k,],alternative="two.sided", paired=TRUE)#
# test2 is a paired t-test #
test3 <- t.test(viral_symptomatic, viral_asymptomatic,alternative="two.sided")#
test4 <- t.test(bacterial[k,],baseline[k,],alternative="two.sided")#
test5 <- t.test(bacterial[k,],viral_symptomatic[k,],alternative="two.sided")#
test6 <- t.test(bacterial[k,],viral_asymptomatic[k,],alternative="two.sided")#
test7 <- t.test(baseline[k,], viral_symptomatic[k,], alternative="two.sided")#
test8 <- t.test(baseline[k,], viral_asymptomatic[k,], alternative="two.sided")#
test9 <- t.test(combined_bacterial_baseline[k,],allviral[k,],alternative="two.sided")#
test10 <- t.test(combined_bacterial_allviral[k,],baseline[k,],alternative="two.sided")#
test11 <- t.test(combined_baseline_allviral[k,],bacterial[k,],alternative="two.sided")#
print(ttestmatrix)#
}
?paste0
?cat
# conducting a Welch Two Sample t-test on every variable (not assuming equal standard deviation) using a for loop#
for (k in 1:nrow(quantile_norm_data)) {#
test1 <- t.test(allviral[k,],bacterial[k,],alternative="two.sided")#
test2 <- t.test(allviral[k,],baseline[k,],alternative="two.sided", paired=TRUE)#
# test2 is a paired t-test #
test3 <- t.test(viral_symptomatic, viral_asymptomatic,alternative="two.sided")#
test4 <- t.test(bacterial[k,],baseline[k,],alternative="two.sided")#
test5 <- t.test(bacterial[k,],viral_symptomatic[k,],alternative="two.sided")#
test6 <- t.test(bacterial[k,],viral_asymptomatic[k,],alternative="two.sided")#
test7 <- t.test(baseline[k,], viral_symptomatic[k,], alternative="two.sided")#
test8 <- t.test(baseline[k,], viral_asymptomatic[k,], alternative="two.sided")#
test9 <- t.test(combined_bacterial_baseline[k,],allviral[k,],alternative="two.sided")#
test10 <- t.test(combined_bacterial_allviral[k,],baseline[k,],alternative="two.sided")#
test11 <- t.test(combined_baseline_allviral[k,],bacterial[k,],alternative="two.sided")#
#
output_vector[k] <- (test_vector)#
ttestmatrix[k,] <- output_vector#
}
# load normalized data set using "Normalization" R script#
# subset viral, bacterial, baseline, asymptomatic/symptomatic miRNA expression#
allviral <- quantile_norm_data[,1:21]#
baseline <- quantile_norm_data[,22:42]#
bacterial <- quantile_norm_data[,43:52]#
viral_symptomatic <- quantile_norm_data[,c(1,2,5,9,11,13,15,16,17,18,19,20,21)]#
viral_asymptomatic <- quantile_norm_data[,c(3,4,6,7,8,10,12,14)]#
combined_bacterial_baseline <- quantile_norm_data[,22:52]#
combined_bacterial_allviral <- quantile_norm_data[,c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,43,44,45,46,47,48,49,50,51,52)]#
combined_baseline_allviral <- quantile_norm_data[,1:42]#
#
# make an output matrix for the pvalues of all the tests#
ttestmatrix <- matrix(, ncol=11, nrow=333)#
#assign a test vector#
test_vector <- c(test1, test2, test3, test4, test5, test6, test7, test8, test9, test10, test11)#
# conducting a Welch Two Sample t-test on every variable (not assuming equal standard deviation) using a for loop#
for (k in 1:nrow(quantile_norm_data)) {#
output_vector <- vector()#
output_vector[1] <- t.test(allviral[k,],bacterial[k,],alternative="two.sided")#
output_vector[2] <- t.test(allviral[k,],baseline[k,],alternative="two.sided", paired=TRUE)#
# test2 is a paired t-test #
output_vector[3] <- t.test(viral_symptomatic, viral_asymptomatic,alternative="two.sided")#
output_vector[4] <- t.test(bacterial[k,],baseline[k,],alternative="two.sided")#
output_vector[5] <- t.test(bacterial[k,],viral_symptomatic[k,],alternative="two.sided")#
output_vector[6] <- t.test(bacterial[k,],viral_asymptomatic[k,],alternative="two.sided")#
output_vector[7] <- t.test(baseline[k,], viral_symptomatic[k,], alternative="two.sided")#
output_vector[8] <- t.test(baseline[k,], viral_asymptomatic[k,], alternative="two.sided")#
output_vector[9] <- t.test(combined_bacterial_baseline[k,],allviral[k,],alternative="two.sided")#
output_vector[10] <- t.test(combined_bacterial_allviral[k,],baseline[k,],alternative="two.sided")#
output_vector[11] <- t.test(combined_baseline_allviral[k,],bacterial[k,],alternative="two.sided")#
#
ttestmatrix[k,] <- output_vector#
}#
print(ttestmatrix)
# load normalized data set using "Normalization" R script#
# subset viral, bacterial, baseline, asymptomatic/symptomatic miRNA expression#
allviral <- quantile_norm_data[,1:21]#
baseline <- quantile_norm_data[,22:42]#
bacterial <- quantile_norm_data[,43:52]#
viral_symptomatic <- quantile_norm_data[,c(1,2,5,9,11,13,15,16,17,18,19,20,21)]#
viral_asymptomatic <- quantile_norm_data[,c(3,4,6,7,8,10,12,14)]#
combined_bacterial_baseline <- quantile_norm_data[,22:52]#
combined_bacterial_allviral <- quantile_norm_data[,c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,43,44,45,46,47,48,49,50,51,52)]#
combined_baseline_allviral <- quantile_norm_data[,1:42]#
# conducting a Welch Two Sample t-test on every variable (not assuming equal standard deviation) using a for loop#
for (k in 1:nrow(quantile_norm_data)) {#
output_vector <- vector()#
# make an output matrix for the pvalues of all the tests#
ttestmatrix <- matrix(, ncol=j, nrow=i)#
output_vector[1] <- t.test(allviral[k,],bacterial[k,],alternative="two.sided")#
output_vector[2] <- t.test(allviral[k,],baseline[k,],alternative="two.sided", paired=TRUE)#
# test2 is a paired t-test #
output_vector[3] <- t.test(viral_symptomatic, viral_asymptomatic,alternative="two.sided")#
output_vector[4] <- t.test(bacterial[k,],baseline[k,],alternative="two.sided")#
output_vector[5] <- t.test(bacterial[k,],viral_symptomatic[k,],alternative="two.sided")#
output_vector[6] <- t.test(bacterial[k,],viral_asymptomatic[k,],alternative="two.sided")#
output_vector[7] <- t.test(baseline[k,], viral_symptomatic[k,], alternative="two.sided")#
output_vector[8] <- t.test(baseline[k,], viral_asymptomatic[k,], alternative="two.sided")#
output_vector[9] <- t.test(combined_bacterial_baseline[k,],allviral[k,],alternative="two.sided")#
output_vector[10] <- t.test(combined_bacterial_allviral[k,],baseline[k,],alternative="two.sided")#
output_vector[11] <- t.test(combined_baseline_allviral[k,],bacterial[k,],alternative="two.sided")#
#
ttestmatrix[k,] <- output_vector#
}#
print(ttestmatrix)
# load normalized data set using "Normalization" R script#
# subset viral, bacterial, baseline, asymptomatic/symptomatic miRNA expression#
allviral <- quantile_norm_data[,1:21]#
baseline <- quantile_norm_data[,22:42]#
bacterial <- quantile_norm_data[,43:52]#
viral_symptomatic <- quantile_norm_data[,c(1,2,5,9,11,13,15,16,17,18,19,20,21)]#
viral_asymptomatic <- quantile_norm_data[,c(3,4,6,7,8,10,12,14)]#
combined_bacterial_baseline <- quantile_norm_data[,22:52]#
combined_bacterial_allviral <- quantile_norm_data[,c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,43,44,45,46,47,48,49,50,51,52)]#
combined_baseline_allviral <- quantile_norm_data[,1:42]#
# conducting a Welch Two Sample t-test on every variable (not assuming equal standard deviation) using a for loop#
for (k in 1:nrow(quantile_norm_data)) {#
output_vector <- vector()#
# make an output matrix for the pvalues of all the tests#
ttestmatrix <- matrix(, ncol=j, nrow=i)#
output_vector[1] <- t.test(allviral[k,],bacterial[k,],alternative="two.sided")#
output_vector[2] <- t.test(allviral[k,],baseline[k,],alternative="two.sided", paired=TRUE)#
# test2 is a paired t-test #
output_vector[3] <- t.test(viral_symptomatic, viral_asymptomatic,alternative="two.sided")#
output_vector[4] <- t.test(bacterial[k,],baseline[k,],alternative="two.sided")#
output_vector[5] <- t.test(bacterial[k,],viral_symptomatic[k,],alternative="two.sided")#
output_vector[6] <- t.test(bacterial[k,],viral_asymptomatic[k,],alternative="two.sided")#
output_vector[7] <- t.test(baseline[k,], viral_symptomatic[k,], alternative="two.sided")#
output_vector[8] <- t.test(baseline[k,], viral_asymptomatic[k,], alternative="two.sided")#
output_vector[9] <- t.test(combined_bacterial_baseline[k,],allviral[k,],alternative="two.sided")#
output_vector[10] <- t.test(combined_bacterial_allviral[k,],baseline[k,],alternative="two.sided")#
output_vector[11] <- t.test(combined_baseline_allviral[k,],bacterial[k,],alternative="two.sided")#
#
ttestmatrix[k,] <- output_vector#
}
# conducting a Welch Two Sample t-test on every variable (not assuming equal standard deviation) using a for loop#
for (k in 1:nrow(quantile_norm_data)) {#
output_vector <- vector()#
# make an output matrix for the pvalues of all the tests#
ttestmatrix <- matrix(, ncol=11, nrow=i)#
output_vector[1] <- t.test(allviral[k,],bacterial[k,],alternative="two.sided")#
output_vector[2] <- t.test(allviral[k,],baseline[k,],alternative="two.sided", paired=TRUE)#
# test2 is a paired t-test #
output_vector[3] <- t.test(viral_symptomatic, viral_asymptomatic,alternative="two.sided")#
output_vector[4] <- t.test(bacterial[k,],baseline[k,],alternative="two.sided")#
output_vector[5] <- t.test(bacterial[k,],viral_symptomatic[k,],alternative="two.sided")#
output_vector[6] <- t.test(bacterial[k,],viral_asymptomatic[k,],alternative="two.sided")#
output_vector[7] <- t.test(baseline[k,], viral_symptomatic[k,], alternative="two.sided")#
output_vector[8] <- t.test(baseline[k,], viral_asymptomatic[k,], alternative="two.sided")#
output_vector[9] <- t.test(combined_bacterial_baseline[k,],allviral[k,],alternative="two.sided")#
output_vector[10] <- t.test(combined_bacterial_allviral[k,],baseline[k,],alternative="two.sided")#
output_vector[11] <- t.test(combined_baseline_allviral[k,],bacterial[k,],alternative="two.sided")#
#
ttestmatrix[k,] <- output_vector#
}
# conducting a Welch Two Sample t-test on every variable (not assuming equal standard deviation) using a for loop#
for (k in 1:nrow(quantile_norm_data)) {#
output_vector <- vector()#
# make an output matrix for the pvalues of all the tests#
ttestmatrix <- matrix(, ncol=11, nrow=333)#
output_vector[1] <- t.test(allviral[k,],bacterial[k,],alternative="two.sided")#
output_vector[2] <- t.test(allviral[k,],baseline[k,],alternative="two.sided", paired=TRUE)#
# test2 is a paired t-test #
output_vector[3] <- t.test(viral_symptomatic, viral_asymptomatic,alternative="two.sided")#
output_vector[4] <- t.test(bacterial[k,],baseline[k,],alternative="two.sided")#
output_vector[5] <- t.test(bacterial[k,],viral_symptomatic[k,],alternative="two.sided")#
output_vector[6] <- t.test(bacterial[k,],viral_asymptomatic[k,],alternative="two.sided")#
output_vector[7] <- t.test(baseline[k,], viral_symptomatic[k,], alternative="two.sided")#
output_vector[8] <- t.test(baseline[k,], viral_asymptomatic[k,], alternative="two.sided")#
output_vector[9] <- t.test(combined_bacterial_baseline[k,],allviral[k,],alternative="two.sided")#
output_vector[10] <- t.test(combined_bacterial_allviral[k,],baseline[k,],alternative="two.sided")#
output_vector[11] <- t.test(combined_baseline_allviral[k,],bacterial[k,],alternative="two.sided")#
#
ttestmatrix[k,] <- output_vector#
}
# conducting a Welch Two Sample t-test on every variable (not assuming equal standard deviation) using a for loop#
for (k in 1:nrow(quantile_norm_data)) {#
output_vector <- vector()#
# make an output matrix for the pvalues of all the tests#
ttestmatrix <- matrix(, ncol=j, nrow=i)#
output_vector[1] <- t.test(allviral[k,],bacterial[k,],alternative="two.sided")#
output_vector[2] <- t.test(allviral[k,],baseline[k,],alternative="two.sided", paired=TRUE)#
# test2 is a paired t-test #
output_vector[3] <- t.test(viral_symptomatic, viral_asymptomatic,alternative="two.sided")#
output_vector[4] <- t.test(bacterial[k,],baseline[k,],alternative="two.sided")#
output_vector[5] <- t.test(bacterial[k,],viral_symptomatic[k,],alternative="two.sided")#
output_vector[6] <- t.test(bacterial[k,],viral_asymptomatic[k,],alternative="two.sided")#
output_vector[7] <- t.test(baseline[k,], viral_symptomatic[k,], alternative="two.sided")#
output_vector[8] <- t.test(baseline[k,], viral_asymptomatic[k,], alternative="two.sided")#
output_vector[9] <- t.test(combined_bacterial_baseline[k,],allviral[k,],alternative="two.sided")#
output_vector[10] <- t.test(combined_bacterial_allviral[k,],baseline[k,],alternative="two.sided")#
output_vector[11] <- t.test(combined_baseline_allviral[k,],bacterial[k,],alternative="two.sided")#
#
ttestmatrix[k,] <- output_vector#
}
print(ttestmatrix)
output_vector[9]
library(igraph)
?infomap
?infomap.community
setwd("~/Desktop/edgelists")
# old network#
cdata = read.csv("e_cermi.csv", header = F)#
 cdata=as.matrix(cdata)#
 g=graph.edgelist(cdata[,1:2],directed=TRUE)#
 E(g)$weight=as.numeric(cdata[,3])#
cdata_matrix <- get.adjacency(g,attr='weight',sparse=FALSE)
cdata
#infomap#
infomap.community(g, e.weights=cdata[,3], nb.trials = 10, modularity = TRUE)
print(communities)
print(g)
length(g)
print(g)
length(communities)
create.communities(membership)
create.communities(g)
info <- infomap.community(g, e.weights=cdata[,3], nb.trials = 10, modularity = TRUE)
create.communities(info)
print(info)
print(length)
modularity(info)
is.hierarchial(info)
is.hierarchical(info)
plot(info)
create.communities(info)
ebc <- edge.betweenness.community(g, directed=F)#
 mods <- sapply(0:ecount(g), function(i){#
   g2 <- delete.edges(g, ebc$removed.edges[seq(length=i)])#
   cl <- clusters(g2)$membership#
 modularity(g,cl)#
 })
modularity(g,cl)
mods <- sapply(0:ecount(g)
}
g2 <- delete.edges(g, ebc$removed.edges[seq(length=i)])  cl <- clusters(g2)$membership
g2 <- delete.edges(g, ebc$removed.edges[seq(length=i)])
cl <- clusters(g2)$membership
modularity(g, cl)
>>>>>>> origin/master
setwd("~/Desktop/Data+/miRNA_dataPlus")
# load normalized data#
# loading quantile_norm_data#
load("R_Data/saved_quantile_norm_data")#
#
# subset viral, bacterial, baseline, asymptomatic/symptomatic miRNA expression#
allviral <- quantile_norm_data[,1:21]#
baseline <- quantile_norm_data[,22:42]#
bacterial <- quantile_norm_data[,43:52]#
viral_symptomatic <- quantile_norm_data[,c(1,2,5,9,11,13,15,16,17,18,19,20,21)]#
viral_asymptomatic <- quantile_norm_data[,c(3,4,6,7,8,10,12,14)]#
combined_bacterial_baseline <- quantile_norm_data[,22:52]#
combined_bacterial_allviral <- quantile_norm_data[,c(1:21,43:52)]#
combined_baseline_allviral <- quantile_norm_data[,1:42]#
#
# t-test function#
do_t_test <- function(s1, s2, is_paired) {#
	result <- t.test(s1, s2, alternative="two.sided", paired=is_paired)#
	return(result$p.value)#
}#
#
# make an output matrix for the pvalues of all the tests#
p_vals <- matrix(, nrow=nrow(quantile_norm_data), ncol=11)#
#
# conducting a Welch Two Sample t-test on every variable (not assuming equal standard deviation) using a for loop#
for (k in 1:nrow(quantile_norm_data)) {#
	output_vector <- vector(length=11)#
	output_vector[1] <- do_t_test(allviral[k,], bacterial[k,], FALSE)#
	output_vector[2] <- do_t_test(allviral[k,], baseline[k,], TRUE)#
	output_vector[3] <- do_t_test(viral_symptomatic[k,], viral_asymptomatic[k,], FALSE)#
	output_vector[4] <- do_t_test(bacterial[k,], baseline[k,], FALSE)#
	output_vector[5] <- do_t_test(bacterial[k,], viral_symptomatic[k,], FALSE)#
	output_vector[6] <- do_t_test(bacterial[k,], viral_asymptomatic[k,], FALSE)#
	output_vector[7] <- do_t_test(baseline[k,], viral_symptomatic[k,], FALSE)#
	output_vector[8] <- do_t_test(baseline[k,], viral_asymptomatic[k,], FALSE)#
	output_vector[9] <- do_t_test(combined_bacterial_baseline[k,], allviral[k,], FALSE)#
	output_vector[10] <- do_t_test(combined_bacterial_allviral[k,], baseline[k,], FALSE)#
	output_vector[11] <- do_t_test(combined_baseline_allviral[k,], bacterial[k,], FALSE)#
	p_vals[k,] <- output_vector#
}#
#
# save p_vals matrix#
save(p_vals, file="R_Data/saved_p_vals")
# loading quantile_norm_data#
load("R_Data/saved_quantile_norm_data.R")
# Retrieve Data#
# processed_data retreived#
load("R_Data/saved_raw_data")#
#
# UQ normalization function#
UQNorm <- function(v) {#
    nonzero_data <- subset(v, v > 0)#
    quartiles <- quantile(nonzero_data)#
    uq <- quartiles[4]#
    return(uq)#
} #
#
# vector of Us needed to normalize data#
Us <- apply(raw_data, 2, UQNorm)#
#
# finding mean of the of the uq samples#
U <- mean(Us)#
#
# load processed data#
load("R_Data/saved_processed_data")#
#
uqnorm <- matrix(, nrow=nrow(processed_data), ncol=ncol(processed_data))#
#
# doing a for loop to normalize on each sample#
for (i in 1:ncol(processed_data)) {#
	colneeded <- processed_data[,i]#
	uqnorm[,i] <- colneeded/Us[i]*U#
}#
#
#create a function to normalize data#
#order the data set according to rank#
quantile_normalize <- function(v) {#
	v_order <- rank(v,ties.method="average")#
	#set the quantiles based on the order#
	quantiles <- v_order/53#
	quantile_norm_vec <- qnorm(quantiles,mean=0,sd=1)#
	return(quantile_norm_vec)	#
}#
#
output_matrix <- matrix(, nrow=m, ncol=n)#
# create quantile normalization function for each miRNA#
quantile_norm_data <- apply(uqnorm, 1, quantile_normalize)#
quantile_norm_data <- t(quantile_norm_data)#
str(quantile_norm_data)#
#
# save final normalized data#
save(quantile_norm_data, file="R_Data/saved_quantile_norm_data")
load("/Users/kelseysumner/Desktop/Data+/miRNA_dataPlus/Data/R_Data-selected/saved_processed_data.r")
# load normalized data#
# loading quantile_norm_data#
load("R_Data/saved_quantile_norm_data")#
#
# subset viral, bacterial, baseline, asymptomatic/symptomatic miRNA expression#
allviral <- quantile_norm_data[,1:21]#
baseline <- quantile_norm_data[,22:42]#
bacterial <- quantile_norm_data[,43:52]#
viral_symptomatic <- quantile_norm_data[,c(1,2,5,9,11,13,15,16,17,18,19,20,21)]#
viral_asymptomatic <- quantile_norm_data[,c(3,4,6,7,8,10,12,14)]#
combined_bacterial_baseline <- quantile_norm_data[,22:52]#
combined_bacterial_allviral <- quantile_norm_data[,c(1:21,43:52)]#
combined_baseline_allviral <- quantile_norm_data[,1:42]#
#
# t-test function#
do_t_test <- function(s1, s2, is_paired) {#
	result <- t.test(s1, s2, alternative="two.sided", paired=is_paired)#
	return(result$p.value)#
}#
#
# make an output matrix for the pvalues of all the tests#
p_vals <- matrix(, nrow=nrow(quantile_norm_data), ncol=11)#
#
# conducting a Welch Two Sample t-test on every variable (not assuming equal standard deviation) using a for loop#
for (k in 1:nrow(quantile_norm_data)) {#
	output_vector <- vector(length=11)#
	output_vector[1] <- do_t_test(allviral[k,], bacterial[k,], FALSE)#
	output_vector[2] <- do_t_test(allviral[k,], baseline[k,], TRUE)#
	output_vector[3] <- do_t_test(viral_symptomatic[k,], viral_asymptomatic[k,], FALSE)#
	output_vector[4] <- do_t_test(bacterial[k,], baseline[k,], FALSE)#
	output_vector[5] <- do_t_test(bacterial[k,], viral_symptomatic[k,], FALSE)#
	output_vector[6] <- do_t_test(bacterial[k,], viral_asymptomatic[k,], FALSE)#
	output_vector[7] <- do_t_test(baseline[k,], viral_symptomatic[k,], FALSE)#
	output_vector[8] <- do_t_test(baseline[k,], viral_asymptomatic[k,], FALSE)#
	output_vector[9] <- do_t_test(combined_bacterial_baseline[k,], allviral[k,], FALSE)#
	output_vector[10] <- do_t_test(combined_bacterial_allviral[k,], baseline[k,], FALSE)#
	output_vector[11] <- do_t_test(combined_baseline_allviral[k,], bacterial[k,], FALSE)#
	p_vals[k,] <- output_vector#
}#
#
# save p_vals matrix#
save(p_vals, file="R_Data/saved_p_vals")
# load normalized data#
# loading quantile_norm_data#
load("Data/saved_quantile_norm_data")#
#
# subset viral, bacterial, baseline, asymptomatic/symptomatic miRNA expression#
allviral <- quantile_norm_data[,1:21]#
baseline <- quantile_norm_data[,22:42]#
bacterial <- quantile_norm_data[,43:52]#
viral_symptomatic <- quantile_norm_data[,c(1,2,5,9,11,13,15,16,17,18,19,20,21)]#
viral_asymptomatic <- quantile_norm_data[,c(3,4,6,7,8,10,12,14)]#
combined_bacterial_baseline <- quantile_norm_data[,22:52]#
combined_bacterial_allviral <- quantile_norm_data[,c(1:21,43:52)]#
combined_baseline_allviral <- quantile_norm_data[,1:42]#
#
# t-test function#
do_t_test <- function(s1, s2, is_paired) {#
	result <- t.test(s1, s2, alternative="two.sided", paired=is_paired)#
	return(result$p.value)#
}#
#
# make an output matrix for the pvalues of all the tests#
p_vals <- matrix(, nrow=nrow(quantile_norm_data), ncol=11)#
#
# conducting a Welch Two Sample t-test on every variable (not assuming equal standard deviation) using a for loop#
for (k in 1:nrow(quantile_norm_data)) {#
	output_vector <- vector(length=11)#
	output_vector[1] <- do_t_test(allviral[k,], bacterial[k,], FALSE)#
	output_vector[2] <- do_t_test(allviral[k,], baseline[k,], TRUE)#
	output_vector[3] <- do_t_test(viral_symptomatic[k,], viral_asymptomatic[k,], FALSE)#
	output_vector[4] <- do_t_test(bacterial[k,], baseline[k,], FALSE)#
	output_vector[5] <- do_t_test(bacterial[k,], viral_symptomatic[k,], FALSE)#
	output_vector[6] <- do_t_test(bacterial[k,], viral_asymptomatic[k,], FALSE)#
	output_vector[7] <- do_t_test(baseline[k,], viral_symptomatic[k,], FALSE)#
	output_vector[8] <- do_t_test(baseline[k,], viral_asymptomatic[k,], FALSE)#
	output_vector[9] <- do_t_test(combined_bacterial_baseline[k,], allviral[k,], FALSE)#
	output_vector[10] <- do_t_test(combined_bacterial_allviral[k,], baseline[k,], FALSE)#
	output_vector[11] <- do_t_test(combined_baseline_allviral[k,], bacterial[k,], FALSE)#
	p_vals[k,] <- output_vector#
}#
#
# save p_vals matrix#
save(p_vals, file="Data/saved_p_vals")
# Retrieve Data#
# processed_data retreived#
load("Data/saved_raw_data")
pvals
setwd(~/Box Sync/Sharing/Data_Plus/R_Data)
setwd(~Box Sync/Sharing/Data_Plus/R_Data)
setwd(~/Box Sync/Sharing/Data_Plus)
load("/Users/kelseysumner/Box Sync/Sharing/Data_Plus/R_Data/saved_raw_data.r")
load("/Users/kelseysumner/Box Sync/Sharing/Data_Plus/R_Data/saved_p_vals.r")
p_vals
fdr_vector_test1 <- c(p_vals[,1])#
fdr_vector_test2 <- c(p_vals[,2])#
fdr_vector_test3 <- c(p_vals[,3])#
fdr_vector_test4 <- c(p_vals[,4])#
fdr_vector_test5 <- c(p_vals[,5])#
fdr_vector_test6 <- c(p_vals[,6])#
fdr_vector_test7 <- c(p_vals[,7])#
fdr_vector_test8 <- c(p_vals[,8])#
fdr_vector_test9 <- c(p_vals[,9])#
fdr_vector_test10 <- c(p_vals[,10])#
fdr_vector_test11 <- c(p_vals[,11])
fdr_adjustment1 <- p.adjust(fdr_vector_test1, method = "fdr")#
fdr_adjustment2 <- p.adjust(fdr_vector_test2, method = "fdr")#
fdr_adjustment3 <- p.adjust(fdr_vector_test3, method = "fdr")#
fdr_adjustment4 <- p.adjust(fdr_vector_test4, method = "fdr")#
fdr_adjustment5 <- p.adjust(fdr_vector_test5, method = "fdr")#
fdr_adjustment6 <- p.adjust(fdr_vector_test6, method = "fdr")#
fdr_adjustment7 <- p.adjust(fdr_vector_test7, method = "fdr")#
fdr_adjustment8 <- p.adjust(fdr_vector_test8, method = "fdr")#
fdr_adjustment9 <- p.adjust(fdr_vector_test9, method = "fdr")#
fdr_adjustment10 <- p.adjust(fdr_vector_test10, method = "fdr")#
fdr_adjustment11 <- p.adjust(fdr_vector_test11, method = "fdr")#
fdr_combined <- c(fdr_adjustment1, fdr_adjustment2, fdr_adjustment3, fdr_adjustment4, fdr_adjustment5, fdr_adjustment6, fdr_adjustment7, fdr_adjustment8, fdr_adjustment9, fdr_adjustment10, fdr_adjustment11)#
fdr_matrix <- matrix(fdr_combined, nrow=333, ncol=11)
fdr_matrix
b_vector_test1 <- c(p_vals[,1])#
b_vector_test2 <- c(p_vals[,2])#
b_vector_test3 <- c(p_vals[,3])#
b_vector_test4 <- c(p_vals[,4])#
b_vector_test5 <- c(p_vals[,5])#
b_vector_test6 <- c(p_vals[,6])#
b_vector_test7 <- c(p_vals[,7])#
b_vector_test8 <- c(p_vals[,8])#
b_vector_test9 <- c(p_vals[,9])#
b_vector_test10 <- c(p_vals[,10])#
b_vector_test11 <- c(p_vals[,11])#
b_adjustment1 <- p.adjust(b_vector_test1, method = "bonferroni")#
b_adjustment2 <- p.adjust(b_vector_test2, method = "bonferroni")#
b_adjustment3 <- p.adjust(b_vector_test3, method = "bonferroni")#
b_adjustment4 <- p.adjust(b_vector_test4, method = "bonferroni")#
b_adjustment5 <- p.adjust(b_vector_test5, method = "bonferroni")#
b_adjustment6 <- p.adjust(b_vector_test6, method = "bonferroni")#
b_adjustment7 <- p.adjust(b_vector_test7, method = "bonferroni")#
b_adjustment8 <- p.adjust(b_vector_test8, method = "bonferroni")#
b_adjustment9 <- p.adjust(b_vector_test9, method = "bonferroni")#
b_adjustment10 <- p.adjust(b_vector_test10, method = "bonferroni")#
b_adjustment11 <- p.adjust(b_vector_test11, method = "bonferroni")#
b_combined <- c(b_adjustment1, b_adjustment2, b_adjustment3, b_adjustment4, b_adjustment5, b_adjustment6, b_adjustment7, b_adjustment8, b_adjustment9, b_adjustment10, b_adjustment11)#
b_matrix <- matrix(b_combined, nrow=333, ncol=11)
b_matrix
<<<<<<< HEAD
significant_b_p_vals <- b_matrix <= .05
significant_b_p_vals
significant_fdr_p_vals <- fdr_matrix <= .05
signifiant_fdr_p_vals
significant_fdr_p_vals
b_matrix
significant_b_p_vals <- b_matrix <= .05
significant_b_p_vals
subset(significant_b_p_vals, subset=TRUE)
significant_b_p_vals[TRUE]
significant_b_p_vals(FALSE, drop = TRUE)
significant_b_p_vals <- b_matrix <= .05
significant_b_p_vals(FALSE, drop = TRUE)
?subset
subset(significant_b_p_vals, FALSE, drop = TRUE)
subset(significant_b_p_vals, TRUE, drop = TRUE)
apply(significant_b_p_vals, 2, subset(significant_b_p_vals, FALSE, drop = TRUE))
?which
apply(significant_b_p_vals, 2, significant_b_p_vals[TRUE])
significant_b_p_vals[TRUE]
takeout <- x==TRUE
takeout <- significant_b_p_vals==TRUE
takeout
takingout <- function(significant_b_p_vals) {#
	takeout <- significant_b_p_vals==TRUE#
	return(takeout)#
}
apply(significant_b_p_vals, 2, takingout)
takeout <- c(significant_b_p_vals==FALSE)
takeout
takingout <- function(significant_b_p_vals) {#
#
	takeout <- which(significant_b_p_vals == TRUE)#
	return(takeout)#
}
apply(significant_b_p_vals, 2, takingout)
takingout <- function(significant_b_p_vals) {#
	takeout <- which(significant_b_p_vals == TRUE)#
	return(takeout)#
}
apply(significant_b_p_vals, 2, takingout)
?hclust
clustergram <- hclust(dist(b_matrix))
clustergram
plot(clustergram)
clustergram <- hclust(dist(b_matrix), "ave")
plot(clustergram)
clustergram <- hclust(dist(b_matrix), "complete")
plot(clustergram)
clustergram <- hclust(dist(b_matrix), "complete")#
plot(clustergram)
load("/Users/kelseysumner/Box Sync/Sharing/Data_Plus/R_Data/saved_raw_data.r")
saved_raw_data
raw_data
processed_data
head(processed_data)
str(processed_data)
?wilcoxin
=======
>>>>>>> Stashed changes
# Load the following...#
# sample_factors#
# quantile_norm_data#
#
# For reference, factors are#
# Viral Symptomatic - v_s#
# Viral Asymptomatic - v_as#
# Baseline - bl#
# Bacteria - bc#
#
# Load permtest package#
library(permtest)#
#
create_truth_vec <- function(class) {#
	# Assume that group 1 is class in consideration, group 2 is everything else#
	truth_vec <- rep.int(2, ncol(quantile_norm_data))#
	truth_table <- sample_factors == class#
	for (i in 1:length(truth_vec)) {#
		if (truth_table[i]) {#
			truth_vec[i] <- 1#
		}#
	}#
	return(truth_vec)#
}#
#
# Assign 1s and 2s based on group#
v_s_vec <- create_truth_vec("v_s")#
v_as_vec <- create_truth_vec("v_as")#
bl_vec <- create_truth_vec("bl")#
bc_vec <- create_truth_vec("bc")#
#
# Assign names for data matrix for input into permtest#
column_names <- 1:ncol(quantile_norm_data)#
colnames(quantile_norm_data) <- column_names#
#
# Create designmatrices#
v_s_dm <- cbind(column_names, v_s_vec)#
v_as_dm <- cbind(column_names, v_as_vec)#
bl_dm <- cbind(column_names, bl_vec)#
bc_dm <- cbind(column_names, bc_vec)#
#
# Do permutation tests#
v_s_result <- permtest(quantile_norm_data, v_s_dm, distance="euclid", nperms=1000, designtype="random")#
v_as_result <- permtest(quantile_norm_data, v_as_dm, distance="euclid", nperms=1000, designtype="random")#
bl_result <- permtest(quantile_norm_data, bl_dm, distance="euclid", nperms=1000, designtype="random")#
bc_result <- permtest(quantile_norm_data, bc_dm, distance="euclid", nperms=1000, designtype="random")#
#
# Write out summaries to txt files#
write.table(v_s_result, "R_Data_temp/permutation_test_summary/viral_symptomatic.txt", sep="\t", quote=FALSE)#
write.table(v_as_result, "R_Data_temp/permutation_test_summary/viral_asymptomatic.txt", sep="\t", quote=FALSE)#
write.table(bl_result, "R_Data_temp/permutation_test_summary/baseline.txt", sep="\t", quote=FALSE)#
write.table(bc_result, "R_Data_temp/permutation_test_summary/bacteria.txt", sep="\t", quote=FALSE)
load("/Users/mrincredible/Box Sync/Home Folder csh36/Sharing/Data_Plus/R_Data/saved_quantile_norm_data.r")
load("/Users/mrincredible/Box Sync/Home Folder csh36/Sharing/Data_Plus/R_Data/saved_sample_factors.r")
# Load the following...#
# sample_factors#
# quantile_norm_data#
#
# For reference, factors are#
# Viral Symptomatic - v_s#
# Viral Asymptomatic - v_as#
# Baseline - bl#
# Bacteria - bc#
#
# Load permtest package#
library(permtest)#
#
create_truth_vec <- function(class) {#
	# Assume that group 1 is class in consideration, group 2 is everything else#
	truth_vec <- rep.int(2, ncol(quantile_norm_data))#
	truth_table <- sample_factors == class#
	for (i in 1:length(truth_vec)) {#
		if (truth_table[i]) {#
			truth_vec[i] <- 1#
		}#
	}#
	return(truth_vec)#
}#
#
# Assign 1s and 2s based on group#
v_s_vec <- create_truth_vec("v_s")#
v_as_vec <- create_truth_vec("v_as")#
bl_vec <- create_truth_vec("bl")#
bc_vec <- create_truth_vec("bc")#
#
# Assign names for data matrix for input into permtest#
column_names <- 1:ncol(quantile_norm_data)#
colnames(quantile_norm_data) <- column_names#
#
# Create designmatrices#
v_s_dm <- cbind(column_names, v_s_vec)#
v_as_dm <- cbind(column_names, v_as_vec)#
bl_dm <- cbind(column_names, bl_vec)#
bc_dm <- cbind(column_names, bc_vec)#
#
# Do permutation tests#
v_s_result <- permtest(quantile_norm_data, v_s_dm, distance="euclid", nperms=1000, designtype="random")#
v_as_result <- permtest(quantile_norm_data, v_as_dm, distance="euclid", nperms=1000, designtype="random")#
bl_result <- permtest(quantile_norm_data, bl_dm, distance="euclid", nperms=1000, designtype="random")#
bc_result <- permtest(quantile_norm_data, bc_dm, distance="euclid", nperms=1000, designtype="random")#
#
# Write out summaries to txt files#
write.table(v_s_result, "R_Data_temp/permutation_test_summary/viral_symptomatic.txt", sep="\t", quote=FALSE)#
write.table(v_as_result, "R_Data_temp/permutation_test_summary/viral_asymptomatic.txt", sep="\t", quote=FALSE)#
write.table(bl_result, "R_Data_temp/permutation_test_summary/baseline.txt", sep="\t", quote=FALSE)#
write.table(bc_result, "R_Data_temp/permutation_test_summary/bacteria.txt", sep="\t", quote=FALSE)
# Do permutation tests#
v_s_result <- permtest(quantile_norm_data, v_s_dm, distance="euclid", nperms=100000, designtype="random")#
v_as_result <- permtest(quantile_norm_data, v_as_dm, distance="euclid", nperms=100000, designtype="random")#
bl_result <- permtest(quantile_norm_data, bl_dm, distance="euclid", nperms=100000, designtype="random")#
bc_result <- permtest(quantile_norm_data, bc_dm, distance="euclid", nperms=100000, designtype="random")#
#
# Write out summaries to txt files#
write.table(v_s_result, "R_Data_temp/permutation_test_summary/viral_symptomatic.txt", sep="\t", quote=FALSE)#
write.table(v_as_result, "R_Data_temp/permutation_test_summary/viral_asymptomatic.txt", sep="\t", quote=FALSE)#
write.table(bl_result, "R_Data_temp/permutation_test_summary/baseline.txt", sep="\t", quote=FALSE)#
write.table(bc_result, "R_Data_temp/permutation_test_summary/bacteria.txt", sep="\t", quote=FALSE)
install.packages("clusterSim")
x <- c(TRUE, TRUE, FALSE, FALSE, TRUE)
y <- c(FALSE, TRUE, TRUE, FALSE, FALSE)
z <- x | y
z
x <- 1
class(x)
x <- "tummy"
x
class(x)
x <- c("mama","papa")
class(x)
x
x <- vector(mode="logical",length=12)
x
load("/Users/mrincredible/Box Sync/Home Folder csh36/Sharing/Data_Plus/R_Data/saved_sample_factors.r")
load("/Users/mrincredible/Box Sync/Home Folder csh36/Sharing/Data_Plus/R_Data/saved_quantile_norm_data.r")
# Load the following...#
# sample_factors#
# quantile_norm_data#
#
# For reference, factors are#
# Viral Symptomatic - v_s#
# Viral Asymptomatic - v_as#
# Baseline - bl#
# Bacteria - bc#
#
# Load permtest package#
library(permtest)#
#
# Assign names for data matrix for input into permtest#
column_names <- 1:ncol(quantile_norm_data)#
colnames(quantile_norm_data) <- column_names#
#
assign_truth_table <- function(class_list, num_samples) {#
	# initialize truth_table to all false#
	truth_table <- vector(mode="logical", length=num_samples)#
	# do logical or to make all considered samples true#
	for (class in class_list) {#
		truth_vals <- sample_factors == class#
		truth_table <- truth_table | truth_vals#
	}#
	return(truth_table)#
}#
#
create_two_grps <- function(class_list_1, class_list_2) {#
# The output is a list... #
# 1. list of 1s and 2s for grp assignment#
# 2. column numbers used#
# 3. truth table for samples used#
	num_samples <- ncol(quantile_norm_data)#
	truth_table_1 <- assign_truth_table(class_list_1, num_samples)#
	truth_table_2 <- assign_truth_table(class_list_2, num_samples)#
	# get truth table for samples used in classes 1 & 2#
	samples_used <- truth_table_1 | truth_table_2#
	# find number of samples for both classes#
	num_true_1 <- length(which(truth_table_1))#
	num_true_2 <- length(which(truth_table_2))#
	num_true <- num_true_1 + num_true_2#
	# create vector of group category per sample#
	grp_vec <- vector(length=num_true)#
	# assign column names for design matrix#
	col_name_vec <- vector(length=num_true)#
	# j is current number to fill in truth_vec#
	for (i in 1:num_samples) {#
		if (truth_table_1[i]) {#
			grp_vec[j] <- 1#
			col_name_vec[j] <- i#
			j <- j + 1#
		}#
		else if (truth_table_2[i]) {#
			grp_vec[j] <- 2#
			col_name_vec[j] <- i#
			j <- j + 1#
		}#
	}#
	if (j != num_true + 1) {#
		stop("Error: Not all of truth_vec covered")#
	}#
	out <- list()#
	out[1] <- grp_vec#
	out[2] <- col_name_vec#
	out[3] <- samples_used#
	return(out)#
}#
#
perform_permtest <- function(class_list_1, class_list_2) {#
	out_two_grps <- create_two_grps(class_list_1, class_list_2)#
	samples_used <- out_two_grps[3]#
	# assign data matrix based on subset used for classes 1 & 2#
	data_matrix <- quantile_norm_data[,samples_used]#
	# create designmatrix#
	dm <- cbind(out[2], out[1])#
	result <- permtest(data_matrix, dm, distance="euclid", nperms=100000, designtype="random")#
	return(result)#
}#
#
# Do permutation tests#
bc_vs_v_result <- perform_permtest("bc", c("v_s", "v_as"))#
bc_vs_bl_result <- perform_permtest("bc", "bl")#
v_vs_all_result <- perform_permtest(c("v_s", "v_as"), c("bc", "bl"))#
#
# Write out summaries to txt files#
write.table(bc_vs_v_result, "R_Data_temp/permtest_summary/bacterial_vs_viral.txt", sep="\t", quote=FALSE)#
write.table(bc_vs_bl_result, "R_Data_temp/permtest_summary/bacterial_vs_healthy.txt", sep="\t", quote=FALSE)#
write.table(v_vs_all_result, "R_Data_temp/permtest_summary/viral_vs_all.txt", sep="\t", quote=FALSE)
# Load the following...#
# sample_factors#
# quantile_norm_data#
#
# For reference, factors are#
# Viral Symptomatic - v_s#
# Viral Asymptomatic - v_as#
# Baseline - bl#
# Bacteria - bc#
#
# Load permtest package#
library(permtest)#
#
# Assign names for data matrix for input into permtest#
column_names <- 1:ncol(quantile_norm_data)#
colnames(quantile_norm_data) <- column_names#
#
assign_truth_table <- function(class_list, num_samples) {#
	# initialize truth_table to all false#
	truth_table <- vector(mode="logical", length=num_samples)#
	# do logical or to make all considered samples true#
	for (class in class_list) {#
		truth_vals <- sample_factors == class#
		truth_table <- truth_table | truth_vals#
	}#
	return(truth_table)#
}#
#
create_two_grps <- function(class_list_1, class_list_2) {#
# The output is a list... #
# 1. list of 1s and 2s for grp assignment#
# 2. column numbers used#
# 3. truth table for samples used#
	num_samples <- ncol(quantile_norm_data)#
	truth_table_1 <- assign_truth_table(class_list_1, num_samples)#
	truth_table_2 <- assign_truth_table(class_list_2, num_samples)#
	# get truth table for samples used in classes 1 & 2#
	samples_used <- truth_table_1 | truth_table_2#
	# find number of samples for both classes#
	num_true_1 <- length(which(truth_table_1))#
	num_true_2 <- length(which(truth_table_2))#
	num_true <- num_true_1 + num_true_2#
	# create vector of group category per sample#
	grp_vec <- vector(length=num_true)#
	# assign column names for design matrix#
	col_name_vec <- vector(length=num_true)#
	# j is current number to fill in truth_vec#
	j <- 1#
	for (i in 1:num_samples) {#
		if (truth_table_1[i]) {#
			grp_vec[j] <- 1#
			col_name_vec[j] <- i#
			j <- j + 1#
		}#
		else if (truth_table_2[i]) {#
			grp_vec[j] <- 2#
			col_name_vec[j] <- i#
			j <- j + 1#
		}#
	}#
	if (j != num_true + 1) {#
		stop("Error: Not all of truth_vec covered")#
	}#
	out <- list()#
	out[1] <- grp_vec#
	out[2] <- col_name_vec#
	out[3] <- samples_used#
	return(out)#
}#
#
perform_permtest <- function(class_list_1, class_list_2) {#
	out_two_grps <- create_two_grps(class_list_1, class_list_2)#
	samples_used <- out_two_grps[3]#
	# assign data matrix based on subset used for classes 1 & 2#
	data_matrix <- quantile_norm_data[,samples_used]#
	# create designmatrix#
	dm <- cbind(out[2], out[1])#
	result <- permtest(data_matrix, dm, distance="euclid", nperms=100000, designtype="random")#
	return(result)#
}#
#
# Do permutation tests#
bc_vs_v_result <- perform_permtest("bc", c("v_s", "v_as"))#
bc_vs_bl_result <- perform_permtest("bc", "bl")#
v_vs_all_result <- perform_permtest(c("v_s", "v_as"), c("bc", "bl"))#
#
# Write out summaries to txt files#
write.table(bc_vs_v_result, "R_Data_temp/permtest_summary/bacterial_vs_viral.txt", sep="\t", quote=FALSE)#
write.table(bc_vs_bl_result, "R_Data_temp/permtest_summary/bacterial_vs_healthy.txt", sep="\t", quote=FALSE)#
write.table(v_vs_all_result, "R_Data_temp/permtest_summary/viral_vs_all.txt", sep="\t", quote=FALSE)
# Load the following...#
# sample_factors#
# quantile_norm_data#
#
# For reference, factors are#
# Viral Symptomatic - v_s#
# Viral Asymptomatic - v_as#
# Baseline - bl#
# Bacteria - bc#
#
# Load permtest package#
library(permtest)#
#
# Assign names for data matrix for input into permtest#
column_names <- 1:ncol(quantile_norm_data)#
colnames(quantile_norm_data) <- column_names#
#
assign_truth_table <- function(class_list, num_samples) {#
	# initialize truth_table to all false#
	truth_table <- vector(mode="logical", length=num_samples)#
	# do logical or to make all considered samples true#
	for (class in class_list) {#
		truth_vals <- sample_factors == class#
		truth_table <- truth_table | truth_vals#
	}#
	return(truth_table)#
}#
#
create_two_grps <- function(class_list_1, class_list_2) {#
# The output is a list... #
# 1. list of 1s and 2s for grp assignment#
# 2. column numbers used#
# 3. truth table for samples used#
	num_samples <- ncol(quantile_norm_data)#
	truth_table_1 <- assign_truth_table(class_list_1, num_samples)#
	truth_table_2 <- assign_truth_table(class_list_2, num_samples)#
	# get truth table for samples used in classes 1 & 2#
	samples_used <- truth_table_1 | truth_table_2#
	# find number of samples for both classes#
	num_true_1 <- length(which(truth_table_1))#
	num_true_2 <- length(which(truth_table_2))#
	num_true <- num_true_1 + num_true_2#
	# create vector of group category per sample#
	grp_vec <- vector(length=num_true)#
	# assign column names for design matrix#
	col_name_vec <- vector(length=num_true)#
	# j is current number to fill in truth_vec#
	j <- 1#
	for (i in 1:num_samples) {#
		if (truth_table_1[i]) {#
			grp_vec[j] <- 1#
			col_name_vec[j] <- i#
			j <- j + 1#
		}#
		else if (truth_table_2[i]) {#
			grp_vec[j] <- 2#
			col_name_vec[j] <- i#
			j <- j + 1#
		}#
	}#
	if (j != num_true + 1) {#
		stop("Error: Not all of truth_vec covered")#
	}#
	out <- list()#
	out[[1]] <- grp_vec#
	out[[2]] <- col_name_vec#
	out[[3]] <- samples_used#
	return(out)#
}#
#
perform_permtest <- function(class_list_1, class_list_2) {#
	out_two_grps <- create_two_grps(class_list_1, class_list_2)#
	samples_used <- out_two_grps[[3]]#
	# assign data matrix based on subset used for classes 1 & 2#
	data_matrix <- quantile_norm_data[,samples_used]#
	# create designmatrix#
	dm <- cbind(out[[2]], out[[1]])#
	result <- permtest(data_matrix, dm, distance="euclid", nperms=100000, designtype="random")#
	return(result)#
}#
#
# Do permutation tests#
bc_vs_v_result <- perform_permtest("bc", c("v_s", "v_as"))#
bc_vs_bl_result <- perform_permtest("bc", "bl")#
v_vs_all_result <- perform_permtest(c("v_s", "v_as"), c("bc", "bl"))#
#
# Write out summaries to txt files#
write.table(bc_vs_v_result, "R_Data_temp/permtest_summary/bacterial_vs_viral.txt", sep="\t", quote=FALSE)#
write.table(bc_vs_bl_result, "R_Data_temp/permtest_summary/bacterial_vs_healthy.txt", sep="\t", quote=FALSE)#
write.table(v_vs_all_result, "R_Data_temp/permtest_summary/viral_vs_all.txt", sep="\t", quote=FALSE)
# Load the following...#
# sample_factors#
# quantile_norm_data#
#
# For reference, factors are#
# Viral Symptomatic - v_s#
# Viral Asymptomatic - v_as#
# Baseline - bl#
# Bacteria - bc#
#
# Load permtest package#
library(permtest)#
#
# Assign names for data matrix for input into permtest#
column_names <- 1:ncol(quantile_norm_data)#
colnames(quantile_norm_data) <- column_names#
#
assign_truth_table <- function(class_list, num_samples) {#
	# initialize truth_table to all false#
	truth_table <- vector(mode="logical", length=num_samples)#
	# do logical or to make all considered samples true#
	for (class in class_list) {#
		truth_vals <- sample_factors == class#
		truth_table <- truth_table | truth_vals#
	}#
	return(truth_table)#
}#
#
create_two_grps <- function(class_list_1, class_list_2) {#
# The output is a list... #
# 1. list of 1s and 2s for grp assignment#
# 2. column numbers used#
# 3. truth table for samples used#
	num_samples <- ncol(quantile_norm_data)#
	truth_table_1 <- assign_truth_table(class_list_1, num_samples)#
	truth_table_2 <- assign_truth_table(class_list_2, num_samples)#
	# get truth table for samples used in classes 1 & 2#
	samples_used <- truth_table_1 | truth_table_2#
	# find number of samples for both classes#
	num_true_1 <- length(which(truth_table_1))#
	num_true_2 <- length(which(truth_table_2))#
	num_true <- num_true_1 + num_true_2#
	# create vector of group category per sample#
	grp_vec <- vector(length=num_true)#
	# assign column names for design matrix#
	col_name_vec <- vector(length=num_true)#
	# j is current number to fill in truth_vec#
	j <- 1#
	for (i in 1:num_samples) {#
		if (truth_table_1[i]) {#
			grp_vec[j] <- 1#
			col_name_vec[j] <- i#
			j <- j + 1#
		}#
		else if (truth_table_2[i]) {#
			grp_vec[j] <- 2#
			col_name_vec[j] <- i#
			j <- j + 1#
		}#
	}#
	if (j != num_true + 1) {#
		stop("Error: Not all of truth_vec covered")#
	}#
	out <- list()#
	out[[1]] <- grp_vec#
	out[[2]] <- col_name_vec#
	out[[3]] <- samples_used#
	return(out)#
}#
#
perform_permtest <- function(class_list_1, class_list_2) {#
	out_two_grps <- create_two_grps(class_list_1, class_list_2)#
	samples_used <- out_two_grps[[3]]#
	# assign data matrix based on subset used for classes 1 & 2#
	data_matrix <- quantile_norm_data[,samples_used]#
	# create designmatrix#
	dm <- cbind(out_two_grps[[2]], out_two_grps[[1]])#
	result <- permtest(data_matrix, dm, distance="euclid", nperms=100000, designtype="random")#
	return(result)#
}#
#
# Do permutation tests#
bc_vs_v_result <- perform_permtest("bc", c("v_s", "v_as"))#
bc_vs_bl_result <- perform_permtest("bc", "bl")#
v_vs_all_result <- perform_permtest(c("v_s", "v_as"), c("bc", "bl"))#
#
# Write out summaries to txt files#
write.table(bc_vs_v_result, "R_Data_temp/permtest_summary/bacterial_vs_viral.txt", sep="\t", quote=FALSE)#
write.table(bc_vs_bl_result, "R_Data_temp/permtest_summary/bacterial_vs_healthy.txt", sep="\t", quote=FALSE)#
write.table(v_vs_all_result, "R_Data_temp/permtest_summary/viral_vs_all.txt", sep="\t", quote=FALSE)
# Retrieve Data#
# quantile_norm_data retrieved#
load("R_data/saved_quantile_norm_data")#
#
# Do PCA Analysis#
pca_analysis <- dget("R_Code/PCA/analyze_PCs_samples.r")#
pca_analysis(quantile_norm_data, 10)
load("/Users/mrincredible/Box Sync/Home Folder csh36/Sharing/Data_Plus/R_Data/saved_quantile_norm_data.r")
# Load the following...#
# quantile_norm_data#
#
# Do PCA Analysis#
pca_analysis <- dget("R_Code/PCA/analyze_PCs_samples.r")#
pca_analysis(quantile_norm_data, 10)
load("/Users/mrincredible/Dropbox/Duke/Data+/miRNA_dataPlus/R_Data_temp/saved_corr_samples.r")
head(corr)
head(corr[,3])
max(abs(corr[,2]))
# Load the following...#
# sample_factors#
# quantile_norm_data#
#
# For reference, factors are#
# Viral Symptomatic - v_s#
# Viral Asymptomatic - v_as#
# Baseline - bl#
# Bacteria - bc#
#
# Load permtest package#
library(permtest)#
#
# Assign names for data matrix for input into permtest#
column_names <- 1:ncol(quantile_norm_data)#
colnames(quantile_norm_data) <- column_names#
#
assign_truth_table <- function(class_list, num_samples) {#
	# initialize truth_table to all false#
	truth_table <- vector(mode="logical", length=num_samples)#
	# do logical or to make all considered samples true#
	for (class in class_list) {#
		truth_vals <- sample_factors == class#
		truth_table <- truth_table | truth_vals#
	}#
	return(truth_table)#
}#
#
create_two_grps <- function(class_list_1, class_list_2) {#
# The output is a list... #
# 1. list of 1s and 2s for grp assignment#
# 2. column numbers used#
# 3. truth table for samples used#
	num_samples <- ncol(quantile_norm_data)#
	truth_table_1 <- assign_truth_table(class_list_1, num_samples)#
	truth_table_2 <- assign_truth_table(class_list_2, num_samples)#
	# get truth table for samples used in classes 1 & 2#
	samples_used <- truth_table_1 | truth_table_2#
	# find number of samples for both classes#
	num_true_1 <- length(which(truth_table_1))#
	num_true_2 <- length(which(truth_table_2))#
	num_true <- num_true_1 + num_true_2#
	# create vector of group category per sample#
	grp_vec <- vector(length=num_true)#
	# assign column names for design matrix#
	col_name_vec <- vector(length=num_true)#
	# j is current number to fill in truth_vec#
	j <- 1#
	for (i in 1:num_samples) {#
		if (truth_table_1[i]) {#
			grp_vec[j] <- 1#
			col_name_vec[j] <- i#
			j <- j + 1#
		}#
		else if (truth_table_2[i]) {#
			grp_vec[j] <- 2#
			col_name_vec[j] <- i#
			j <- j + 1#
		}#
	}#
	if (j != num_true + 1) {#
		stop("Error: Not all of truth_vec covered")#
	}#
	out <- list()#
	out[[1]] <- grp_vec#
	out[[2]] <- col_name_vec#
	out[[3]] <- samples_used#
	return(out)#
}#
#
perform_permtest <- function(class_list_1, class_list_2) {#
	out_two_grps <- create_two_grps(class_list_1, class_list_2)#
	samples_used <- out_two_grps[[3]]#
	# assign data matrix based on subset used for classes 1 & 2#
	data_matrix <- quantile_norm_data[,samples_used]#
	# create designmatrix#
	dm <- cbind(out_two_grps[[2]], out_two_grps[[1]])#
	# do permtest#
	result <- permtest(data_matrix, dm, distance="euclid", nperms=100000, designtype="random")#
	return(result)#
}#
#
# Do permutation tests#
bc_vs_v_result <- perform_permtest("bc", c("v_s", "v_as"))#
bc_vs_bl_result <- perform_permtest("bc", "bl")#
v_vs_all_result <- perform_permtest(c("v_s", "v_as"), c("bc", "bl"))#
v_vs_bl_result <- perform_permtest(c("v_s", "v_as"), c("bl"))#
#
# Write out summaries to txt files#
write.table(bc_vs_v_result, "R_Data_temp/permtest_summary/bacterial_vs_viral.txt", sep="\t", quote=FALSE)#
write.table(bc_vs_bl_result, "R_Data_temp/permtest_summary/bacterial_vs_healthy.txt", sep="\t", quote=FALSE)#
write.table(v_vs_all_result, "R_Data_temp/permtest_summary/viral_vs_all.txt", sep="\t", quote=FALSE)#
write.table(v_vs_bl_result, "R_Data_temp/permtest_summary/viral_vs_all.txt", sep="\t", quote=FALSE)
write.table(bc_vs_v_result, "R_Data_temp/permtest_summary/bacterial_vs_viral.txt", sep="\t", quote=FALSE)#
write.table(bc_vs_bl_result, "R_Data_temp/permtest_summary/bacterial_vs_healthy.txt", sep="\t", quote=FALSE)#
write.table(v_vs_all_result, "R_Data_temp/permtest_summary/viral_vs_all.txt", sep="\t", quote=FALSE)#
write.table(v_vs_bl_result, "R_Data_temp/permtest_summary/viral_vs_all.txt", sep="\t", quote=FALSE)
write.table(bc_vs_v_result, "R_Data_temp/permtest_summary/bacterial_vs_viral.txt", sep="\t", quote=FALSE)#
write.table(bc_vs_bl_result, "R_Data_temp/permtest_summary/bacterial_vs_healthy.txt", sep="\t", quote=FALSE)#
write.table(v_vs_all_result, "R_Data_temp/permtest_summary/viral_vs_all.txt", sep="\t", quote=FALSE)#
write.table(v_vs_bl_result, "R_Data_temp/permtest_summary/viral_vs_healthy.txt", sep="\t", quote=FALSE)
# insert data set#
known_data <-read.delim("R_Data_in/known_miRNAs_expressed_all_samples.txt", header=TRUE)#
#
# extract raw data into matrix (just #s), exclude "norm" data#
raw_data <- known_data[,5:56]#
raw_data <- data.matrix(raw_data)#
#
# save row names into matrix#
miRNA_names <- known_data[,1]#
rownames(raw_data) <- miRNA_names#
#
# save raw data#
save(raw_data, file="R_Data_out/saved_raw_data")#
#
# function to count zeros, return proportions#
count_zeros <- function(v) {#
	len <- length(v)#
	zero_bool <- v==0#
	zero_count <- length(which(zero_bool == "TRUE"))#
	nonzero_count <- len - zero_count#
	props <- c(0, 0)#
	props[1] <- zero_count / len#
	props[2] <- nonzero_count / len#
	return(props)#
}#
#
# find zero proportions for each sample#
zero_counts_sample <- apply(raw_data, 2, count_zeros)#
#
# find zero proportions for each miRNA#
zero_counts_miRNA <- apply(raw_data, 1, count_zeros)#
#
# save zero proportions (zero_count / len)#
zero_props_miRNA <- zero_counts_miRNA[1,]#
save(zero_props_miRNA, file="R_Data_out/saved_zero_props_miRNA")#
#
# delete miRNAs that have >50% zeros#
over_50 <- zero_props_miRNA > 0.5#
processed_data <- raw_data[!over_50,]#
#
# save processed data#
# save as R file#
save(processed_data, file="R_Data_out/saved_processed_data")#
# save as txt file#
write.table(processed_data, "R_Data_out/saved_processed_data_text.txt", sep="\t",#
		quote=FALSE)#
#
# get precursor names#
precursor_names <- known_data$precursor#
# get corresponding precursor names for processed_data#
prec_names_proc <- precursor_names[!over_50]#
# save precursor names for processed_data#
save(prec_names_proc, file="R_Data_out/saved_prec_names_proc")
# save precursor & miRNA names of processed data as txt files#
write.table(rownames(processed_data), "R_Data_out/miRNA_names_proc.txt", sep="\t", quote=FALSE)
write.table(prec_names_proc, "R_Data_out/prec_names_proc.txt", sep="\t", quote=FALSE)
save(miRNA_names_proc, file="R_Data_out/saved_miRNA_names_proc")
# get miRNA names for processed_data#
miRNA_names_proc <- rownames(processed_data)#
# save miRNA names for processed_data#
save(miRNA_names_proc, file="R_Data_out/saved_miRNA_names_proc")
<<<<<<< Updated upstream
>>>>>>> origin/master
=======
load("/Users/mrincredible/Box Sync/Home Folder csh36/Sharing/Data_Plus/R_Data/saved_miRNA_names_proc.r")
miRNA_names_proc[c(86,165,191)]
>>>>>>> Stashed changes
fun <- function(a,b,c) {}
fun <- function(a,b,c){return(a+b)}
x <- fun(2,3)
x
# wilcoxin tests #
# load processed_data...#
# subset viral, bacterial, baseline, asymptomatic/symptomatic miRNA expression#
allviral <- processed_data[,1:21]#
baseline <- processed_data[,22:42]#
bacterial <- processed_data[,43:52]#
viral_symptomatic <- processed_data[,c(1,2,5,9,11,13,15,16,17,18,19,20,21)]#
viral_asymptomatic <- processed_data[,c(3,4,6,7,8,10,12,14)]#
combined_bacterial_baseline <- processed_data[,22:52]#
combined_bacterial_allviral <- processed_data[,c(1:21,43:52)]#
combined_baseline_allviral <- processed_data[,1:42]#
# wilcoxon function#
do_wilcoxon <- function(s1, s2, is_paired) {#
	result <- wilcox.test(s1, s2, alternative="two.sided")#
	return(result$p.value)#
}#
# make an output matrix for the pvalues of all the tests#
wp_vals <- matrix(, nrow=nrow(processed_data), ncol=11)#
# conducting a wilcoxon test using a for loop#
for (k in 1:nrow(processed_data)) {#
	woutput_vector <- vector(length=11)#
	woutput_vector[1] <- do_wilcoxon(allviral[k,], bacterial[k,])#
	woutput_vector[2] <- do_wilcoxon(allviral[k,], baseline[k,])#
	woutput_vector[3] <- do_wilcoxon(viral_symptomatic[k,], viral_asymptomatic[k,])#
	woutput_vector[4] <- do_wilcoxon(bacterial[k,], baseline[k,])#
	woutput_vector[5] <- do_wilcoxon(bacterial[k,], viral_symptomatic[k,])#
	woutput_vector[6] <- do_wilcoxon(bacterial[k,], viral_asymptomatic[k,])#
	woutput_vector[7] <- do_wilcoxon(baseline[k,], viral_symptomatic[k,])#
	woutput_vector[8] <- do_wilcoxon(baseline[k,], viral_asymptomatic[k,])#
	woutput_vector[9] <- do_wilcoxon(combined_bacterial_baseline[k,], allviral[k,])#
	woutput_vector[10] <- do_wilcoxon(combined_bacterial_allviral[k,], baseline[k,])#
	woutput_vector[11] <- do_wilcoxon(combined_baseline_allviral[k,], bacterial[k,])#
	wp_vals[k,] <- woutput_vector#
}
load("/Users/mrincredible/Box Sync/Home Folder csh36/Sharing/Data_Plus/R_Data/saved_processed_data.r")
# wilcoxin tests #
# load processed_data...#
# subset viral, bacterial, baseline, asymptomatic/symptomatic miRNA expression#
allviral <- processed_data[,1:21]#
baseline <- processed_data[,22:42]#
bacterial <- processed_data[,43:52]#
viral_symptomatic <- processed_data[,c(1,2,5,9,11,13,15,16,17,18,19,20,21)]#
viral_asymptomatic <- processed_data[,c(3,4,6,7,8,10,12,14)]#
combined_bacterial_baseline <- processed_data[,22:52]#
combined_bacterial_allviral <- processed_data[,c(1:21,43:52)]#
combined_baseline_allviral <- processed_data[,1:42]#
# wilcoxon function#
do_wilcoxon <- function(s1, s2, is_paired) {#
	result <- wilcox.test(s1, s2, alternative="two.sided")#
	return(result$p.value)#
}#
# make an output matrix for the pvalues of all the tests#
wp_vals <- matrix(, nrow=nrow(processed_data), ncol=11)#
# conducting a wilcoxon test using a for loop#
for (k in 1:nrow(processed_data)) {#
	woutput_vector <- vector(length=11)#
	woutput_vector[1] <- do_wilcoxon(allviral[k,], bacterial[k,])#
	woutput_vector[2] <- do_wilcoxon(allviral[k,], baseline[k,])#
	woutput_vector[3] <- do_wilcoxon(viral_symptomatic[k,], viral_asymptomatic[k,])#
	woutput_vector[4] <- do_wilcoxon(bacterial[k,], baseline[k,])#
	woutput_vector[5] <- do_wilcoxon(bacterial[k,], viral_symptomatic[k,])#
	woutput_vector[6] <- do_wilcoxon(bacterial[k,], viral_asymptomatic[k,])#
	woutput_vector[7] <- do_wilcoxon(baseline[k,], viral_symptomatic[k,])#
	woutput_vector[8] <- do_wilcoxon(baseline[k,], viral_asymptomatic[k,])#
	woutput_vector[9] <- do_wilcoxon(combined_bacterial_baseline[k,], allviral[k,])#
	woutput_vector[10] <- do_wilcoxon(combined_bacterial_allviral[k,], baseline[k,])#
	woutput_vector[11] <- do_wilcoxon(combined_baseline_allviral[k,], bacterial[k,])#
	wp_vals[k,] <- woutput_vector#
}
warnings()
# insert data set#
known_data <-read.delim("R_Data_in/known_miRNAs_expressed_all_samples.txt", header=TRUE)#
#
# extract raw data into matrix (just #s), exclude "norm" data#
raw_data <- known_data[,5:56]#
raw_data <- data.matrix(raw_data)#
#
# save row names into matrix#
miRNA_names <- known_data[,1]#
rownames(raw_data) <- miRNA_names#
#
# save raw data#
save(raw_data, file="R_Data_out/saved_raw_data")#
#
# function to count zeros, return proportions#
count_zeros <- function(v) {#
	len <- length(v)#
	zero_bool <- v==0#
	zero_count <- length(which(zero_bool == "TRUE"))#
	nonzero_count <- len - zero_count#
	props <- c(0, 0)#
	props[1] <- zero_count / len#
	props[2] <- nonzero_count / len#
	return(props)#
}#
#
# find zero proportions for each sample#
zero_counts_sample <- apply(raw_data, 2, count_zeros)#
#
# find zero proportions for each miRNA#
zero_counts_miRNA <- apply(raw_data, 1, count_zeros)#
#
# save zero proportions (zero_count / len)#
zero_props_miRNA <- zero_counts_miRNA[1,]#
save(zero_props_miRNA, file="R_Data_out/saved_zero_props_miRNA")#
#
# delete miRNAs that have >50% zeros#
over_50 <- zero_props_miRNA > 0.5#
processed_data <- raw_data[!over_50,]#
#
# save processed data#
# save as R file#
save(processed_data, file="R_Data_out/saved_processed_data")#
#
# get miRNA names for processed_data#
miRNA_names_proc <- rownames(processed_data)#
# save miRNA names for processed_data#
save(miRNA_names_proc, file="R_Data_out/saved_miRNA_names_proc")#
write.table(, "R_Data_out/miRNA_names_proc.txt", sep="\t", quote=FALSE)#
#
# get precursor names#
precursor_names <- known_data$precursor#
# get corresponding precursor names for processed_data#
prec_names_proc <- precursor_names[!over_50]#
# save precursor names for processed_data#
save(prec_names_proc, file="R_Data_out/saved_prec_names_proc")#
write.table(prec_names_proc, "R_Data_out/prec_names_proc.txt", sep="\t", quote=FALSE)
# insert data set#
known_data <-read.delim("Data_in/known_miRNAs_expressed_all_samples.txt", header=TRUE)#
#
# extract raw data into matrix (just #s), exclude "norm" data#
raw_data <- known_data[,5:56]#
raw_data <- data.matrix(raw_data)#
#
# save row names into matrix#
miRNA_names <- known_data[,1]#
rownames(raw_data) <- miRNA_names#
#
# save raw data#
save(raw_data, file="R_Data_out/saved_raw_data")#
#
# function to count zeros, return proportions#
count_zeros <- function(v) {#
	len <- length(v)#
	zero_bool <- v==0#
	zero_count <- length(which(zero_bool == "TRUE"))#
	nonzero_count <- len - zero_count#
	props <- c(0, 0)#
	props[1] <- zero_count / len#
	props[2] <- nonzero_count / len#
	return(props)#
}#
#
# find zero proportions for each sample#
zero_counts_sample <- apply(raw_data, 2, count_zeros)#
#
# find zero proportions for each miRNA#
zero_counts_miRNA <- apply(raw_data, 1, count_zeros)#
#
# save zero proportions (zero_count / len)#
zero_props_miRNA <- zero_counts_miRNA[1,]#
save(zero_props_miRNA, file="Data_out/saved_zero_props_miRNA")#
#
# delete miRNAs that have >50% zeros#
over_50 <- zero_props_miRNA > 0.5#
processed_data <- raw_data[!over_50,]#
#
# save processed data#
# save as R file#
save(processed_data, file="Data_out/saved_processed_data")#
#
# get miRNA names for processed_data#
miRNA_names_proc <- rownames(processed_data)#
# save miRNA names for processed_data#
save(miRNA_names_proc, file="Data_out/saved_miRNA_names_proc")#
write.table(, "Data_out/miRNA_names_proc.txt", sep="\t", quote=FALSE)#
#
# get precursor names#
precursor_names <- known_data$precursor#
# get corresponding precursor names for processed_data#
prec_names_proc <- precursor_names[!over_50]#
# save precursor names for processed_data#
save(prec_names_proc, file="Data_out/saved_prec_names_proc")#
write.table(prec_names_proc, "Data_out/prec_names_proc.txt", sep="\t", quote=FALSE)
write.table(miRNA_names_proc, "Data_out/miRNA_names_proc.txt", sep="\t", quote=FALSE)
write.table(miRNA_names_proc, "Data_out/miRNA_names_proc.txt", row.names=FALSE, col.names=FALSE, sep="\t", quote=FALSE)
write.table(prec_names_proc, "Data_out/prec_names_proc.txt", row.names=FALSE, col.names=FALSE, sep="\t", quote=FALSE)
# Save factor vector#
save(sample_factors, file="Data_out/saved_sample_factors.r")#
write.table(sample_factors, "Data_out/sample_factors.txt", row.names=FALSE, col.names=FALSE, sep="\t", quote=FALSE)
# Factors are:#
# Viral Symptomatic - v_s#
# Viral Asymptomatic - v_as#
# Baseline - bl#
# Bacteria - bc#
#
# Write factors for viral symptomatic & asymptomatic#
viral_symp_indices <- c(1,2,5,9,11,13,15,16,17,18,19,20,21)#
viral_asymp_indices <- c(3,4,6,7,8,10,12,14)#
viral <- vector(length=21)#
for (i in viral_symp_indices) {#
	viral[i] <- "v_s"#
}#
for (i in viral_asymp_indices) {#
	viral[i] <- "v_as"#
}#
#
# Write factors for baseline#
baseline <- rep_len("bl", 21)#
#
# Write factors for bacteria#
bacteria <- rep_len("bc", 10)#
#
# Get one big factor vector#
category_vector <- c(viral, baseline, bacteria)#
sample_factors <- factor(category_vector)#
sample_factors#
#
# Save factor vector#
save(sample_factors, file="Data_out/saved_sample_factors.r")#
write.table(sample_factors, "Data_out/sample_factors.txt", row.names=FALSE, col.names=FALSE, sep="\t", quote=FALSE)
X <- matrix(c(1,2,3,4,5,6), nrow=3, ncol=2)
X
ext <- X[-2,]
X
ext
load("/Users/mrincredible/Box Sync/Home Folder csh36/Sharing/Data_Plus/R_Data/saved_miRNA_names_proc.r")
miRNA_names_proc[86]
# Perform logistic regression#
# Load the following...#
# 	quantile_norm_data#
#	sample_factors#
#
factor_names <- c("viral", "bacterial")#
factors <- list(c("v_s", "v_as"), "bc")#
#
m <- nrow(quantile_norm_data)#
row_names <- vector(mode="character", length=m)#
for (i in 1:m) {#
	row_names[i] <- paste("s", i, sep="")#
}#
rownames(quantile_norm_data) <- row_names#
#
data <- quantile_norm_data[c(19, 20, 32, 86, 93, 111, 141, 165, 191, 199, 200, 201, 209, 211, 329), ]#
output <- do_log_reg(data, factors, factor_names, sample_factors)#
#
do_log_reg <- function(data, factors, factor_names, factor_vec) {#
# perform logistic regression w/ all but one sample as training set#
# data is mxn matrix with m descrbing miRNAs, n describing samples#
# Make sure data rows are labeled with names#
	create_X_and_y <- dget("R_Code/Classifiers/create_X_and_y.R")#
	X_and_y <- create_X_and_y(data, factors, factor_names, factor_vec)#
	X <- X_and_y[[1]]#
	y <- X_and_y[[2]]#
	# X is mxn where m describes samples and n describes miRNAs#
	m <- nrow(X)#
	n <- ncol(X)#
#
	classify_one_out <- dget("R_Code/Classifiers/classify_one_out.R")#
	classifier_outs <- classify_one_out(X, y, logistic_regression)#
#
	out <- analyze_log_reg_output(X, y, classifier_outs, factor_names)#
	return(out)#
}#
#
logistic_regression <- function(X, y) {#
# Perform logistic regression on matrix X with categories specified in y#
# X is mxn where m is the # of samples, n is the # of miRNAs#
# X must have column names to specify which miRNAs are in the data#
# y must only have two categories#
# output is output of glm function (logistic regression)#
	m <- nrow(X)#
	n <- ncol(X)#
	# format data frame for input into glm#
	df <- as.data.frame(X)#
	feature_names <- colnames(df)#
	df <- cbind(df,y)#
	# create formula#
	formula_str <- "y~"#
	f1 <- feature_names[1]#
	formula_str <- paste(formula_str, f1, sep="")#
	for (i in 2:n) {#
		f_name <- feature_names[i]#
		formula_str <- paste(formula_str, "+", f_name, sep="")#
	}#
	formula <- as.formula(formula_str)#
	# perform glm#
	logreg_fit <- glm(formula, family=binomial, data=df)#
	return(logreg_fit)#
}#
#
analyze_log_reg_output <- function(X, y, classifier_outs, factor_names) {#
# X is mxn matrix where m describes samples and n describes miRNAs#
	m <- nrow(X)#
	n <- ncol(X)#
	if (m != length(classifier_outs)) {#
		stop("# of classifier outputs not equal to # of samples")#
	}#
	# convert y to vector of positives (true) and negatives (false)#
	y_positive <- y == factor_names[1]#
	coef_mat <- matrix( , nrow=m, ncol=n)#
	# vector of output result compared to actual label#
	# key:#
	# tp - true positive#
	# fp - false positive#
	# tn - true negative#
	# fn - false negative#
	out <- vector(mode="character", length=m)#
	for (i in 1:m) {#
		data_vec <- X[i, ]#
		df_elem <- data.frame(t(data_vec))#
		print(df_elem)#
		glm.prob <- predict(classifier_outs[[i]], newdata=df_elem, type="response")#
		coef_mat[i,] = coef(classifier_outs[[i]])#
		positive <- TRUE#
		if (glm.prob > .5) {#
			positive <- FALSE#
		}#
		if (positive) {#
			if (y_positive[i]) {#
				out[i] <- "tp"#
			} else {#
				out[i] <- "fp"#
			}#
		} else {#
			if (y_positive[i]) {#
				out[i] <- "fn"#
			} else {#
				out[i] <- "tn"#
			}#
		}#
	}#
	coef_avg <- apply(coef_mat, 2, mean)#
	return(list(out, coef_avg))#
}
# Perform logistic regression#
# Load the following...#
# 	quantile_norm_data#
#	sample_factors#
#
factor_names <- c("viral", "bacterial")#
factors <- list(c("v_s", "v_as"), "bc")#
#
m <- nrow(quantile_norm_data)#
row_names <- vector(mode="character", length=m)#
for (i in 1:m) {#
	row_names[i] <- paste("s", i, sep="")#
}#
rownames(quantile_norm_data) <- row_names#
#
data <- quantile_norm_data[c(19, 20, 32, 86, 93, 111, 141, 165, 191, 199, 200, 201, 209, 211, 329), ]#
output <- do_log_reg(data, factors, factor_names, sample_factors)#
#
do_log_reg <- function(data, factors, factor_names, factor_vec) {#
# perform logistic regression w/ all but one sample as training set#
# data is mxn matrix with m descrbing miRNAs, n describing samples#
# Make sure data rows are labeled with names#
	create_X_and_y <- dget("R_Code/Classifiers/create_X_and_y.R")#
	X_and_y <- create_X_and_y(data, factors, factor_names, factor_vec)#
	X <- X_and_y[[1]]#
	y <- X_and_y[[2]]#
	# X is mxn where m describes samples and n describes miRNAs#
	m <- nrow(X)#
	n <- ncol(X)#
#
	classify_one_out <- dget("R_Code/Classifiers/classify_one_out.R")#
	classifier_outs <- classify_one_out(X, y, logistic_regression)#
#
	out <- analyze_log_reg_output(X, y, classifier_outs, factor_names)#
	return(out)#
}#
#
logistic_regression <- function(X, y) {#
# Perform logistic regression on matrix X with categories specified in y#
# X is mxn where m is the # of samples, n is the # of miRNAs#
# X must have column names to specify which miRNAs are in the data#
# y must only have two categories#
# output is output of glm function (logistic regression)#
	m <- nrow(X)#
	n <- ncol(X)#
	# format data frame for input into glm#
	df <- as.data.frame(X)#
	feature_names <- colnames(df)#
	df <- cbind(df,y)#
	# create formula#
	formula_str <- "y~"#
	f1 <- feature_names[1]#
	formula_str <- paste(formula_str, f1, sep="")#
	for (i in 2:n) {#
		f_name <- feature_names[i]#
		formula_str <- paste(formula_str, "+", f_name, sep="")#
	}#
	formula <- as.formula(formula_str)#
	# perform glm#
	logreg_fit <- glm(formula, family=binomial, data=df)#
	return(logreg_fit)#
}#
#
analyze_log_reg_output <- function(X, y, classifier_outs, factor_names) {#
# X is mxn matrix where m describes samples and n describes miRNAs#
	m <- nrow(X)#
	n <- ncol(X)#
	if (m != length(classifier_outs)) {#
		stop("# of classifier outputs not equal to # of samples")#
	}#
	# convert y to vector of positives (true) and negatives (false)#
	y_positive <- y == factor_names[1]#
	coef_mat <- matrix( , nrow=m, ncol=n)#
	# vector of output result compared to actual label#
	# key:#
	# tp - true positive#
	# fp - false positive#
	# tn - true negative#
	# fn - false negative#
	out <- vector(mode="character", length=m)#
	for (i in 1:m) {#
		data_vec <- X[i, ]#
		df_elem <- data.frame(t(data_vec))#
		glm.prob <- predict(classifier_outs[[i]], newdata=df_elem, type="response")#
		print(classifier_outs[[i]])#
		coef_mat[i,] = coef(classifier_outs[[i]])#
		positive <- TRUE#
		if (glm.prob > .5) {#
			positive <- FALSE#
		}#
		if (positive) {#
			if (y_positive[i]) {#
				out[i] <- "tp"#
			} else {#
				out[i] <- "fp"#
			}#
		} else {#
			if (y_positive[i]) {#
				out[i] <- "fn"#
			} else {#
				out[i] <- "tn"#
			}#
		}#
	}#
	coef_avg <- apply(coef_mat, 2, mean)#
	return(list(out, coef_avg))#
}
# Perform logistic regression#
# Load the following...#
# 	quantile_norm_data#
#	sample_factors#
#
factor_names <- c("viral", "bacterial")#
factors <- list(c("v_s", "v_as"), "bc")#
#
m <- nrow(quantile_norm_data)#
row_names <- vector(mode="character", length=m)#
for (i in 1:m) {#
	row_names[i] <- paste("s", i, sep="")#
}#
rownames(quantile_norm_data) <- row_names#
#
data <- quantile_norm_data[c(19, 20, 32, 86, 93, 111, 141, 165, 191, 199, 200, 201, 209, 211, 329), ]#
output <- do_log_reg(data, factors, factor_names, sample_factors)#
#
do_log_reg <- function(data, factors, factor_names, factor_vec) {#
# perform logistic regression w/ all but one sample as training set#
# data is mxn matrix with m descrbing miRNAs, n describing samples#
# Make sure data rows are labeled with names#
	create_X_and_y <- dget("R_Code/Classifiers/create_X_and_y.R")#
	X_and_y <- create_X_and_y(data, factors, factor_names, factor_vec)#
	X <- X_and_y[[1]]#
	y <- X_and_y[[2]]#
	# X is mxn where m describes samples and n describes miRNAs#
	m <- nrow(X)#
	n <- ncol(X)#
#
	classify_one_out <- dget("R_Code/Classifiers/classify_one_out.R")#
	classifier_outs <- classify_one_out(X, y, logistic_regression)#
#
	out <- analyze_log_reg_output(X, y, classifier_outs, factor_names)#
	return(out)#
}#
#
logistic_regression <- function(X, y) {#
# Perform logistic regression on matrix X with categories specified in y#
# X is mxn where m is the # of samples, n is the # of miRNAs#
# X must have column names to specify which miRNAs are in the data#
# y must only have two categories#
# output is output of glm function (logistic regression)#
	m <- nrow(X)#
	n <- ncol(X)#
	# format data frame for input into glm#
	df <- as.data.frame(X)#
	feature_names <- colnames(df)#
	df <- cbind(df,y)#
	# create formula#
	formula_str <- "y~"#
	f1 <- feature_names[1]#
	formula_str <- paste(formula_str, f1, sep="")#
	for (i in 2:n) {#
		f_name <- feature_names[i]#
		formula_str <- paste(formula_str, "+", f_name, sep="")#
	}#
	formula <- as.formula(formula_str)#
	# perform glm#
	logreg_fit <- glm(formula, family=binomial, data=df)#
	return(logreg_fit)#
}#
#
analyze_log_reg_output <- function(X, y, classifier_outs, factor_names) {#
# X is mxn matrix where m describes samples and n describes miRNAs#
	m <- nrow(X)#
	n <- ncol(X)#
	if (m != length(classifier_outs)) {#
		stop("# of classifier outputs not equal to # of samples")#
	}#
	# convert y to vector of positives (true) and negatives (false)#
	y_positive <- y == factor_names[1]#
	coef_mat <- matrix( , nrow=m, ncol=n)#
	# vector of output result compared to actual label#
	# key:#
	# tp - true positive#
	# fp - false positive#
	# tn - true negative#
	# fn - false negative#
	out <- vector(mode="character", length=m)#
	for (i in 1:m) {#
		data_vec <- X[i, ]#
		df_elem <- data.frame(t(data_vec))#
		glm.prob <- predict(classifier_outs[[i]], newdata=df_elem, type="response")#
		print(str(classifier_outs[[i]]))#
		coef_mat[i,] = coef(classifier_outs[[i]])#
		positive <- TRUE#
		if (glm.prob > .5) {#
			positive <- FALSE#
		}#
		if (positive) {#
			if (y_positive[i]) {#
				out[i] <- "tp"#
			} else {#
				out[i] <- "fp"#
			}#
		} else {#
			if (y_positive[i]) {#
				out[i] <- "fn"#
			} else {#
				out[i] <- "tn"#
			}#
		}#
	}#
	coef_avg <- apply(coef_mat, 2, mean)#
	return(list(out, coef_avg))#
}
# Perform logistic regression#
# Load the following...#
# 	quantile_norm_data#
#	sample_factors#
#
factor_names <- c("viral", "bacterial")#
factors <- list(c("v_s", "v_as"), "bc")#
#
m <- nrow(quantile_norm_data)#
row_names <- vector(mode="character", length=m)#
for (i in 1:m) {#
	row_names[i] <- paste("s", i, sep="")#
}#
rownames(quantile_norm_data) <- row_names#
#
data <- quantile_norm_data[c(19, 20, 32, 86, 93, 111, 141, 165, 191, 199, 200, 201, 209, 211, 329), ]#
output <- do_log_reg(data, factors, factor_names, sample_factors)#
#
do_log_reg <- function(data, factors, factor_names, factor_vec) {#
# perform logistic regression w/ all but one sample as training set#
# data is mxn matrix with m descrbing miRNAs, n describing samples#
# Make sure data rows are labeled with names#
	create_X_and_y <- dget("R_Code/Classifiers/create_X_and_y.R")#
	X_and_y <- create_X_and_y(data, factors, factor_names, factor_vec)#
	X <- X_and_y[[1]]#
	y <- X_and_y[[2]]#
	# X is mxn where m describes samples and n describes miRNAs#
	m <- nrow(X)#
	n <- ncol(X)#
#
	classify_one_out <- dget("R_Code/Classifiers/classify_one_out.R")#
	classifier_outs <- classify_one_out(X, y, logistic_regression)#
#
	out <- analyze_log_reg_output(X, y, classifier_outs, factor_names)#
	return(out)#
}#
#
logistic_regression <- function(X, y) {#
# Perform logistic regression on matrix X with categories specified in y#
# X is mxn where m is the # of samples, n is the # of miRNAs#
# X must have column names to specify which miRNAs are in the data#
# y must only have two categories#
# output is output of glm function (logistic regression)#
	m <- nrow(X)#
	n <- ncol(X)#
	# format data frame for input into glm#
	df <- as.data.frame(X)#
	feature_names <- colnames(df)#
	df <- cbind(df,y)#
	# create formula#
	formula_str <- "y~"#
	f1 <- feature_names[1]#
	formula_str <- paste(formula_str, f1, sep="")#
	for (i in 2:n) {#
		f_name <- feature_names[i]#
		formula_str <- paste(formula_str, "+", f_name, sep="")#
	}#
	formula <- as.formula(formula_str)#
	# perform glm#
	logreg_fit <- glm(formula, family=binomial, data=df)#
	return(logreg_fit)#
}#
#
analyze_log_reg_output <- function(X, y, classifier_outs, factor_names) {#
# X is mxn matrix where m describes samples and n describes miRNAs#
	m <- nrow(X)#
	n <- ncol(X)#
	if (m != length(classifier_outs)) {#
		stop("# of classifier outputs not equal to # of samples")#
	}#
	# convert y to vector of positives (true) and negatives (false)#
	y_positive <- y == factor_names[1]#
	coef_mat <- matrix( , nrow=m, ncol=n)#
	# vector of output result compared to actual label#
	# key:#
	# tp - true positive#
	# fp - false positive#
	# tn - true negative#
	# fn - false negative#
	out <- vector(mode="character", length=m)#
	for (i in 1:m) {#
		data_vec <- X[i, ]#
		df_elem <- data.frame(t(data_vec))#
		glm.prob <- predict(classifier_outs[[i]], newdata=df_elem, type="response")#
		coef_mat[i,] = coef(classifier_outs[[i]])$coefficients#
		positive <- TRUE#
		if (glm.prob > .5) {#
			positive <- FALSE#
		}#
		if (positive) {#
			if (y_positive[i]) {#
				out[i] <- "tp"#
			} else {#
				out[i] <- "fp"#
			}#
		} else {#
			if (y_positive[i]) {#
				out[i] <- "fn"#
			} else {#
				out[i] <- "tn"#
			}#
		}#
	}#
	coef_avg <- apply(coef_mat, 2, mean)#
	return(list(out, coef_avg))#
}
# Perform logistic regression#
# Load the following...#
# 	quantile_norm_data#
#	sample_factors#
#
factor_names <- c("viral", "bacterial")#
factors <- list(c("v_s", "v_as"), "bc")#
#
m <- nrow(quantile_norm_data)#
row_names <- vector(mode="character", length=m)#
for (i in 1:m) {#
	row_names[i] <- paste("s", i, sep="")#
}#
rownames(quantile_norm_data) <- row_names#
#
data <- quantile_norm_data[c(19, 20, 32, 86, 93, 111, 141, 165, 191, 199, 200, 201, 209, 211, 329), ]#
output <- do_log_reg(data, factors, factor_names, sample_factors)#
#
do_log_reg <- function(data, factors, factor_names, factor_vec) {#
# perform logistic regression w/ all but one sample as training set#
# data is mxn matrix with m descrbing miRNAs, n describing samples#
# Make sure data rows are labeled with names#
	create_X_and_y <- dget("R_Code/Classifiers/create_X_and_y.R")#
	X_and_y <- create_X_and_y(data, factors, factor_names, factor_vec)#
	X <- X_and_y[[1]]#
	y <- X_and_y[[2]]#
	# X is mxn where m describes samples and n describes miRNAs#
	m <- nrow(X)#
	n <- ncol(X)#
#
	classify_one_out <- dget("R_Code/Classifiers/classify_one_out.R")#
	classifier_outs <- classify_one_out(X, y, logistic_regression)#
#
	out <- analyze_log_reg_output(X, y, classifier_outs, factor_names)#
	return(out)#
}#
#
logistic_regression <- function(X, y) {#
# Perform logistic regression on matrix X with categories specified in y#
# X is mxn where m is the # of samples, n is the # of miRNAs#
# X must have column names to specify which miRNAs are in the data#
# y must only have two categories#
# output is output of glm function (logistic regression)#
	m <- nrow(X)#
	n <- ncol(X)#
	# format data frame for input into glm#
	df <- as.data.frame(X)#
	feature_names <- colnames(df)#
	df <- cbind(df,y)#
	# create formula#
	formula_str <- "y~"#
	f1 <- feature_names[1]#
	formula_str <- paste(formula_str, f1, sep="")#
	for (i in 2:n) {#
		f_name <- feature_names[i]#
		formula_str <- paste(formula_str, "+", f_name, sep="")#
	}#
	formula <- as.formula(formula_str)#
	# perform glm#
	logreg_fit <- glm(formula, family=binomial, data=df)#
	return(logreg_fit)#
}#
#
analyze_log_reg_output <- function(X, y, classifier_outs, factor_names) {#
# X is mxn matrix where m describes samples and n describes miRNAs#
	m <- nrow(X)#
	n <- ncol(X)#
	if (m != length(classifier_outs)) {#
		stop("# of classifier outputs not equal to # of samples")#
	}#
	# convert y to vector of positives (true) and negatives (false)#
	y_positive <- y == factor_names[1]#
	coef_mat <- matrix( , nrow=m, ncol=n)#
	# vector of output result compared to actual label#
	# key:#
	# tp - true positive#
	# fp - false positive#
	# tn - true negative#
	# fn - false negative#
	out <- vector(mode="character", length=m)#
	for (i in 1:m) {#
		data_vec <- X[i, ]#
		df_elem <- data.frame(t(data_vec))#
		glm.prob <- predict(classifier_outs[[i]], newdata=df_elem, type="response")#
		coef_mat[i,] = summary(classifier_outs[[i]])$coefficients#
		positive <- TRUE#
		if (glm.prob > .5) {#
			positive <- FALSE#
		}#
		if (positive) {#
			if (y_positive[i]) {#
				out[i] <- "tp"#
			} else {#
				out[i] <- "fp"#
			}#
		} else {#
			if (y_positive[i]) {#
				out[i] <- "fn"#
			} else {#
				out[i] <- "tn"#
			}#
		}#
	}#
	coef_avg <- apply(coef_mat, 2, mean)#
	return(list(out, coef_avg))#
}
# Perform logistic regression#
# Load the following...#
# 	quantile_norm_data#
#	sample_factors#
#
factor_names <- c("viral", "bacterial")#
factors <- list(c("v_s", "v_as"), "bc")#
#
m <- nrow(quantile_norm_data)#
row_names <- vector(mode="character", length=m)#
for (i in 1:m) {#
	row_names[i] <- paste("s", i, sep="")#
}#
rownames(quantile_norm_data) <- row_names#
#
data <- quantile_norm_data[c(19, 20, 32, 86, 93, 111, 141, 165, 191, 199, 200, 201, 209, 211, 329), ]#
output <- do_log_reg(data, factors, factor_names, sample_factors)#
#
do_log_reg <- function(data, factors, factor_names, factor_vec) {#
# perform logistic regression w/ all but one sample as training set#
# data is mxn matrix with m descrbing miRNAs, n describing samples#
# Make sure data rows are labeled with names#
	create_X_and_y <- dget("R_Code/Classifiers/create_X_and_y.R")#
	X_and_y <- create_X_and_y(data, factors, factor_names, factor_vec)#
	X <- X_and_y[[1]]#
	y <- X_and_y[[2]]#
	# X is mxn where m describes samples and n describes miRNAs#
	m <- nrow(X)#
	n <- ncol(X)#
#
	classify_one_out <- dget("R_Code/Classifiers/classify_one_out.R")#
	classifier_outs <- classify_one_out(X, y, logistic_regression)#
#
	out <- analyze_log_reg_output(X, y, classifier_outs, factor_names)#
	return(out)#
}#
#
logistic_regression <- function(X, y) {#
# Perform logistic regression on matrix X with categories specified in y#
# X is mxn where m is the # of samples, n is the # of miRNAs#
# X must have column names to specify which miRNAs are in the data#
# y must only have two categories#
# output is output of glm function (logistic regression)#
	m <- nrow(X)#
	n <- ncol(X)#
	# format data frame for input into glm#
	df <- as.data.frame(X)#
	feature_names <- colnames(df)#
	df <- cbind(df,y)#
	# create formula#
	formula_str <- "y~"#
	f1 <- feature_names[1]#
	formula_str <- paste(formula_str, f1, sep="")#
	for (i in 2:n) {#
		f_name <- feature_names[i]#
		formula_str <- paste(formula_str, "+", f_name, sep="")#
	}#
	formula <- as.formula(formula_str)#
	# perform glm#
	logreg_fit <- glm(formula, family=binomial, data=df)#
	return(logreg_fit)#
}#
#
analyze_log_reg_output <- function(X, y, classifier_outs, factor_names) {#
# X is mxn matrix where m describes samples and n describes miRNAs#
	m <- nrow(X)#
	n <- ncol(X)#
	if (m != length(classifier_outs)) {#
		stop("# of classifier outputs not equal to # of samples")#
	}#
	# convert y to vector of positives (true) and negatives (false)#
	y_positive <- y == factor_names[1]#
	coef_mat <- matrix( , nrow=m, ncol=n+1)#
	# vector of output result compared to actual label#
	# key:#
	# tp - true positive#
	# fp - false positive#
	# tn - true negative#
	# fn - false negative#
	out <- vector(mode="character", length=m)#
	for (i in 1:m) {#
		data_vec <- X[i, ]#
		df_elem <- data.frame(t(data_vec))#
		glm.prob <- predict(classifier_outs[[i]], newdata=df_elem, type="response")#
		coef_mat[i,] = summary(classifier_outs[[i]])$coefficients#
		positive <- TRUE#
		if (glm.prob > .5) {#
			positive <- FALSE#
		}#
		if (positive) {#
			if (y_positive[i]) {#
				out[i] <- "tp"#
			} else {#
				out[i] <- "fp"#
			}#
		} else {#
			if (y_positive[i]) {#
				out[i] <- "fn"#
			} else {#
				out[i] <- "tn"#
			}#
		}#
	}#
	coef_avg <- apply(coef_mat, 2, mean)#
	return(list(out, coef_avg))#
}
# Perform logistic regression#
# Load the following...#
# 	quantile_norm_data#
#	sample_factors#
#
factor_names <- c("viral", "bacterial")#
factors <- list(c("v_s", "v_as"), "bc")#
#
m <- nrow(quantile_norm_data)#
row_names <- vector(mode="character", length=m)#
for (i in 1:m) {#
	row_names[i] <- paste("s", i, sep="")#
}#
rownames(quantile_norm_data) <- row_names#
#
data <- quantile_norm_data[c(19, 20, 32, 86, 93, 111, 141, 165, 191, 199, 200, 201, 209, 211, 329), ]#
output <- do_log_reg(data, factors, factor_names, sample_factors)#
#
do_log_reg <- function(data, factors, factor_names, factor_vec) {#
# perform logistic regression w/ all but one sample as training set#
# data is mxn matrix with m descrbing miRNAs, n describing samples#
# Make sure data rows are labeled with names#
	create_X_and_y <- dget("R_Code/Classifiers/create_X_and_y.R")#
	X_and_y <- create_X_and_y(data, factors, factor_names, factor_vec)#
	X <- X_and_y[[1]]#
	y <- X_and_y[[2]]#
	# X is mxn where m describes samples and n describes miRNAs#
	m <- nrow(X)#
	n <- ncol(X)#
#
	classify_one_out <- dget("R_Code/Classifiers/classify_one_out.R")#
	classifier_outs <- classify_one_out(X, y, logistic_regression)#
#
	out <- analyze_log_reg_output(X, y, classifier_outs, factor_names)#
	return(out)#
}#
#
logistic_regression <- function(X, y) {#
# Perform logistic regression on matrix X with categories specified in y#
# X is mxn where m is the # of samples, n is the # of miRNAs#
# X must have column names to specify which miRNAs are in the data#
# y must only have two categories#
# output is output of glm function (logistic regression)#
	m <- nrow(X)#
	n <- ncol(X)#
	# format data frame for input into glm#
	df <- as.data.frame(X)#
	feature_names <- colnames(df)#
	df <- cbind(df,y)#
	# create formula#
	formula_str <- "y~"#
	f1 <- feature_names[1]#
	formula_str <- paste(formula_str, f1, sep="")#
	for (i in 2:n) {#
		f_name <- feature_names[i]#
		formula_str <- paste(formula_str, "+", f_name, sep="")#
	}#
	formula <- as.formula(formula_str)#
	# perform glm#
	logreg_fit <- glm(formula, family=binomial, data=df)#
	return(logreg_fit)#
}#
#
analyze_log_reg_output <- function(X, y, classifier_outs, factor_names) {#
# X is mxn matrix where m describes samples and n describes miRNAs#
	m <- nrow(X)#
	n <- ncol(X)#
	if (m != length(classifier_outs)) {#
		stop("# of classifier outputs not equal to # of samples")#
	}#
	# convert y to vector of positives (true) and negatives (false)#
	y_positive <- y == factor_names[1]#
	coef_mat <- matrix( , nrow=m, ncol=n+1)#
	print(dim(coef_mat))#
	# vector of output result compared to actual label#
	# key:#
	# tp - true positive#
	# fp - false positive#
	# tn - true negative#
	# fn - false negative#
	out <- vector(mode="character", length=m)#
	for (i in 1:m) {#
		data_vec <- X[i, ]#
		df_elem <- data.frame(t(data_vec))#
		glm.prob <- predict(classifier_outs[[i]], newdata=df_elem, type="response")#
		coef_mat[i,] = summary(classifier_outs[[i]])$coefficients#
		positive <- TRUE#
		if (glm.prob > .5) {#
			positive <- FALSE#
		}#
		if (positive) {#
			if (y_positive[i]) {#
				out[i] <- "tp"#
			} else {#
				out[i] <- "fp"#
			}#
		} else {#
			if (y_positive[i]) {#
				out[i] <- "fn"#
			} else {#
				out[i] <- "tn"#
			}#
		}#
	}#
	coef_avg <- apply(coef_mat, 2, mean)#
	return(list(out, coef_avg))#
}
# Perform logistic regression#
# Load the following...#
# 	quantile_norm_data#
#	sample_factors#
#
factor_names <- c("viral", "bacterial")#
factors <- list(c("v_s", "v_as"), "bc")#
#
m <- nrow(quantile_norm_data)#
row_names <- vector(mode="character", length=m)#
for (i in 1:m) {#
	row_names[i] <- paste("s", i, sep="")#
}#
rownames(quantile_norm_data) <- row_names#
#
data <- quantile_norm_data[c(19, 20, 32, 86, 93, 111, 141, 165, 191, 199, 200, 201, 209, 211, 329), ]#
output <- do_log_reg(data, factors, factor_names, sample_factors)#
#
do_log_reg <- function(data, factors, factor_names, factor_vec) {#
# perform logistic regression w/ all but one sample as training set#
# data is mxn matrix with m descrbing miRNAs, n describing samples#
# Make sure data rows are labeled with names#
	create_X_and_y <- dget("R_Code/Classifiers/create_X_and_y.R")#
	X_and_y <- create_X_and_y(data, factors, factor_names, factor_vec)#
	X <- X_and_y[[1]]#
	y <- X_and_y[[2]]#
	# X is mxn where m describes samples and n describes miRNAs#
	m <- nrow(X)#
	n <- ncol(X)#
#
	classify_one_out <- dget("R_Code/Classifiers/classify_one_out.R")#
	classifier_outs <- classify_one_out(X, y, logistic_regression)#
#
	out <- analyze_log_reg_output(X, y, classifier_outs, factor_names)#
	return(out)#
}#
#
logistic_regression <- function(X, y) {#
# Perform logistic regression on matrix X with categories specified in y#
# X is mxn where m is the # of samples, n is the # of miRNAs#
# X must have column names to specify which miRNAs are in the data#
# y must only have two categories#
# output is output of glm function (logistic regression)#
	m <- nrow(X)#
	n <- ncol(X)#
	# format data frame for input into glm#
	df <- as.data.frame(X)#
	feature_names <- colnames(df)#
	df <- cbind(df,y)#
	# create formula#
	formula_str <- "y~"#
	f1 <- feature_names[1]#
	formula_str <- paste(formula_str, f1, sep="")#
	for (i in 2:n) {#
		f_name <- feature_names[i]#
		formula_str <- paste(formula_str, "+", f_name, sep="")#
	}#
	formula <- as.formula(formula_str)#
	# perform glm#
	logreg_fit <- glm(formula, family=binomial, data=df)#
	return(logreg_fit)#
}#
#
analyze_log_reg_output <- function(X, y, classifier_outs, factor_names) {#
# X is mxn matrix where m describes samples and n describes miRNAs#
	m <- nrow(X)#
	n <- ncol(X)#
	if (m != length(classifier_outs)) {#
		stop("# of classifier outputs not equal to # of samples")#
	}#
	# convert y to vector of positives (true) and negatives (false)#
	y_positive <- y == factor_names[1]#
	coef_mat <- matrix( , nrow=m, ncol=n+1)#
	print(dim(coef_mat))#
	# vector of output result compared to actual label#
	# key:#
	# tp - true positive#
	# fp - false positive#
	# tn - true negative#
	# fn - false negative#
	out <- vector(mode="character", length=m)#
	for (i in 1:m) {#
		data_vec <- X[i, ]#
		df_elem <- data.frame(t(data_vec))#
		glm.prob <- predict(classifier_outs[[i]], newdata=df_elem, type="response")#
		print(summary(classifier_outs[[i]])$coefficients)#
		coef_mat[i,] = summary(classifier_outs[[i]])$coefficients#
		positive <- TRUE#
		if (glm.prob > .5) {#
			positive <- FALSE#
		}#
		if (positive) {#
			if (y_positive[i]) {#
				out[i] <- "tp"#
			} else {#
				out[i] <- "fp"#
			}#
		} else {#
			if (y_positive[i]) {#
				out[i] <- "fn"#
			} else {#
				out[i] <- "tn"#
			}#
		}#
	}#
	coef_avg <- apply(coef_mat, 2, mean)#
	return(list(out, coef_avg))#
}
# Perform logistic regression#
# Load the following...#
# 	quantile_norm_data#
#	sample_factors#
#
factor_names <- c("viral", "bacterial")#
factors <- list(c("v_s", "v_as"), "bc")#
#
m <- nrow(quantile_norm_data)#
row_names <- vector(mode="character", length=m)#
for (i in 1:m) {#
	row_names[i] <- paste("s", i, sep="")#
}#
rownames(quantile_norm_data) <- row_names#
#
data <- quantile_norm_data[c(19, 20, 32, 86, 93, 111, 141, 165, 191, 199, 200, 201, 209, 211, 329), ]#
output <- do_log_reg(data, factors, factor_names, sample_factors)#
#
do_log_reg <- function(data, factors, factor_names, factor_vec) {#
# perform logistic regression w/ all but one sample as training set#
# data is mxn matrix with m descrbing miRNAs, n describing samples#
# Make sure data rows are labeled with names#
	create_X_and_y <- dget("R_Code/Classifiers/create_X_and_y.R")#
	X_and_y <- create_X_and_y(data, factors, factor_names, factor_vec)#
	X <- X_and_y[[1]]#
	y <- X_and_y[[2]]#
	# X is mxn where m describes samples and n describes miRNAs#
	m <- nrow(X)#
	n <- ncol(X)#
#
	classify_one_out <- dget("R_Code/Classifiers/classify_one_out.R")#
	classifier_outs <- classify_one_out(X, y, logistic_regression)#
#
	out <- analyze_log_reg_output(X, y, classifier_outs, factor_names)#
	return(out)#
}#
#
logistic_regression <- function(X, y) {#
# Perform logistic regression on matrix X with categories specified in y#
# X is mxn where m is the # of samples, n is the # of miRNAs#
# X must have column names to specify which miRNAs are in the data#
# y must only have two categories#
# output is output of glm function (logistic regression)#
	m <- nrow(X)#
	n <- ncol(X)#
	# format data frame for input into glm#
	df <- as.data.frame(X)#
	feature_names <- colnames(df)#
	df <- cbind(df,y)#
	# create formula#
	formula_str <- "y~"#
	f1 <- feature_names[1]#
	formula_str <- paste(formula_str, f1, sep="")#
	for (i in 2:n) {#
		f_name <- feature_names[i]#
		formula_str <- paste(formula_str, "+", f_name, sep="")#
	}#
	formula <- as.formula(formula_str)#
	# perform glm#
	logreg_fit <- glm(formula, family=binomial, data=df)#
	return(logreg_fit)#
}#
#
analyze_log_reg_output <- function(X, y, classifier_outs, factor_names) {#
# X is mxn matrix where m describes samples and n describes miRNAs#
	m <- nrow(X)#
	n <- ncol(X)#
	if (m != length(classifier_outs)) {#
		stop("# of classifier outputs not equal to # of samples")#
	}#
	# convert y to vector of positives (true) and negatives (false)#
	y_positive <- y == factor_names[1]#
	coef_mat <- matrix( , nrow=m, ncol=n+1)#
	print(dim(coef_mat))#
	# vector of output result compared to actual label#
	# key:#
	# tp - true positive#
	# fp - false positive#
	# tn - true negative#
	# fn - false negative#
	out <- vector(mode="character", length=m)#
	for (i in 1:m) {#
		data_vec <- X[i, ]#
		df_elem <- data.frame(t(data_vec))#
		glm.prob <- predict(classifier_outs[[i]], newdata=df_elem, type="response")#
		print(summary(classifier_outs[[i]])$coefficients)#
		coef_mat[i,] = summary(classifier_outs[[i]])$coefficients$Estimate#
		positive <- TRUE#
		if (glm.prob > .5) {#
			positive <- FALSE#
		}#
		if (positive) {#
			if (y_positive[i]) {#
				out[i] <- "tp"#
			} else {#
				out[i] <- "fp"#
			}#
		} else {#
			if (y_positive[i]) {#
				out[i] <- "fn"#
			} else {#
				out[i] <- "tn"#
			}#
		}#
	}#
	coef_avg <- apply(coef_mat, 2, mean)#
	return(list(out, coef_avg))#
}
# Perform logistic regression#
# Load the following...#
# 	quantile_norm_data#
#	sample_factors#
#
factor_names <- c("viral", "bacterial")#
factors <- list(c("v_s", "v_as"), "bc")#
#
m <- nrow(quantile_norm_data)#
row_names <- vector(mode="character", length=m)#
for (i in 1:m) {#
	row_names[i] <- paste("s", i, sep="")#
}#
rownames(quantile_norm_data) <- row_names#
#
data <- quantile_norm_data[c(19, 20, 32, 86, 93, 111, 141, 165, 191, 199, 200, 201, 209, 211, 329), ]#
output <- do_log_reg(data, factors, factor_names, sample_factors)#
#
do_log_reg <- function(data, factors, factor_names, factor_vec) {#
# perform logistic regression w/ all but one sample as training set#
# data is mxn matrix with m descrbing miRNAs, n describing samples#
# Make sure data rows are labeled with names#
	create_X_and_y <- dget("R_Code/Classifiers/create_X_and_y.R")#
	X_and_y <- create_X_and_y(data, factors, factor_names, factor_vec)#
	X <- X_and_y[[1]]#
	y <- X_and_y[[2]]#
	# X is mxn where m describes samples and n describes miRNAs#
	m <- nrow(X)#
	n <- ncol(X)#
#
	classify_one_out <- dget("R_Code/Classifiers/classify_one_out.R")#
	classifier_outs <- classify_one_out(X, y, logistic_regression)#
#
	out <- analyze_log_reg_output(X, y, classifier_outs, factor_names)#
	return(out)#
}#
#
logistic_regression <- function(X, y) {#
# Perform logistic regression on matrix X with categories specified in y#
# X is mxn where m is the # of samples, n is the # of miRNAs#
# X must have column names to specify which miRNAs are in the data#
# y must only have two categories#
# output is output of glm function (logistic regression)#
	m <- nrow(X)#
	n <- ncol(X)#
	# format data frame for input into glm#
	df <- as.data.frame(X)#
	feature_names <- colnames(df)#
	df <- cbind(df,y)#
	# create formula#
	formula_str <- "y~"#
	f1 <- feature_names[1]#
	formula_str <- paste(formula_str, f1, sep="")#
	for (i in 2:n) {#
		f_name <- feature_names[i]#
		formula_str <- paste(formula_str, "+", f_name, sep="")#
	}#
	formula <- as.formula(formula_str)#
	# perform glm#
	logreg_fit <- glm(formula, family=binomial, data=df)#
	return(logreg_fit)#
}#
#
analyze_log_reg_output <- function(X, y, classifier_outs, factor_names) {#
# X is mxn matrix where m describes samples and n describes miRNAs#
	m <- nrow(X)#
	n <- ncol(X)#
	if (m != length(classifier_outs)) {#
		stop("# of classifier outputs not equal to # of samples")#
	}#
	# convert y to vector of positives (true) and negatives (false)#
	y_positive <- y == factor_names[1]#
	coef_mat <- matrix( , nrow=m, ncol=n+1)#
	print(dim(coef_mat))#
	# vector of output result compared to actual label#
	# key:#
	# tp - true positive#
	# fp - false positive#
	# tn - true negative#
	# fn - false negative#
	out <- vector(mode="character", length=m)#
	for (i in 1:m) {#
		data_vec <- X[i, ]#
		df_elem <- data.frame(t(data_vec))#
		glm.prob <- predict(classifier_outs[[i]], newdata=df_elem, type="response")#
		print(str(summary(classifier_outs[[i]])$coefficients)#
		coef_mat[i,] = summary(classifier_outs[[i]])$coefficients$Estimate#
		positive <- TRUE#
		if (glm.prob > .5) {#
			positive <- FALSE#
		}#
		if (positive) {#
			if (y_positive[i]) {#
				out[i] <- "tp"#
			} else {#
				out[i] <- "fp"#
			}#
		} else {#
			if (y_positive[i]) {#
				out[i] <- "fn"#
			} else {#
				out[i] <- "tn"#
			}#
		}#
	}#
	coef_avg <- apply(coef_mat, 2, mean)#
	return(list(out, coef_avg))#
}
# Perform logistic regression#
# Load the following...#
# 	quantile_norm_data#
#	sample_factors#
#
factor_names <- c("viral", "bacterial")#
factors <- list(c("v_s", "v_as"), "bc")#
#
m <- nrow(quantile_norm_data)#
row_names <- vector(mode="character", length=m)#
for (i in 1:m) {#
	row_names[i] <- paste("s", i, sep="")#
}#
rownames(quantile_norm_data) <- row_names#
#
data <- quantile_norm_data[c(19, 20, 32, 86, 93, 111, 141, 165, 191, 199, 200, 201, 209, 211, 329), ]#
output <- do_log_reg(data, factors, factor_names, sample_factors)#
#
do_log_reg <- function(data, factors, factor_names, factor_vec) {#
# perform logistic regression w/ all but one sample as training set#
# data is mxn matrix with m descrbing miRNAs, n describing samples#
# Make sure data rows are labeled with names#
	create_X_and_y <- dget("R_Code/Classifiers/create_X_and_y.R")#
	X_and_y <- create_X_and_y(data, factors, factor_names, factor_vec)#
	X <- X_and_y[[1]]#
	y <- X_and_y[[2]]#
	# X is mxn where m describes samples and n describes miRNAs#
	m <- nrow(X)#
	n <- ncol(X)#
#
	classify_one_out <- dget("R_Code/Classifiers/classify_one_out.R")#
	classifier_outs <- classify_one_out(X, y, logistic_regression)#
#
	out <- analyze_log_reg_output(X, y, classifier_outs, factor_names)#
	return(out)#
}#
#
logistic_regression <- function(X, y) {#
# Perform logistic regression on matrix X with categories specified in y#
# X is mxn where m is the # of samples, n is the # of miRNAs#
# X must have column names to specify which miRNAs are in the data#
# y must only have two categories#
# output is output of glm function (logistic regression)#
	m <- nrow(X)#
	n <- ncol(X)#
	# format data frame for input into glm#
	df <- as.data.frame(X)#
	feature_names <- colnames(df)#
	df <- cbind(df,y)#
	# create formula#
	formula_str <- "y~"#
	f1 <- feature_names[1]#
	formula_str <- paste(formula_str, f1, sep="")#
	for (i in 2:n) {#
		f_name <- feature_names[i]#
		formula_str <- paste(formula_str, "+", f_name, sep="")#
	}#
	formula <- as.formula(formula_str)#
	# perform glm#
	logreg_fit <- glm(formula, family=binomial, data=df)#
	return(logreg_fit)#
}#
#
analyze_log_reg_output <- function(X, y, classifier_outs, factor_names) {#
# X is mxn matrix where m describes samples and n describes miRNAs#
	m <- nrow(X)#
	n <- ncol(X)#
	if (m != length(classifier_outs)) {#
		stop("# of classifier outputs not equal to # of samples")#
	}#
	# convert y to vector of positives (true) and negatives (false)#
	y_positive <- y == factor_names[1]#
	coef_mat <- matrix( , nrow=m, ncol=n+1)#
	print(dim(coef_mat))#
	# vector of output result compared to actual label#
	# key:#
	# tp - true positive#
	# fp - false positive#
	# tn - true negative#
	# fn - false negative#
	out <- vector(mode="character", length=m)#
	for (i in 1:m) {#
		data_vec <- X[i, ]#
		df_elem <- data.frame(t(data_vec))#
		glm.prob <- predict(classifier_outs[[i]], newdata=df_elem, type="response")#
		print(str(summary(classifier_outs[[i]])$coefficients))#
		coef_mat[i,] = summary(classifier_outs[[i]])$coefficients$Estimate#
		positive <- TRUE#
		if (glm.prob > .5) {#
			positive <- FALSE#
		}#
		if (positive) {#
			if (y_positive[i]) {#
				out[i] <- "tp"#
			} else {#
				out[i] <- "fp"#
			}#
		} else {#
			if (y_positive[i]) {#
				out[i] <- "fn"#
			} else {#
				out[i] <- "tn"#
			}#
		}#
	}#
	coef_avg <- apply(coef_mat, 2, mean)#
	return(list(out, coef_avg))#
}
# Perform logistic regression#
# Load the following...#
# 	quantile_norm_data#
#	sample_factors#
#
factor_names <- c("viral", "bacterial")#
factors <- list(c("v_s", "v_as"), "bc")#
#
m <- nrow(quantile_norm_data)#
row_names <- vector(mode="character", length=m)#
for (i in 1:m) {#
	row_names[i] <- paste("s", i, sep="")#
}#
rownames(quantile_norm_data) <- row_names#
#
data <- quantile_norm_data[c(19, 20, 32, 86, 93, 111, 141, 165, 191, 199, 200, 201, 209, 211, 329), ]#
output <- do_log_reg(data, factors, factor_names, sample_factors)#
#
do_log_reg <- function(data, factors, factor_names, factor_vec) {#
# perform logistic regression w/ all but one sample as training set#
# data is mxn matrix with m descrbing miRNAs, n describing samples#
# Make sure data rows are labeled with names#
	create_X_and_y <- dget("R_Code/Classifiers/create_X_and_y.R")#
	X_and_y <- create_X_and_y(data, factors, factor_names, factor_vec)#
	X <- X_and_y[[1]]#
	y <- X_and_y[[2]]#
	# X is mxn where m describes samples and n describes miRNAs#
	m <- nrow(X)#
	n <- ncol(X)#
#
	classify_one_out <- dget("R_Code/Classifiers/classify_one_out.R")#
	classifier_outs <- classify_one_out(X, y, logistic_regression)#
#
	out <- analyze_log_reg_output(X, y, classifier_outs, factor_names)#
	return(out)#
}#
#
logistic_regression <- function(X, y) {#
# Perform logistic regression on matrix X with categories specified in y#
# X is mxn where m is the # of samples, n is the # of miRNAs#
# X must have column names to specify which miRNAs are in the data#
# y must only have two categories#
# output is output of glm function (logistic regression)#
	m <- nrow(X)#
	n <- ncol(X)#
	# format data frame for input into glm#
	df <- as.data.frame(X)#
	feature_names <- colnames(df)#
	df <- cbind(df,y)#
	# create formula#
	formula_str <- "y~"#
	f1 <- feature_names[1]#
	formula_str <- paste(formula_str, f1, sep="")#
	for (i in 2:n) {#
		f_name <- feature_names[i]#
		formula_str <- paste(formula_str, "+", f_name, sep="")#
	}#
	formula <- as.formula(formula_str)#
	# perform glm#
	logreg_fit <- glm(formula, family=binomial, data=df)#
	return(logreg_fit)#
}#
#
analyze_log_reg_output <- function(X, y, classifier_outs, factor_names) {#
# X is mxn matrix where m describes samples and n describes miRNAs#
	m <- nrow(X)#
	n <- ncol(X)#
	if (m != length(classifier_outs)) {#
		stop("# of classifier outputs not equal to # of samples")#
	}#
	# convert y to vector of positives (true) and negatives (false)#
	y_positive <- y == factor_names[1]#
	coef_mat <- matrix( , nrow=m, ncol=n+1)#
	print(dim(coef_mat))#
	# vector of output result compared to actual label#
	# key:#
	# tp - true positive#
	# fp - false positive#
	# tn - true negative#
	# fn - false negative#
	out <- vector(mode="character", length=m)#
	for (i in 1:m) {#
		data_vec <- X[i, ]#
		df_elem <- data.frame(t(data_vec))#
		glm.prob <- predict(classifier_outs[[i]], newdata=df_elem, type="response")#
		print(str(summary(classifier_outs[[i]])$coefficients))#
		coef_mat[i,] = summary(classifier_outs[[i]])$coefficients[,1]#
		positive <- TRUE#
		if (glm.prob > .5) {#
			positive <- FALSE#
		}#
		if (positive) {#
			if (y_positive[i]) {#
				out[i] <- "tp"#
			} else {#
				out[i] <- "fp"#
			}#
		} else {#
			if (y_positive[i]) {#
				out[i] <- "fn"#
			} else {#
				out[i] <- "tn"#
			}#
		}#
	}#
	coef_avg <- apply(coef_mat, 2, mean)#
	return(list(out, coef_avg))#
}
coef_mat <- matrix( , nrow=m, ncol=n)
# Perform logistic regression#
# Load the following...#
# 	quantile_norm_data#
#	sample_factors#
#
factor_names <- c("viral", "bacterial")#
factors <- list(c("v_s", "v_as"), "bc")#
#
m <- nrow(quantile_norm_data)#
row_names <- vector(mode="character", length=m)#
for (i in 1:m) {#
	row_names[i] <- paste("s", i, sep="")#
}#
rownames(quantile_norm_data) <- row_names#
#
data <- quantile_norm_data[c(19, 20, 32, 86, 93, 111, 141, 165, 191, 199, 200, 201, 209, 211, 329), ]#
output <- do_log_reg(data, factors, factor_names, sample_factors)#
#
do_log_reg <- function(data, factors, factor_names, factor_vec) {#
# perform logistic regression w/ all but one sample as training set#
# data is mxn matrix with m descrbing miRNAs, n describing samples#
# Make sure data rows are labeled with names#
	create_X_and_y <- dget("R_Code/Classifiers/create_X_and_y.R")#
	X_and_y <- create_X_and_y(data, factors, factor_names, factor_vec)#
	X <- X_and_y[[1]]#
	y <- X_and_y[[2]]#
	# X is mxn where m describes samples and n describes miRNAs#
	m <- nrow(X)#
	n <- ncol(X)#
#
	classify_one_out <- dget("R_Code/Classifiers/classify_one_out.R")#
	classifier_outs <- classify_one_out(X, y, logistic_regression)#
#
	out <- analyze_log_reg_output(X, y, classifier_outs, factor_names)#
	return(out)#
}#
#
logistic_regression <- function(X, y) {#
# Perform logistic regression on matrix X with categories specified in y#
# X is mxn where m is the # of samples, n is the # of miRNAs#
# X must have column names to specify which miRNAs are in the data#
# y must only have two categories#
# output is output of glm function (logistic regression)#
	m <- nrow(X)#
	n <- ncol(X)#
	# format data frame for input into glm#
	df <- as.data.frame(X)#
	feature_names <- colnames(df)#
	df <- cbind(df,y)#
	# create formula#
	formula_str <- "y~"#
	f1 <- feature_names[1]#
	formula_str <- paste(formula_str, f1, sep="")#
	for (i in 2:n) {#
		f_name <- feature_names[i]#
		formula_str <- paste(formula_str, "+", f_name, sep="")#
	}#
	formula <- as.formula(formula_str)#
	# perform glm#
	logreg_fit <- glm(formula, family=binomial, data=df)#
	return(logreg_fit)#
}#
#
analyze_log_reg_output <- function(X, y, classifier_outs, factor_names) {#
# X is mxn matrix where m describes samples and n describes miRNAs#
	m <- nrow(X)#
	n <- ncol(X)#
	if (m != length(classifier_outs)) {#
		stop("# of classifier outputs not equal to # of samples")#
	}#
	# convert y to vector of positives (true) and negatives (false)#
	y_positive <- y == factor_names[1]#
	coef_mat <- matrix( , nrow=m, ncol=n)#
	print(dim(coef_mat))#
	# vector of output result compared to actual label#
	# key:#
	# tp - true positive#
	# fp - false positive#
	# tn - true negative#
	# fn - false negative#
	out <- vector(mode="character", length=m)#
	for (i in 1:m) {#
		data_vec <- X[i, ]#
		df_elem <- data.frame(t(data_vec))#
		glm.prob <- predict(classifier_outs[[i]], newdata=df_elem, type="response")#
		print(str(summary(classifier_outs[[i]])$coefficients))#
		coef_mat[i,] = summary(classifier_outs[[i]])$coefficients[,1]#
		positive <- TRUE#
		if (glm.prob > .5) {#
			positive <- FALSE#
		}#
		if (positive) {#
			if (y_positive[i]) {#
				out[i] <- "tp"#
			} else {#
				out[i] <- "fp"#
			}#
		} else {#
			if (y_positive[i]) {#
				out[i] <- "fn"#
			} else {#
				out[i] <- "tn"#
			}#
		}#
	}#
	coef_avg <- apply(coef_mat, 2, mean)#
	return(list(out, coef_avg))#
}
# Perform logistic regression#
# Load the following...#
# 	quantile_norm_data#
#	sample_factors#
#
factor_names <- c("viral", "bacterial")#
factors <- list(c("v_s", "v_as"), "bc")#
#
m <- nrow(quantile_norm_data)#
row_names <- vector(mode="character", length=m)#
for (i in 1:m) {#
	row_names[i] <- paste("s", i, sep="")#
}#
rownames(quantile_norm_data) <- row_names#
#
data <- quantile_norm_data[c(19, 20, 32, 86, 93, 111, 141, 165, 191, 199, 200, 201, 209, 211, 329), ]#
output <- do_log_reg(data, factors, factor_names, sample_factors)#
#
do_log_reg <- function(data, factors, factor_names, factor_vec) {#
# perform logistic regression w/ all but one sample as training set#
# data is mxn matrix with m descrbing miRNAs, n describing samples#
# Make sure data rows are labeled with names#
	create_X_and_y <- dget("R_Code/Classifiers/create_X_and_y.R")#
	X_and_y <- create_X_and_y(data, factors, factor_names, factor_vec)#
	X <- X_and_y[[1]]#
	y <- X_and_y[[2]]#
	# X is mxn where m describes samples and n describes miRNAs#
	m <- nrow(X)#
	n <- ncol(X)#
#
	classify_one_out <- dget("R_Code/Classifiers/classify_one_out.R")#
	classifier_outs <- classify_one_out(X, y, logistic_regression)#
#
	out <- analyze_log_reg_output(X, y, classifier_outs, factor_names)#
	return(out)#
}#
#
logistic_regression <- function(X, y) {#
# Perform logistic regression on matrix X with categories specified in y#
# X is mxn where m is the # of samples, n is the # of miRNAs#
# X must have column names to specify which miRNAs are in the data#
# y must only have two categories#
# output is output of glm function (logistic regression)#
	m <- nrow(X)#
	n <- ncol(X)#
	# format data frame for input into glm#
	df <- as.data.frame(X)#
	feature_names <- colnames(df)#
	df <- cbind(df,y)#
	# create formula#
	formula_str <- "y~"#
	f1 <- feature_names[1]#
	formula_str <- paste(formula_str, f1, sep="")#
	for (i in 2:n) {#
		f_name <- feature_names[i]#
		formula_str <- paste(formula_str, "+", f_name, sep="")#
	}#
	formula <- as.formula(formula_str)#
	# perform glm#
	logreg_fit <- glm(formula, family=binomial, data=df)#
	return(logreg_fit)#
}#
#
analyze_log_reg_output <- function(X, y, classifier_outs, factor_names) {#
# X is mxn matrix where m describes samples and n describes miRNAs#
	m <- nrow(X)#
	n <- ncol(X)#
	if (m != length(classifier_outs)) {#
		stop("# of classifier outputs not equal to # of samples")#
	}#
	# convert y to vector of positives (true) and negatives (false)#
	y_positive <- y == factor_names[1]#
	coef_mat <- matrix( , nrow=m, ncol=n)#
	print(dim(coef_mat))#
	# vector of output result compared to actual label#
	# key:#
	# tp - true positive#
	# fp - false positive#
	# tn - true negative#
	# fn - false negative#
	out <- vector(mode="character", length=m)#
	print(length(classifier_outs))#
	for (i in 1:m) {#
		data_vec <- X[i, ]#
		df_elem <- data.frame(t(data_vec))#
		glm.prob <- predict(classifier_outs[[i]], newdata=df_elem, type="response")#
		print(str(summary(classifier_outs[[i]])$coefficients))#
		coef_mat[i,] = summary(classifier_outs[[i]])$coefficients[,1]#
		positive <- TRUE#
		if (glm.prob > .5) {#
			positive <- FALSE#
		}#
		if (positive) {#
			if (y_positive[i]) {#
				out[i] <- "tp"#
			} else {#
				out[i] <- "fp"#
			}#
		} else {#
			if (y_positive[i]) {#
				out[i] <- "fn"#
			} else {#
				out[i] <- "tn"#
			}#
		}#
	}#
	coef_avg <- apply(coef_mat, 2, mean)#
	return(list(out, coef_avg))#
}
# Perform logistic regression#
# Load the following...#
# 	quantile_norm_data#
#	sample_factors#
#
factor_names <- c("viral", "bacterial")#
factors <- list(c("v_s", "v_as"), "bc")#
#
m <- nrow(quantile_norm_data)#
row_names <- vector(mode="character", length=m)#
for (i in 1:m) {#
	row_names[i] <- paste("s", i, sep="")#
}#
rownames(quantile_norm_data) <- row_names#
#
data <- quantile_norm_data[c(19, 20, 32, 86, 93, 111, 141, 165, 191, 199, 200, 201, 209, 211, 329), ]#
output <- do_log_reg(data, factors, factor_names, sample_factors)#
#
do_log_reg <- function(data, factors, factor_names, factor_vec) {#
# perform logistic regression w/ all but one sample as training set#
# data is mxn matrix with m descrbing miRNAs, n describing samples#
# Make sure data rows are labeled with names#
	create_X_and_y <- dget("R_Code/Classifiers/create_X_and_y.R")#
	X_and_y <- create_X_and_y(data, factors, factor_names, factor_vec)#
	X <- X_and_y[[1]]#
	y <- X_and_y[[2]]#
	# X is mxn where m describes samples and n describes miRNAs#
	m <- nrow(X)#
	n <- ncol(X)#
#
	classify_one_out <- dget("R_Code/Classifiers/classify_one_out.R")#
	classifier_outs <- classify_one_out(X, y, logistic_regression)#
#
	out <- analyze_log_reg_output(X, y, classifier_outs, factor_names)#
	return(out)#
}#
#
logistic_regression <- function(X, y) {#
# Perform logistic regression on matrix X with categories specified in y#
# X is mxn where m is the # of samples, n is the # of miRNAs#
# X must have column names to specify which miRNAs are in the data#
# y must only have two categories#
# output is output of glm function (logistic regression)#
	m <- nrow(X)#
	n <- ncol(X)#
	# format data frame for input into glm#
	df <- as.data.frame(X)#
	feature_names <- colnames(df)#
	df <- cbind(df,y)#
	# create formula#
	formula_str <- "y~"#
	f1 <- feature_names[1]#
	formula_str <- paste(formula_str, f1, sep="")#
	for (i in 2:n) {#
		f_name <- feature_names[i]#
		formula_str <- paste(formula_str, "+", f_name, sep="")#
	}#
	formula <- as.formula(formula_str)#
	# perform glm#
	logreg_fit <- glm(formula, family=binomial, data=df)#
	return(logreg_fit)#
}#
#
analyze_log_reg_output <- function(X, y, classifier_outs, factor_names) {#
# X is mxn matrix where m describes samples and n describes miRNAs#
	m <- nrow(X)#
	n <- ncol(X)#
	if (m != length(classifier_outs)) {#
		stop("# of classifier outputs not equal to # of samples")#
	}#
	# convert y to vector of positives (true) and negatives (false)#
	y_positive <- y == factor_names[1]#
	coef_mat <- matrix( , nrow=m, ncol=n)#
	# vector of output result compared to actual label#
	# key:#
	# tp - true positive#
	# fp - false positive#
	# tn - true negative#
	# fn - false negative#
	out <- vector(mode="character", length=m)#
	for (i in 1:m) {#
		print(i)#
		data_vec <- X[i, ]#
		df_elem <- data.frame(t(data_vec))#
		glm.prob <- predict(classifier_outs[[i]], newdata=df_elem, type="response")#
		coef_mat[i,] = summary(classifier_outs[[i]])$coefficients[,1]#
		positive <- TRUE#
		if (glm.prob > .5) {#
			positive <- FALSE#
		}#
		if (positive) {#
			if (y_positive[i]) {#
				out[i] <- "tp"#
			} else {#
				out[i] <- "fp"#
			}#
		} else {#
			if (y_positive[i]) {#
				out[i] <- "fn"#
			} else {#
				out[i] <- "tn"#
			}#
		}#
	}#
	coef_avg <- apply(coef_mat, 2, mean)#
	return(list(out, coef_avg))#
}
# Perform logistic regression#
# Load the following...#
# 	quantile_norm_data#
#	sample_factors#
#
factor_names <- c("viral", "bacterial")#
factors <- list(c("v_s", "v_as"), "bc")#
#
m <- nrow(quantile_norm_data)#
row_names <- vector(mode="character", length=m)#
for (i in 1:m) {#
	row_names[i] <- paste("s", i, sep="")#
}#
rownames(quantile_norm_data) <- row_names#
#
data <- quantile_norm_data[c(19, 20, 32, 86, 93, 111, 141, 165, 191, 199, 200, 201, 209, 211, 329), ]#
output <- do_log_reg(data, factors, factor_names, sample_factors)#
#
do_log_reg <- function(data, factors, factor_names, factor_vec) {#
# perform logistic regression w/ all but one sample as training set#
# data is mxn matrix with m descrbing miRNAs, n describing samples#
# Make sure data rows are labeled with names#
	create_X_and_y <- dget("R_Code/Classifiers/create_X_and_y.R")#
	X_and_y <- create_X_and_y(data, factors, factor_names, factor_vec)#
	X <- X_and_y[[1]]#
	y <- X_and_y[[2]]#
	# X is mxn where m describes samples and n describes miRNAs#
	m <- nrow(X)#
	n <- ncol(X)#
#
	classify_one_out <- dget("R_Code/Classifiers/classify_one_out.R")#
	classifier_outs <- classify_one_out(X, y, logistic_regression)#
#
	out <- analyze_log_reg_output(X, y, classifier_outs, factor_names)#
	return(out)#
}#
#
logistic_regression <- function(X, y) {#
# Perform logistic regression on matrix X with categories specified in y#
# X is mxn where m is the # of samples, n is the # of miRNAs#
# X must have column names to specify which miRNAs are in the data#
# y must only have two categories#
# output is output of glm function (logistic regression)#
	m <- nrow(X)#
	n <- ncol(X)#
	# format data frame for input into glm#
	df <- as.data.frame(X)#
	feature_names <- colnames(df)#
	df <- cbind(df,y)#
	# create formula#
	formula_str <- "y~"#
	f1 <- feature_names[1]#
	formula_str <- paste(formula_str, f1, sep="")#
	for (i in 2:n) {#
		f_name <- feature_names[i]#
		formula_str <- paste(formula_str, "+", f_name, sep="")#
	}#
	formula <- as.formula(formula_str)#
	# perform glm#
	logreg_fit <- glm(formula, family=binomial, data=df)#
	return(logreg_fit)#
}#
#
analyze_log_reg_output <- function(X, y, classifier_outs, factor_names) {#
# X is mxn matrix where m describes samples and n describes miRNAs#
	m <- nrow(X)#
	n <- ncol(X)#
	if (m != length(classifier_outs)) {#
		stop("# of classifier outputs not equal to # of samples")#
	}#
	# convert y to vector of positives (true) and negatives (false)#
	y_positive <- y == factor_names[1]#
	coef_mat <- matrix( , nrow=m, ncol=n)#
	# vector of output result compared to actual label#
	# key:#
	# tp - true positive#
	# fp - false positive#
	# tn - true negative#
	# fn - false negative#
	out <- vector(mode="character", length=m)#
	for (i in 1:m) {#
		if (i == 29) {#
			print(classifier_outs[[i]])#
		}#
		data_vec <- X[i, ]#
		df_elem <- data.frame(t(data_vec))#
		glm.prob <- predict(classifier_outs[[i]], newdata=df_elem, type="response")#
		coef_mat[i,] = summary(classifier_outs[[i]])$coefficients[,1]#
		positive <- TRUE#
		if (glm.prob > .5) {#
			positive <- FALSE#
		}#
		if (positive) {#
			if (y_positive[i]) {#
				out[i] <- "tp"#
			} else {#
				out[i] <- "fp"#
			}#
		} else {#
			if (y_positive[i]) {#
				out[i] <- "fn"#
			} else {#
				out[i] <- "tn"#
			}#
		}#
	}#
	coef_avg <- apply(coef_mat, 2, mean)#
	return(list(out, coef_avg))#
}
# Perform logistic regression#
# Load the following...#
# 	quantile_norm_data#
#	sample_factors#
#
factor_names <- c("viral", "bacterial")#
factors <- list(c("v_s", "v_as"), "bc")#
#
m <- nrow(quantile_norm_data)#
row_names <- vector(mode="character", length=m)#
for (i in 1:m) {#
	row_names[i] <- paste("s", i, sep="")#
}#
rownames(quantile_norm_data) <- row_names#
#
data <- quantile_norm_data[c(19, 20, 32, 86, 93, 111, 141, 165, 191, 199, 200, 201, 209, 211, 329), ]#
output <- do_log_reg(data, factors, factor_names, sample_factors)#
#
do_log_reg <- function(data, factors, factor_names, factor_vec) {#
# perform logistic regression w/ all but one sample as training set#
# data is mxn matrix with m descrbing miRNAs, n describing samples#
# Make sure data rows are labeled with names#
	create_X_and_y <- dget("R_Code/Classifiers/create_X_and_y.R")#
	X_and_y <- create_X_and_y(data, factors, factor_names, factor_vec)#
	X <- X_and_y[[1]]#
	y <- X_and_y[[2]]#
	# X is mxn where m describes samples and n describes miRNAs#
	m <- nrow(X)#
	n <- ncol(X)#
#
	classify_one_out <- dget("R_Code/Classifiers/classify_one_out.R")#
	classifier_outs <- classify_one_out(X, y, logistic_regression)#
#
	out <- analyze_log_reg_output(X, y, classifier_outs, factor_names)#
	return(out)#
}#
#
logistic_regression <- function(X, y) {#
# Perform logistic regression on matrix X with categories specified in y#
# X is mxn where m is the # of samples, n is the # of miRNAs#
# X must have column names to specify which miRNAs are in the data#
# y must only have two categories#
# output is output of glm function (logistic regression)#
	m <- nrow(X)#
	n <- ncol(X)#
	# format data frame for input into glm#
	df <- as.data.frame(X)#
	feature_names <- colnames(df)#
	df <- cbind(df,y)#
	# create formula#
	formula_str <- "y~"#
	f1 <- feature_names[1]#
	formula_str <- paste(formula_str, f1, sep="")#
	for (i in 2:n) {#
		f_name <- feature_names[i]#
		formula_str <- paste(formula_str, "+", f_name, sep="")#
	}#
	formula <- as.formula(formula_str)#
	# perform glm#
	logreg_fit <- glm(formula, family=binomial, data=df)#
	return(logreg_fit)#
}#
#
analyze_log_reg_output <- function(X, y, classifier_outs, factor_names) {#
# X is mxn matrix where m describes samples and n describes miRNAs#
	m <- nrow(X)#
	n <- ncol(X)#
	if (m != length(classifier_outs)) {#
		stop("# of classifier outputs not equal to # of samples")#
	}#
	# convert y to vector of positives (true) and negatives (false)#
	y_positive <- y == factor_names[1]#
	coef_mat <- matrix( , nrow=m, ncol=n)#
	# vector of output result compared to actual label#
	# key:#
	# tp - true positive#
	# fp - false positive#
	# tn - true negative#
	# fn - false negative#
	out <- vector(mode="character", length=m)#
	for (i in 1:m) {#
		if (i == 29) {#
			print(classifier_outs[[i]]$coefficients)#
		}#
		data_vec <- X[i, ]#
		df_elem <- data.frame(t(data_vec))#
		glm.prob <- predict(classifier_outs[[i]], newdata=df_elem, type="response")#
		coef_mat[i,] = summary(classifier_outs[[i]])$coefficients[,1]#
		positive <- TRUE#
		if (glm.prob > .5) {#
			positive <- FALSE#
		}#
		if (positive) {#
			if (y_positive[i]) {#
				out[i] <- "tp"#
			} else {#
				out[i] <- "fp"#
			}#
		} else {#
			if (y_positive[i]) {#
				out[i] <- "fn"#
			} else {#
				out[i] <- "tn"#
			}#
		}#
	}#
	coef_avg <- apply(coef_mat, 2, mean)#
	return(list(out, coef_avg))#
}
# Perform logistic regression#
# Load the following...#
# 	quantile_norm_data#
#	sample_factors#
#
factor_names <- c("viral", "bacterial")#
factors <- list(c("v_s", "v_as"), "bc")#
#
m <- nrow(quantile_norm_data)#
row_names <- vector(mode="character", length=m)#
for (i in 1:m) {#
	row_names[i] <- paste("s", i, sep="")#
}#
rownames(quantile_norm_data) <- row_names#
#
data <- quantile_norm_data[c(19, 20, 32, 86, 93, 111, 141, 165, 191, 199, 200, 201, 209, 211, 329), ]#
output <- do_log_reg(data, factors, factor_names, sample_factors)#
#
do_log_reg <- function(data, factors, factor_names, factor_vec) {#
# perform logistic regression w/ all but one sample as training set#
# data is mxn matrix with m descrbing miRNAs, n describing samples#
# Make sure data rows are labeled with names#
	create_X_and_y <- dget("R_Code/Classifiers/create_X_and_y.R")#
	X_and_y <- create_X_and_y(data, factors, factor_names, factor_vec)#
	X <- X_and_y[[1]]#
	y <- X_and_y[[2]]#
	# X is mxn where m describes samples and n describes miRNAs#
	m <- nrow(X)#
	n <- ncol(X)#
#
	classify_one_out <- dget("R_Code/Classifiers/classify_one_out.R")#
	classifier_outs <- classify_one_out(X, y, logistic_regression)#
#
	out <- analyze_log_reg_output(X, y, classifier_outs, factor_names)#
	return(out)#
}#
#
logistic_regression <- function(X, y) {#
# Perform logistic regression on matrix X with categories specified in y#
# X is mxn where m is the # of samples, n is the # of miRNAs#
# X must have column names to specify which miRNAs are in the data#
# y must only have two categories#
# output is output of glm function (logistic regression)#
	m <- nrow(X)#
	n <- ncol(X)#
	# format data frame for input into glm#
	df <- as.data.frame(X)#
	feature_names <- colnames(df)#
	df <- cbind(df,y)#
	# create formula#
	formula_str <- "y~"#
	f1 <- feature_names[1]#
	formula_str <- paste(formula_str, f1, sep="")#
	for (i in 2:n) {#
		f_name <- feature_names[i]#
		formula_str <- paste(formula_str, "+", f_name, sep="")#
	}#
	formula <- as.formula(formula_str)#
	# perform glm#
	logreg_fit <- glm(formula, family=binomial, data=df)#
	return(logreg_fit)#
}#
#
analyze_log_reg_output <- function(X, y, classifier_outs, factor_names) {#
# X is mxn matrix where m describes samples and n describes miRNAs#
	m <- nrow(X)#
	n <- ncol(X)#
	if (m != length(classifier_outs)) {#
		stop("# of classifier outputs not equal to # of samples")#
	}#
	# convert y to vector of positives (true) and negatives (false)#
	y_positive <- y == factor_names[1]#
	coef_mat <- matrix( , nrow=m, ncol=n)#
	# vector of output result compared to actual label#
	# key:#
	# tp - true positive#
	# fp - false positive#
	# tn - true negative#
	# fn - false negative#
	out <- vector(mode="character", length=m)#
	for (i in 1:m) {#
		if (i == 29) {#
			print(classifier_outs[[i]]$coefficients[,1])#
		}#
		data_vec <- X[i, ]#
		df_elem <- data.frame(t(data_vec))#
		glm.prob <- predict(classifier_outs[[i]], newdata=df_elem, type="response")#
		coef_mat[i,] = summary(classifier_outs[[i]])$coefficients[,1]#
		positive <- TRUE#
		if (glm.prob > .5) {#
			positive <- FALSE#
		}#
		if (positive) {#
			if (y_positive[i]) {#
				out[i] <- "tp"#
			} else {#
				out[i] <- "fp"#
			}#
		} else {#
			if (y_positive[i]) {#
				out[i] <- "fn"#
			} else {#
				out[i] <- "tn"#
			}#
		}#
	}#
	coef_avg <- apply(coef_mat, 2, mean)#
	return(list(out, coef_avg))#
}
# Perform logistic regression#
# Load the following...#
# 	quantile_norm_data#
#	sample_factors#
#
factor_names <- c("viral", "bacterial")#
factors <- list(c("v_s", "v_as"), "bc")#
#
m <- nrow(quantile_norm_data)#
row_names <- vector(mode="character", length=m)#
for (i in 1:m) {#
	row_names[i] <- paste("s", i, sep="")#
}#
rownames(quantile_norm_data) <- row_names#
#
data <- quantile_norm_data[c(19, 20, 32, 86, 93, 111, 141, 165, 191, 199, 200, 201, 209, 211, 329), ]#
output <- do_log_reg(data, factors, factor_names, sample_factors)#
#
do_log_reg <- function(data, factors, factor_names, factor_vec) {#
# perform logistic regression w/ all but one sample as training set#
# data is mxn matrix with m descrbing miRNAs, n describing samples#
# Make sure data rows are labeled with names#
	create_X_and_y <- dget("R_Code/Classifiers/create_X_and_y.R")#
	X_and_y <- create_X_and_y(data, factors, factor_names, factor_vec)#
	X <- X_and_y[[1]]#
	y <- X_and_y[[2]]#
	# X is mxn where m describes samples and n describes miRNAs#
	m <- nrow(X)#
	n <- ncol(X)#
#
	classify_one_out <- dget("R_Code/Classifiers/classify_one_out.R")#
	classifier_outs <- classify_one_out(X, y, logistic_regression)#
#
	out <- analyze_log_reg_output(X, y, classifier_outs, factor_names)#
	return(out)#
}#
#
logistic_regression <- function(X, y) {#
# Perform logistic regression on matrix X with categories specified in y#
# X is mxn where m is the # of samples, n is the # of miRNAs#
# X must have column names to specify which miRNAs are in the data#
# y must only have two categories#
# output is output of glm function (logistic regression)#
	m <- nrow(X)#
	n <- ncol(X)#
	# format data frame for input into glm#
	df <- as.data.frame(X)#
	feature_names <- colnames(df)#
	df <- cbind(df,y)#
	# create formula#
	formula_str <- "y~"#
	f1 <- feature_names[1]#
	formula_str <- paste(formula_str, f1, sep="")#
	for (i in 2:n) {#
		f_name <- feature_names[i]#
		formula_str <- paste(formula_str, "+", f_name, sep="")#
	}#
	formula <- as.formula(formula_str)#
	# perform glm#
	logreg_fit <- glm(formula, family=binomial, data=df)#
	return(logreg_fit)#
}#
#
analyze_log_reg_output <- function(X, y, classifier_outs, factor_names) {#
# X is mxn matrix where m describes samples and n describes miRNAs#
	m <- nrow(X)#
	n <- ncol(X)#
	if (m != length(classifier_outs)) {#
		stop("# of classifier outputs not equal to # of samples")#
	}#
	# convert y to vector of positives (true) and negatives (false)#
	y_positive <- y == factor_names[1]#
	coef_mat <- matrix( , nrow=m, ncol=n)#
	# vector of output result compared to actual label#
	# key:#
	# tp - true positive#
	# fp - false positive#
	# tn - true negative#
	# fn - false negative#
	out <- vector(mode="character", length=m)#
	for (i in 1:m) {#
		if (i == 28) {#
			print(classifier_outs[[i]]$coefficients[,1])#
		}#
		data_vec <- X[i, ]#
		df_elem <- data.frame(t(data_vec))#
		glm.prob <- predict(classifier_outs[[i]], newdata=df_elem, type="response")#
		coef_mat[i,] = summary(classifier_outs[[i]])$coefficients[,1]#
		positive <- TRUE#
		if (glm.prob > .5) {#
			positive <- FALSE#
		}#
		if (positive) {#
			if (y_positive[i]) {#
				out[i] <- "tp"#
			} else {#
				out[i] <- "fp"#
			}#
		} else {#
			if (y_positive[i]) {#
				out[i] <- "fn"#
			} else {#
				out[i] <- "tn"#
			}#
		}#
	}#
	coef_avg <- apply(coef_mat, 2, mean)#
	return(list(out, coef_avg))#
}
# Perform logistic regression#
# Load the following...#
# 	quantile_norm_data#
#	sample_factors#
#
factor_names <- c("viral", "bacterial")#
factors <- list(c("v_s", "v_as"), "bc")#
#
m <- nrow(quantile_norm_data)#
row_names <- vector(mode="character", length=m)#
for (i in 1:m) {#
	row_names[i] <- paste("s", i, sep="")#
}#
rownames(quantile_norm_data) <- row_names#
#
data <- quantile_norm_data[c(19, 20, 32, 86, 93, 111, 141, 165, 191, 199, 200, 201, 209, 211, 329), ]#
output <- do_log_reg(data, factors, factor_names, sample_factors)#
#
do_log_reg <- function(data, factors, factor_names, factor_vec) {#
# perform logistic regression w/ all but one sample as training set#
# data is mxn matrix with m descrbing miRNAs, n describing samples#
# Make sure data rows are labeled with names#
	create_X_and_y <- dget("R_Code/Classifiers/create_X_and_y.R")#
	X_and_y <- create_X_and_y(data, factors, factor_names, factor_vec)#
	X <- X_and_y[[1]]#
	y <- X_and_y[[2]]#
	# X is mxn where m describes samples and n describes miRNAs#
	m <- nrow(X)#
	n <- ncol(X)#
#
	classify_one_out <- dget("R_Code/Classifiers/classify_one_out.R")#
	classifier_outs <- classify_one_out(X, y, logistic_regression)#
#
	out <- analyze_log_reg_output(X, y, classifier_outs, factor_names)#
	return(out)#
}#
#
logistic_regression <- function(X, y) {#
# Perform logistic regression on matrix X with categories specified in y#
# X is mxn where m is the # of samples, n is the # of miRNAs#
# X must have column names to specify which miRNAs are in the data#
# y must only have two categories#
# output is output of glm function (logistic regression)#
	m <- nrow(X)#
	n <- ncol(X)#
	# format data frame for input into glm#
	df <- as.data.frame(X)#
	feature_names <- colnames(df)#
	df <- cbind(df,y)#
	# create formula#
	formula_str <- "y~"#
	f1 <- feature_names[1]#
	formula_str <- paste(formula_str, f1, sep="")#
	for (i in 2:n) {#
		f_name <- feature_names[i]#
		formula_str <- paste(formula_str, "+", f_name, sep="")#
	}#
	formula <- as.formula(formula_str)#
	# perform glm#
	logreg_fit <- glm(formula, family=binomial, data=df)#
	return(logreg_fit)#
}#
#
analyze_log_reg_output <- function(X, y, classifier_outs, factor_names) {#
# X is mxn matrix where m describes samples and n describes miRNAs#
	m <- nrow(X)#
	n <- ncol(X)#
	if (m != length(classifier_outs)) {#
		stop("# of classifier outputs not equal to # of samples")#
	}#
	# convert y to vector of positives (true) and negatives (false)#
	y_positive <- y == factor_names[1]#
	coef_mat <- matrix( , nrow=m, ncol=n)#
	# vector of output result compared to actual label#
	# key:#
	# tp - true positive#
	# fp - false positive#
	# tn - true negative#
	# fn - false negative#
	out <- vector(mode="character", length=m)#
	for (i in 1:m) {#
		print(i)#
		data_vec <- X[i, ]#
		df_elem <- data.frame(t(data_vec))#
		glm.prob <- predict(classifier_outs[[i]], newdata=df_elem, type="response")#
		coef_mat[i,] = summary(classifier_outs[[i]])$coefficients[,1]#
		positive <- TRUE#
		if (glm.prob > .5) {#
			positive <- FALSE#
		}#
		if (positive) {#
			if (y_positive[i]) {#
				out[i] <- "tp"#
			} else {#
				out[i] <- "fp"#
			}#
		} else {#
			if (y_positive[i]) {#
				out[i] <- "fn"#
			} else {#
				out[i] <- "tn"#
			}#
		}#
	}#
	coef_avg <- apply(coef_mat, 2, mean)#
	return(list(out, coef_avg))#
}
warnings()
# Perform logistic regression#
# Load the following...#
# 	quantile_norm_data#
#	sample_factors#
#
factor_names <- c("viral", "bacterial")#
factors <- list(c("v_s", "v_as"), "bc")#
#
m <- nrow(quantile_norm_data)#
row_names <- vector(mode="character", length=m)#
for (i in 1:m) {#
	row_names[i] <- paste("s", i, sep="")#
}#
rownames(quantile_norm_data) <- row_names#
#
data <- quantile_norm_data[c(19, 20, 32, 86, 93, 111, 141, 165, 191, 199, 200, 201, 209, 211, 329), ]#
output <- do_log_reg(data, factors, factor_names, sample_factors)#
#
do_log_reg <- function(data, factors, factor_names, factor_vec) {#
# perform logistic regression w/ all but one sample as training set#
# data is mxn matrix with m descrbing miRNAs, n describing samples#
# Make sure data rows are labeled with names#
	create_X_and_y <- dget("R_Code/Classifiers/create_X_and_y.R")#
	X_and_y <- create_X_and_y(data, factors, factor_names, factor_vec)#
	X <- X_and_y[[1]]#
	y <- X_and_y[[2]]#
	# X is mxn where m describes samples and n describes miRNAs#
	m <- nrow(X)#
	n <- ncol(X)#
#
	classify_one_out <- dget("R_Code/Classifiers/classify_one_out.R")#
	classifier_outs <- classify_one_out(X, y, logistic_regression)#
#
	out <- analyze_log_reg_output(X, y, classifier_outs, factor_names)#
	return(out)#
}#
#
logistic_regression <- function(X, y) {#
# Perform logistic regression on matrix X with categories specified in y#
# X is mxn where m is the # of samples, n is the # of miRNAs#
# X must have column names to specify which miRNAs are in the data#
# y must only have two categories#
# output is output of glm function (logistic regression)#
	m <- nrow(X)#
	n <- ncol(X)#
	# format data frame for input into glm#
	df <- as.data.frame(X)#
	feature_names <- colnames(df)#
	df <- cbind(df,y)#
	# create formula#
	formula_str <- "y~"#
	f1 <- feature_names[1]#
	formula_str <- paste(formula_str, f1, sep="")#
	for (i in 2:n) {#
		f_name <- feature_names[i]#
		formula_str <- paste(formula_str, "+", f_name, sep="")#
	}#
	formula <- as.formula(formula_str)#
	# perform glm#
	logreg_fit <- glm(formula, family=binomial, data=df)#
	return(logreg_fit)#
}#
#
analyze_log_reg_output <- function(X, y, classifier_outs, factor_names) {#
# X is mxn matrix where m describes samples and n describes miRNAs#
	m <- nrow(X)#
	n <- ncol(X)#
	if (m != length(classifier_outs)) {#
		stop("# of classifier outputs not equal to # of samples")#
	}#
	# convert y to vector of positives (true) and negatives (false)#
	y_positive <- y == factor_names[1]#
	coef_mat <- matrix( , nrow=28, ncol=n)#
	# vector of output result compared to actual label#
	# key:#
	# tp - true positive#
	# fp - false positive#
	# tn - true negative#
	# fn - false negative#
	out <- vector(mode="character", length=m)#
	for (i in 1:28) {#
		print(i)#
		data_vec <- X[i, ]#
		df_elem <- data.frame(t(data_vec))#
		glm.prob <- predict(classifier_outs[[i]], newdata=df_elem, type="response")#
		coef_mat[i,] = summary(classifier_outs[[i]])$coefficients[,1]#
		positive <- TRUE#
		if (glm.prob > .5) {#
			positive <- FALSE#
		}#
		if (positive) {#
			if (y_positive[i]) {#
				out[i] <- "tp"#
			} else {#
				out[i] <- "fp"#
			}#
		} else {#
			if (y_positive[i]) {#
				out[i] <- "fn"#
			} else {#
				out[i] <- "tn"#
			}#
		}#
	}#
	coef_avg <- apply(coef_mat, 2, mean)#
	return(list(out, coef_avg))#
}
output[[1]]
# Load the following...#
# sample_factors#
# quantile_norm_data#
#
# For reference, factors are#
# Viral Symptomatic - v_s#
# Viral Asymptomatic - v_as#
# Baseline - bl#
# Bacteria - bc#
#
# Load permtest package#
library(permtest)#
#
# Assign names for data matrix for input into permtest#
column_names <- 1:ncol(quantile_norm_data)#
colnames(quantile_norm_data) <- column_names#
#
assign_truth_table <- function(class_list, num_samples) {#
	# initialize truth_table to all false#
	truth_table <- vector(mode="logical", length=num_samples)#
	# do logical or to make all considered samples true#
	for (class in class_list) {#
		truth_vals <- sample_factors == class#
		truth_table <- truth_table | truth_vals#
	}#
	return(truth_table)#
}#
#
create_two_grps <- function(class_list_1, class_list_2) {#
# The output is a list... #
# 1. list of 1s and 2s for grp assignment#
# 2. column numbers used#
# 3. truth table for samples used#
	num_samples <- ncol(quantile_norm_data)#
	truth_table_1 <- assign_truth_table(class_list_1, num_samples)#
	truth_table_2 <- assign_truth_table(class_list_2, num_samples)#
	# get truth table for samples used in classes 1 & 2#
	samples_used <- truth_table_1 | truth_table_2#
	# find number of samples for both classes#
	num_true_1 <- length(which(truth_table_1))#
	num_true_2 <- length(which(truth_table_2))#
	num_true <- num_true_1 + num_true_2#
	# create vector of group category per sample#
	grp_vec <- vector(length=num_true)#
	# assign column names for design matrix#
	col_name_vec <- vector(length=num_true)#
	# j is current number to fill in truth_vec#
	j <- 1#
	for (i in 1:num_samples) {#
		if (truth_table_1[i]) {#
			grp_vec[j] <- 1#
			col_name_vec[j] <- i#
			j <- j + 1#
		}#
		else if (truth_table_2[i]) {#
			grp_vec[j] <- 2#
			col_name_vec[j] <- i#
			j <- j + 1#
		}#
	}#
	if (j != num_true + 1) {#
		stop("Error: Not all of truth_vec covered")#
	}#
	out <- list()#
	out[[1]] <- grp_vec#
	out[[2]] <- col_name_vec#
	out[[3]] <- samples_used#
	return(out)#
}#
#
perform_permtest <- function(class_list_1, class_list_2) {#
	out_two_grps <- create_two_grps(class_list_1, class_list_2)#
	samples_used <- out_two_grps[[3]]#
	# assign data matrix based on subset used for classes 1 & 2#
	data_matrix <- quantile_norm_data[,samples_used]#
	# create designmatrix#
	dm <- cbind(out_two_grps[[2]], out_two_grps[[1]])#
	# do permtest#
	result <- permtest(data_matrix, dm, distance="euclid", nperms=100000, designtype="random")#
	return(result)#
}#
#
# Do permutation tests#
bc_vs_v_result <- perform_permtest("bc", c("v_s", "v_as"))#
bc_vs_bl_result <- perform_permtest("bc", "bl")#
v_vs_all_result <- perform_permtest(c("v_s", "v_as"), c("bc", "bl"))#
v_vs_bl_result <- perform_permtest(c("v_s", "v_as"), c("bl"))#
#
# Write out summaries to txt files#
write.table(bc_vs_v_result, "Data_out/bacterial_vs_viral.txt", sep="\t", quote=FALSE)#
write.table(bc_vs_bl_result, "Data_out/bacterial_vs_healthy.txt", sep="\t", quote=FALSE)#
write.table(v_vs_all_result, "Data_out/viral_vs_all.txt", sep="\t", quote=FALSE)#
write.table(v_vs_bl_result, "Data_out/viral_vs_healthy.txt", sep="\t", quote=FALSE)
load("/Users/mrincredible/Box Sync/Home Folder csh36/Sharing/Data_Plus/R_Data/saved_sample_factors.r")
load("/Users/mrincredible/Box Sync/Home Folder csh36/Sharing/Data_Plus/R_Data/saved_quantile_norm_data.r")
# Load the following...#
# sample_factors#
# quantile_norm_data#
#
# For reference, factors are#
# Viral Symptomatic - v_s#
# Viral Asymptomatic - v_as#
# Baseline - bl#
# Bacteria - bc#
#
# Load permtest package#
library(permtest)#
#
# Assign names for data matrix for input into permtest#
column_names <- 1:ncol(quantile_norm_data)#
colnames(quantile_norm_data) <- column_names#
#
assign_truth_table <- function(class_list, num_samples) {#
	# initialize truth_table to all false#
	truth_table <- vector(mode="logical", length=num_samples)#
	# do logical or to make all considered samples true#
	for (class in class_list) {#
		truth_vals <- sample_factors == class#
		truth_table <- truth_table | truth_vals#
	}#
	return(truth_table)#
}#
#
create_two_grps <- function(class_list_1, class_list_2) {#
# The output is a list... #
# 1. list of 1s and 2s for grp assignment#
# 2. column numbers used#
# 3. truth table for samples used#
	num_samples <- ncol(quantile_norm_data)#
	truth_table_1 <- assign_truth_table(class_list_1, num_samples)#
	truth_table_2 <- assign_truth_table(class_list_2, num_samples)#
	# get truth table for samples used in classes 1 & 2#
	samples_used <- truth_table_1 | truth_table_2#
	# find number of samples for both classes#
	num_true_1 <- length(which(truth_table_1))#
	num_true_2 <- length(which(truth_table_2))#
	num_true <- num_true_1 + num_true_2#
	# create vector of group category per sample#
	grp_vec <- vector(length=num_true)#
	# assign column names for design matrix#
	col_name_vec <- vector(length=num_true)#
	# j is current number to fill in truth_vec#
	j <- 1#
	for (i in 1:num_samples) {#
		if (truth_table_1[i]) {#
			grp_vec[j] <- 1#
			col_name_vec[j] <- i#
			j <- j + 1#
		}#
		else if (truth_table_2[i]) {#
			grp_vec[j] <- 2#
			col_name_vec[j] <- i#
			j <- j + 1#
		}#
	}#
	if (j != num_true + 1) {#
		stop("Error: Not all of truth_vec covered")#
	}#
	out <- list()#
	out[[1]] <- grp_vec#
	out[[2]] <- col_name_vec#
	out[[3]] <- samples_used#
	return(out)#
}#
#
perform_permtest <- function(class_list_1, class_list_2) {#
	out_two_grps <- create_two_grps(class_list_1, class_list_2)#
	samples_used <- out_two_grps[[3]]#
	# assign data matrix based on subset used for classes 1 & 2#
	data_matrix <- quantile_norm_data[,samples_used]#
	# create designmatrix#
	dm <- cbind(out_two_grps[[2]], out_two_grps[[1]])#
	# do permtest#
	result <- permtest(data_matrix, dm, distance="euclid", nperms=100000, designtype="random")#
	return(result)#
}#
#
# Do permutation tests#
bc_vs_v_result <- perform_permtest("bc", c("v_s", "v_as"))#
bc_vs_bl_result <- perform_permtest("bc", "bl")#
v_vs_all_result <- perform_permtest(c("v_s", "v_as"), c("bc", "bl"))#
v_vs_bl_result <- perform_permtest(c("v_s", "v_as"), c("bl"))#
#
# Write out summaries to txt files#
write.table(bc_vs_v_result, "Data_out/bacterial_vs_viral.txt", sep="\t", quote=FALSE)#
write.table(bc_vs_bl_result, "Data_out/bacterial_vs_healthy.txt", sep="\t", quote=FALSE)#
write.table(v_vs_all_result, "Data_out/viral_vs_all.txt", sep="\t", quote=FALSE)#
write.table(v_vs_bl_result, "Data_out/viral_vs_healthy.txt", sep="\t", quote=FALSE)
install.packages("permtest")
# Load the following...#
# sample_factors#
# quantile_norm_data#
#
# For reference, factors are#
# Viral Symptomatic - v_s#
# Viral Asymptomatic - v_as#
# Baseline - bl#
# Bacteria - bc#
#
# Load permtest package#
library(permtest)#
#
# Assign names for data matrix for input into permtest#
column_names <- 1:ncol(quantile_norm_data)#
colnames(quantile_norm_data) <- column_names#
#
assign_truth_table <- function(class_list, num_samples) {#
	# initialize truth_table to all false#
	truth_table <- vector(mode="logical", length=num_samples)#
	# do logical or to make all considered samples true#
	for (class in class_list) {#
		truth_vals <- sample_factors == class#
		truth_table <- truth_table | truth_vals#
	}#
	return(truth_table)#
}#
#
create_two_grps <- function(class_list_1, class_list_2) {#
# The output is a list... #
# 1. list of 1s and 2s for grp assignment#
# 2. column numbers used#
# 3. truth table for samples used#
	num_samples <- ncol(quantile_norm_data)#
	truth_table_1 <- assign_truth_table(class_list_1, num_samples)#
	truth_table_2 <- assign_truth_table(class_list_2, num_samples)#
	# get truth table for samples used in classes 1 & 2#
	samples_used <- truth_table_1 | truth_table_2#
	# find number of samples for both classes#
	num_true_1 <- length(which(truth_table_1))#
	num_true_2 <- length(which(truth_table_2))#
	num_true <- num_true_1 + num_true_2#
	# create vector of group category per sample#
	grp_vec <- vector(length=num_true)#
	# assign column names for design matrix#
	col_name_vec <- vector(length=num_true)#
	# j is current number to fill in truth_vec#
	j <- 1#
	for (i in 1:num_samples) {#
		if (truth_table_1[i]) {#
			grp_vec[j] <- 1#
			col_name_vec[j] <- i#
			j <- j + 1#
		}#
		else if (truth_table_2[i]) {#
			grp_vec[j] <- 2#
			col_name_vec[j] <- i#
			j <- j + 1#
		}#
	}#
	if (j != num_true + 1) {#
		stop("Error: Not all of truth_vec covered")#
	}#
	out <- list()#
	out[[1]] <- grp_vec#
	out[[2]] <- col_name_vec#
	out[[3]] <- samples_used#
	return(out)#
}#
#
perform_permtest <- function(class_list_1, class_list_2) {#
	out_two_grps <- create_two_grps(class_list_1, class_list_2)#
	samples_used <- out_two_grps[[3]]#
	# assign data matrix based on subset used for classes 1 & 2#
	data_matrix <- quantile_norm_data[,samples_used]#
	# create designmatrix#
	dm <- cbind(out_two_grps[[2]], out_two_grps[[1]])#
	# do permtest#
	result <- permtest(data_matrix, dm, distance="euclid", nperms=100000, designtype="random")#
	return(result)#
}#
#
# Do permutation tests#
bc_vs_v_result <- perform_permtest("bc", c("v_s", "v_as"))#
bc_vs_bl_result <- perform_permtest("bc", "bl")#
v_vs_all_result <- perform_permtest(c("v_s", "v_as"), c("bc", "bl"))#
v_vs_bl_result <- perform_permtest(c("v_s", "v_as"), c("bl"))#
#
# Write out summaries to txt files#
write.table(bc_vs_v_result, "Data_out/bacterial_vs_viral.txt", sep="\t", quote=FALSE)#
write.table(bc_vs_bl_result, "Data_out/bacterial_vs_healthy.txt", sep="\t", quote=FALSE)#
write.table(v_vs_all_result, "Data_out/viral_vs_all.txt", sep="\t", quote=FALSE)#
write.table(v_vs_bl_result, "Data_out/viral_vs_healthy.txt", sep="\t", quote=FALSE)
